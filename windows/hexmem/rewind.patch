diff --git a/windows/hexmem/hexmem.c b/windows/hexmem/hexmem.c
index 403b2fb..bc4a3b8 100644
--- a/windows/hexmem/hexmem.c
+++ b/windows/hexmem/hexmem.c
@@ -56,68 +84,6 @@ DWORD		displayMax = 0;
 char		captureTmp[4096];
 char		drawTmp[512];
 
-#if TARGET_MSDOS == 16
-static volatile unsigned char faulted = 0;
-
-/* SS:SP + 12h = SS (fault)
- * SS:SS + 10h = SP (fault)
- * SS:SP + 0Eh = FLAGS (fault)
- * SS:SP + 0Ch = CS (fault)
- * SS:SP + 0Ah = IP (fault)
- * SS:SP + 08h = handle (internal)
- * SS:SP + 06h = interrupt number
- * SS:SP + 04h = AX (to load into DS)
- * SS:SP + 02h = CS (toolhelp.dll)
- * SS:SP + 00h = IP (toolhelp.dll)
- *
- * to pass exception on: RETF
- * to restart instruction: clear first 10 bytes of the stack, and IRET (??) */
-static void __declspec(naked) fault_pf_toolhelp() {
-	__asm {
-		.386p
-		push		ds
-		push		ax
-		push		bp
-		mov		bp,sp
-
-		/* is this a page fault? */
-		cmp		word ptr [bp+6+6],14	/* SS:SP + 06h = interrupt number */
-		jnz		pass_on
-
-		/* set the faulted flag, change the return address, then IRET directly back */
-		mov		ax,seg faulted
-		mov		ds,ax
-		mov		faulted,1
-		add		word ptr [bp+6+10],3
-		pop		bp
-		pop		ax
-		pop		ds
-		add		sp,0Ah			/* throw away handle, int number, and CS:IP return */
-		iret
-
-pass_on:	retf
-	}
-}
-
-static void __declspec(naked) fault_pf_dpmi() { /* DPMI exception handler */
-	__asm {
-		.386p
-		push		ds
-		push		ax
-		push		bp
-		mov		bp,sp
-		mov		ax,seg faulted
-		mov		ds,ax
-		mov		faulted,1
-		add		word ptr [bp+6+6],3
-		pop		bp
-		pop		ax
-		pop		ds
-		retf
-	}
-}
-#endif
-
 /* Notes and findings so far:
 
    Windows 3.1, 16-bit: The first 1MB of RAM + 64KB is mapped 1:1 to what you would get in DOS.
@@ -208,130 +191,35 @@ static int CaptureMemoryLinear(DWORD memofs,unsigned int howmuch) {
 		return 0;
 	}
 	else {
-		volatile unsigned char *d = captureTmp,cc=0;
-		UINT selector,my_ds=0,my_ss=0,my_cs=0;
+		volatile unsigned char *d = captureTmp;
+		UINT selector,my_ds=0;
 		unsigned int s=0,sf,t;
-		void far *oldDPMI;
-		int tlhelp = 0;
 		int fail=0;
 
-		/* Windows NT warning: This code works fine, but NTVDM.EXE will not pass Page Fault exceptions
-		   down to us. Instead page faults will simply cause NTVDM.EXE to exit. So beware: if you're
-		   scrolling through memory and suddenly the program disappears---that's why.
-
-		   We hook Page Fault anyway in the vain hope that some version of NT lets it pass through. */
-
-		/* OS/2 warning: Win-on-OS/2 also doesn't provide a way to catch page faults. */
-
-		/* Windows 3.0: Our DPMI-based hack also fails to catch page faults in 386 Enhanced Mode. Use Standard Mode if you need to browse through RAM */
-
-		/* WARNING WARNING WARNING!!!!!
-
-		   On actual hardware and most emulators, this code succeeds at catching page faults and safely
-		   reflecting back to the main loop.
-
-		   Tested and compatible:
-		   Windows 3.1 under QEMU
-		   Windows 95 under VirtualBox
-		   Windows 98 under VirtualBox
-
-		   DOSBox 0.74 however does NOT properly emulate the Page Fault exception (at least in a way
-		   that Windows 3.1 expects to handle). If you run this program under Windows 3.1/3.0 under
-		   DOSBox 0.74 and this code causes a Page Fault, the next thing you will see is either a)
-		   Windows freeze solid or b) Windows crash-dump to the DOS prompt or c) Windows *TRY* to
-		   crash dump to the DOS prompt and hang.
-
-		   Note that 32-bit builds of this program running under Windows 3.1 + Win32s are able to
-		   page fault without crashing erratically under DOSBox, which means that the problem probably
-		   lies in DOSBox not properly emulating the 16-bit protected mode version of the Page Fault
-		   exception.
-
-		   I will be patching DOSBox-X to better emulate the Page Fault and resolve this issue. */
-
-		/* We really only need to trap Page Fault from 386 enhanced mode Windows 3.x or Windows 9x/ME/NT.
-		   Windows 3.x "standard mode" does not involve paging */
-		if (windows_mode == WINDOWS_ENHANCED || windows_mode == WINDOWS_NT) {
-			/* Windows 3.1 or higher: Use Toolhelp.
-			   Windows 3.0: Use DPMI hacks */
-			tlhelp = (windows_mode == WINDOWS_NT) || (windows_version >= ((3 << 8) + 10)); /* Windows 3.1 or higher */
-
-			/* we may cause page faults. be prepared */
-			if (tlhelp) {
-				if (!ToolHelpInit() || __InterruptRegister == NULL || __InterruptUnRegister == NULL)
-					return howmuch;
-
-				if (!__InterruptRegister(NULL,MakeProcInstance((FARPROC)fault_pf_toolhelp,myInstance)))
-					return howmuch;
-			}
-			else {
-				oldDPMI = win16_getexhandler(14);
-				if (!win16_setexhandler(14,fault_pf_dpmi)) return howmuch;
-			}
-		}
-
 		__asm {
-			mov my_cs,cs
 			mov my_ds,ds
-			mov my_ss,ss
 		}
 
 		selector = AllocSelector(my_ds);
-		if (selector == 0) {
-			if (tlhelp) __InterruptUnRegister(NULL);
-			else win16_setexhandler(6,oldDPMI);
-			return howmuch;
-		}
+		if (selector == 0) return howmuch;
 		SetSelectorBase(selector,memofs & 0xFFFFF000UL);
 		SetSelectorLimit(selector,howmuch + 0x1000UL);
 
-		/* we need to lock our code, data, and stack in place */
-		LockSegment(my_cs);
-		LockSegment(my_ds);
-		LockSegment(my_ss);
-
 		s = (unsigned int)(memofs & 0xFFFUL);
 		sf = s + howmuch;
 		while (s < sf) {
 			t = (s | 0xFFFU) + 1U;
 			if (t > sf) t = sf;
-			faulted = 0;
-
-			while (s < t) {
-				/* we have to do it this way to exert better control over how we resume from fault */
-				__asm {
-					push	si
-					push	ds
-					mov	si,s
-					mov	ax,selector
-					mov	ds,ax
-
-					nop
-					nop
-					mov	al,[si]
-					nop
-					nop
-
-					pop	ds
-					pop	si
-					mov	cc,al
-				}
-				if (faulted) break;
-				s++; *d++ = cc;
-			}
 
-			while (s < t) {
-				s++; *d++ = 0xFF; fail++;
+			if (windows_mode == WINDOWS_ENHANCED || windows_mode == WINDOWS_NT) {
+				if (IsBadReadPtr((unsigned char far*)MK_FP(selector,s),1) == 0)
+					while (s < t) *d++ = *((volatile unsigned char far*)MK_FP(selector,s++));
+			}
+			else if (windows_mode == WINDOWS_STANDARD) {
+				while (s < t) *d++ = *((volatile unsigned char far*)MK_FP(selector,s++));
 			}
-		}
-
-		UnlockSegment(my_cs);
-		UnlockSegment(my_ds);
-		UnlockSegment(my_ss);
 
-		if (windows_mode == WINDOWS_ENHANCED || windows_mode == WINDOWS_NT) {
-			/* remove page fault handler */
-			if (tlhelp) __InterruptUnRegister(NULL);
-			else win16_setexhandler(6,oldDPMI);
+			while (s < t) { *d++ = 0xFF; s++; fail++; };
 		}
 
 		FreeSelector(selector);

