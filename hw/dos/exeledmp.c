/* NOTES:
 *
 * So far, the test material for this program on hand:
 *
 * - Windows 3.x .386 device drivers and
 *   Windows 95 .VXD device drivers
 *
 * - DOS4/GW 32-bit DOS executables compiled by Open Watcom
 *
 * - 32-bit OS/2 executables generated by Open Watcom when compiling DOSLIB.
 *
 * This code implements dumping both LE and LX formats.
 *
 * I have not yet tested this against any actual OS/2 applications or libraries.
 *
 * Not all 32-bit DOS programs are LE/LX formats. Many, such as DOOM.EXE, use an
 * undocumented "BW" type executable also supported by DOS4GW.EXE.
 *
 * OS/2 targets generated by DOSLIB are either NE if 16-bit or LX if 32-bit.
 *
 * 32-bit DOS programs and Windows VXDs appear to use ONLY internal reference fixups,
 * with (at most) the source list feature for multiple fixups in one page that refer
 * to the same target.
 *
 * Fixups generally do not use the 32-bit target offset flag unless the offset exceeds
 * 64KB, obviously.
 *
 * A quick dump of the main executable for "Estatica" is a fairly lengthy list of fixups,
 * most 32-bit, and a LOT of pages. Same result dumping the main executable for "Blood".
 *
 * Only OS/2 executables use the other types of fixup, to import symbols.
 *
 * Windows VXDs can carry 16-bit real-mode code that is executed on startup. This
 * is often carried in a third segment that does not have the BIG (32-bit) flag
 * set, and often indicates the need for a 16:16 alias.
 *
 * If you examine the entry points and non-resident name table of a Windows 386/VXD driver,
 * you'll find only one entry point with the name of the driver and _DDB at the end.
 * I wonder if Windows locates this entry point by ordinal 1 or by DRIVER_NAME + _DDB.
 * Probably ordinal 1. */

#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>

#include <hw/dos/exehdr.h>

#ifndef O_BINARY
#define O_BINARY (0)
#endif

static char*                    src_file = NULL;
static int                      src_fd = -1;

static struct exe_dos_header    exehdr;
static struct exe_dos_layout    exelayout;

static void help(void) {
    fprintf(stderr,"EXELEDMP -i <exe file>\n");
}

///////////////

#pragma pack(push,1)
struct exe_le_header {
    uint16_t        signature;                      // +0x00 0x454C 'LE'
    uint8_t         byte_order;                     // +0x02 byte order (0 = little endian  nonzero = big endian)
    uint8_t         word_order;                     // +0x03 word order (0 = little endian  nonzero = big endian)
    uint32_t        executable_format_level;        // +0x04 incremented each incompatible change to the EXE format
    uint16_t        cpu_type;                       // +0x08 cpu type (1 = 286, 2 = 386, 3 = 486, 4 = 586, and more)
    uint16_t        target_operating_system;        // +0x0A target os (1 = OS/2, 2 = windows, 3 = DOS 4.x, 4 = Windows 386)
    uint32_t        module_version;                 // +0x0C version of the EXE, for differentiating revisions of dynamic linked modules
    uint32_t        module_type_flags;              // +0x10 module flags (see enum)
    uint32_t        number_of_memory_pages;         // +0x14 number of memory pages
    uint32_t        initial_object_cs_number;       // +0x18
    uint32_t        initial_eip;                    // +0x1C
    uint32_t        initial_object_ss_number;       // +0x20
    uint32_t        initial_esp;                    // +0x24
    uint32_t        memory_page_size;               // +0x28
    uint32_t        bytes_on_last_page;             // +0x2C Like MS-DOS header, the last page is this long   NTS: LX format defines as PAGE_SHIFT
    uint32_t        fixup_section_size;             // +0x30
    uint32_t        fixup_section_checksum;         // +0x34
    uint32_t        loader_section_size;            // +0x38
    uint32_t        loader_section_checksum;        // +0x3C
    uint32_t        offset_of_object_table;         // +0x40
    uint32_t        object_table_entries;           // +0x44
    uint32_t        object_page_map_offset;         // +0x48
    uint32_t        object_iterate_data_map_offset; // +0x4C
    uint32_t        resource_table_offset;          // +0x50
    uint32_t        resource_table_entries;         // +0x54
    uint32_t        resident_names_table_offset;    // +0x58
    uint32_t        entry_table_offset;             // +0x5C
    uint32_t        module_directives_table_offset; // +0x60
    uint32_t        module_directives_entries;      // +0x64
    uint32_t        fixup_page_table_offset;        // +0x68
    uint32_t        fixup_record_table_offset;      // +0x6C
    uint32_t        imported_modules_name_table_offset;// +0x70
    uint32_t        imported_modules_count;         // +0x74
    uint32_t        imported_procedure_name_table_offset;// +0x78
    uint32_t        per_page_checksum_table_offset; // +0x7C
    uint32_t        data_pages_offset;              // +0x80 from top of file
    uint32_t        preload_page_count;             // +0x84
    uint32_t        nonresident_names_table_offset; // +0x88 from top of file
    uint32_t        nonresident_names_table_length; // +0x8C
    uint32_t        nonresident_names_table_checksum;// +0x90
    uint32_t        automatic_data_object;          // +0x94
    uint32_t        debug_information_offset;       // +0x98
    uint32_t        debug_information_length;       // +0x9C
    uint32_t        preload_instances_pages_number; // +0xA0
    uint32_t        demand_instances_pages_number;  // +0xA4
    uint32_t        extra_heap_allocation;          // +0xA8
};                                                  // =0xAC
#pragma pack(pop)
#define EXE_HEADER_LE_HEADER_SIZE           (0xAC)
#define EXE_LE_SIGNATURE                    (0x454C)
#define EXE_LX_SIGNATURE                    (0x584C)

static inline uint32_t exe_le_PAGE_SHIFT(const struct exe_le_header * const hdr) {
    if (hdr->signature == EXE_LX_SIGNATURE)
        return hdr->bytes_on_last_page;     // LX replaces with PAGE_SHIFT

    return 0;
}

#define LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_DLL_INIT            (1UL << 2UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_NO_INTERNAL_FIXUP               (1UL << 4UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_NO_EXTERNAL_FIXUP               (1UL << 5UL)

#define LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_MASK               (3UL << 8UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_UNKNOWN            (0UL << 8UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_INCOMPATIBLE       (1UL << 8UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_COMPATIBLE         (2UL << 8UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_USES_API           (3UL << 8UL)

#define LE_HEADER_MODULE_TYPE_FLAGS_MODULE_NOT_LOADABLE             (1UL << 13UL)
#define LE_HEADER_MODULE_TYPE_FLAGS_IS_DLL                          (1UL << 15UL)

#define LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_LIBRARY_TERMINATION (1UL << 31UL)

#pragma pack(push,1)
struct exe_le_header_object_table_entry {
    uint32_t        virtual_segment_size;           // +0x00 in bytes
    uint32_t        relocation_base_address;        // +0x04 base of relocation, address this object will be loaded to
    uint32_t        object_flags;                   // +0x08 object flags
    uint32_t        page_map_index;                 // +0x0C index of first object page  table
    uint32_t        page_map_entries;               // +0x10 number of object page table entries
    uint32_t        _reserved;                      // +0x14
};                                                  // =0x18
#pragma pack(pop)

#pragma pack(push,1)
// NTS: I can find the LX definition of this structure, but LE structures remain undocumented.
//      I had to reverse engineer this from what I observe in an EXE file. The data in LE files
//      makes no sense unless interpreted this way.
struct exe_le_header_object_page_table_entry {
    uint16_t        flags;                          // +0x00 flags
    uint16_t        page_data_offset;               // +0x02 offset from preload page << PAGE_SHIFT, 1-based (so subtract by 1 before shift)
};                                                  // =0x04
#pragma pack(pop)

#pragma pack(push,1)
// NTS: IBM confusingly describes each entry as if one 64-bit word, with bit field markers.
//      If you actually followed it, you'd think the page data offset were in the upper 32 bits,
//      and you'd read the fields backwards.
struct exe_lx_header_object_page_table_entry {
    uint32_t        page_data_offset;               // +0x00 offset from preload page << PAGE_SHIFT, 1-based (so subtract by 1 before shift)
    uint16_t        data_size;                      // +0x04 data size
    uint16_t        flags;                          // +0x06 flags
};                                                  // =0x08
#pragma pack(pop)

#pragma pack(push,1)
// parsed form, in parser struct
struct exe_le_header_parseinfo_object_page_table_entry {
    uint32_t        page_data_offset;               // +0x00 offset from preload page in bytes
    uint16_t        data_size;                      // +0x04 data size (from LX, or synthesized from LE)
    uint16_t        flags;                          // +0x06 flags
};                                                  // =0x08
#pragma pack(pop)

#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_READABLE                 (1UL << 0UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_WRITEABLE                (1UL << 1UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_EXECUTABLE               (1UL << 2UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESOURCE                 (1UL << 3UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_DISCARDABLE              (1UL << 4UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_SHARED                   (1UL << 5UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_PRELOAD                  (1UL << 6UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_INVALID                  (1UL << 7UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_ZEROFILLED               (1UL << 8UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESIDENT                 (1UL << 9UL) /* valid for VDD, PDD, etc */
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESIDENT_LONG_LOCKABLE   (1UL << 10UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_1616ALIAS                (1UL << 12UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_386_BIG_DEFAULT          (1UL << 13UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_CONFORMING               (1UL << 14UL)
#define LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_IO_PRIVILEGE             (1UL << 15UL)

const char *le_cpu_type_to_str(const uint8_t b) {
    switch (b) {
        case 0x01:  return "Intel 80286";
        case 0x02:  return "Intel 80386";
        case 0x03:  return "Intel 80486";
        case 0x04:  return "Intel 80586";
        case 0x20:  return "Intel i860 (N10)";
        case 0x21:  return "Intel N11";
        case 0x40:  return "MIPS Mark I (R2000/R3000)";
        case 0x41:  return "MIPS Mark II (R6000)";
        case 0x42:  return "MIPS Mark III (R4000)";
        default:    break;
    }

    return "";
}

const char *le_target_operating_system_to_str(const uint8_t b) {
    switch (b) {
        case 0x01:  return "OS/2";
        case 0x02:  return "Windows";
        case 0x03:  return "DOS 4.x";
        case 0x04:  return "Windows 386";
        default:    break;
    }

    return "";
}

// the entry table is the only part that can't be determined by any other way than
// differences in offset. to complicate matters, some fields are set to zero by
// linkers instead of NE-style where all offsets just match the prior field's offset
// to signal no table.
uint32_t le_exe_header_entry_table_size(struct exe_le_header * const h) {
    // NTS: This searches in header field order, do not re-order.
    if (h->module_directives_table_offset >= h->entry_table_offset)
        return h->module_directives_table_offset - h->entry_table_offset;
    if (h->fixup_page_table_offset >= h->entry_table_offset)
        return h->fixup_page_table_offset - h->entry_table_offset;
    if (h->fixup_record_table_offset >= h->entry_table_offset)
        return h->fixup_record_table_offset - h->entry_table_offset;
    if (h->imported_modules_name_table_offset >= h->entry_table_offset)
        return h->imported_modules_name_table_offset - h->entry_table_offset;
    if (h->imported_procedure_name_table_offset >= h->entry_table_offset)
        return h->imported_procedure_name_table_offset - h->entry_table_offset;
    if (h->per_page_checksum_table_offset >= h->entry_table_offset)
        return h->per_page_checksum_table_offset - h->entry_table_offset;
    if (h->data_pages_offset >= h->entry_table_offset)
        return h->data_pages_offset - h->entry_table_offset;

    return 0;
}

struct le_header_parseinfo {
    struct exe_le_header_parseinfo_object_page_table_entry* le_object_page_map_table;           /* [number_of_memory_pages] entries */
    struct exe_le_header_object_table_entry*                le_object_table;                    /* [object_table_entries] entries */
    uint32_t*                                               le_fixup_page_table;                /* [number_of_memory_pages + 1] entries */
    uint32_t                                                le_header_offset;
    struct exe_le_header                                    le_header;
};

uint32_t le_header_parseinfo_fixup_page_table_entries(const struct le_header_parseinfo * const h) {
    if (h->le_fixup_page_table != NULL)
        return h->le_header.number_of_memory_pages + (uint32_t)1;

    return (uint32_t)0;
}

void le_header_parseinfo_init(struct le_header_parseinfo * const h) {
    memset(h,0,sizeof(*h));
}

void le_header_parseinfo_free_object_table(struct le_header_parseinfo * const h) {
    if (h->le_object_table) free(h->le_object_table);
    h->le_object_table = NULL;
}

void le_header_parseinfo_free_object_page_map_table(struct le_header_parseinfo * const h) {
    if (h->le_object_table) free(h->le_object_page_map_table);
    h->le_object_page_map_table = NULL;
}

void le_header_parseinfo_free_fixup_page_table(struct le_header_parseinfo * const h) {
    if (h->le_fixup_page_table) free(h->le_fixup_page_table);
    h->le_fixup_page_table = NULL;
}

void le_header_parseinfo_free(struct le_header_parseinfo * const h) {
    le_header_parseinfo_free_object_page_map_table(h);
    le_header_parseinfo_free_fixup_page_table(h);
    le_header_parseinfo_free_object_table(h);
}

size_t le_header_parseinfo_get_fixup_page_table_buffer_size(struct le_header_parseinfo * const h) {
    return sizeof(uint32_t) * ((unsigned long)h->le_header.number_of_memory_pages + 1UL);
}

void le_header_parseinfo_finish_read_get_object_page_map_table(struct le_header_parseinfo * const h) {
    /* the caller read the raw data into memory.
     * we need to convert it in place to the exe_le_header_parseinfo_object_page_table_entry format.
     * conversion depend on whether it's the LE or LX format.
     *
     * There is NO protection against calling this function twice! */
    struct exe_le_header_parseinfo_object_page_table_entry *d;
    unsigned int i;

    if (h->le_header.number_of_memory_pages == 0)
        return;

    i = h->le_header.number_of_memory_pages - 1;
    d = (struct exe_le_header_parseinfo_object_page_table_entry*)h->le_object_page_map_table + i;

    /* convert backwards, in place */
    if (h->le_header.signature == EXE_LE_SIGNATURE) {
        struct exe_le_header_object_page_table_entry *s =
            ((struct exe_le_header_object_page_table_entry*)h->le_object_page_map_table) + i;

        assert(sizeof(*s) <= sizeof(*d));

        do {
            struct exe_le_header_object_page_table_entry se = *s; /* because we're converting in-place */

            d->page_data_offset =
                (((uint32_t)se.page_data_offset - (uint32_t)1) * (uint32_t)h->le_header.memory_page_size) +
                (uint32_t)h->le_header.data_pages_offset;
            d->data_size =
                (uint16_t)h->le_header.memory_page_size;
            d->flags =
                se.flags;

            d--; s--;
        } while ((i--) != 0);
    }
    else if (h->le_header.signature == EXE_LX_SIGNATURE) {
        uint32_t pshf =
            (uint32_t)exe_le_PAGE_SHIFT(&h->le_header);
        struct exe_lx_header_object_page_table_entry *s =
            ((struct exe_lx_header_object_page_table_entry*)h->le_object_page_map_table) + i;

        assert(sizeof(*s) <= sizeof(*d));

        do {
            struct exe_lx_header_object_page_table_entry se = *s; /* because we're converting in-place */

            d->page_data_offset =
                ((uint32_t)se.page_data_offset << pshf) +
                (uint32_t)h->le_header.data_pages_offset;
            d->data_size =
                se.data_size;
            d->flags =
                se.flags;

            d--; s--;
        } while ((i--) != 0);
    }
}

size_t le_header_parseinfo_get_object_page_map_table_read_buffer_size(struct le_header_parseinfo * const h) {
    if (h->le_header.signature == EXE_LE_SIGNATURE)
        return sizeof(struct exe_le_header_object_page_table_entry) * h->le_header.number_of_memory_pages;
    else if (h->le_header.signature == EXE_LX_SIGNATURE)
        return sizeof(struct exe_lx_header_object_page_table_entry) * h->le_header.number_of_memory_pages;

    return 0;
}

size_t le_header_parseinfo_get_object_page_map_table_buffer_size(struct le_header_parseinfo * const h) {
    return sizeof(struct exe_le_header_parseinfo_object_page_table_entry) * h->le_header.number_of_memory_pages;
}

size_t le_header_parseinfo_get_object_table_buffer_size(struct le_header_parseinfo * const h) {
    return sizeof(struct exe_le_header_object_table_entry) * h->le_header.object_table_entries;
}

unsigned char *le_header_parseinfo_alloc_object_page_map_table(struct le_header_parseinfo * const h) {
    const size_t sz = le_header_parseinfo_get_object_page_map_table_buffer_size(h);

    if (h->le_object_page_map_table == NULL)
        h->le_object_page_map_table = (struct exe_le_header_parseinfo_object_page_table_entry*)malloc(sz);

    return (unsigned char*)(h->le_object_page_map_table);
}

unsigned char *le_header_parseinfo_alloc_object_table(struct le_header_parseinfo * const h) {
    const size_t sz = le_header_parseinfo_get_object_table_buffer_size(h);

    if (h->le_object_table == NULL)
        h->le_object_table = (struct exe_le_header_object_table_entry*)malloc(sz);

    return (unsigned char*)(h->le_object_table);
}

unsigned char *le_header_parseinfo_alloc_fixup_page_table(struct le_header_parseinfo * const h) {
    const size_t sz = le_header_parseinfo_get_fixup_page_table_buffer_size(h);

    if (h->le_fixup_page_table == NULL)
        h->le_fixup_page_table = (uint32_t*)malloc(sz);

    return (unsigned char*)(h->le_fixup_page_table);
}

///////////////

int main(int argc,char **argv) {
    struct le_header_parseinfo le_parser;
    struct exe_le_header le_header;
    uint32_t le_header_offset;
    uint32_t file_size;
    char *a;
    int i;

    assert(sizeof(le_parser.le_header) == EXE_HEADER_LE_HEADER_SIZE);
    le_header_parseinfo_init(&le_parser);
    memset(&exehdr,0,sizeof(exehdr));

    for (i=1;i < argc;) {
        a = argv[i++];

        if (*a == '-') {
            do { a++; } while (*a == '-');

            if (!strcmp(a,"h") || !strcmp(a,"help")) {
                help();
                return 1;
            }
            else if (!strcmp(a,"i")) {
                src_file = argv[i++];
                if (src_file == NULL) return 1;
            }
            else {
                fprintf(stderr,"Unknown switch %s\n",a);
                return 1;
            }
        }
        else {
            fprintf(stderr,"Unknown switch %s\n",a);
            return 1;
        }
    }

    assert(sizeof(exehdr) == 0x1C);

    if (src_file == NULL) {
        fprintf(stderr,"No source file specified\n");
        return 1;
    }

    src_fd = open(src_file,O_RDONLY|O_BINARY);
    if (src_fd < 0) {
        fprintf(stderr,"Unable to open '%s', %s\n",src_file,strerror(errno));
        return 1;
    }

    file_size = lseek(src_fd,0,SEEK_END);
    lseek(src_fd,0,SEEK_SET);

    if (read(src_fd,&exehdr,sizeof(exehdr)) != (int)sizeof(exehdr)) {
        fprintf(stderr,"EXE header read error\n");
        return 1;
    }

    if (exehdr.magic != 0x5A4DU/*MZ*/) {
        fprintf(stderr,"EXE header signature missing\n");
        return 1;
    }

    printf("File size:                        %lu bytes\n",
        (unsigned long)file_size);
    printf("MS-DOS EXE header:\n");
    printf("    last_block_bytes:             %u bytes\n",
        exehdr.last_block_bytes);
    printf("    exe_file_blocks:              %u bytes\n",
        exehdr.exe_file_blocks);
    printf("  * exe resident size (blocks):   %lu bytes\n",
        (unsigned long)exe_dos_header_file_resident_size(&exehdr));
    printf("                                  ^  x  = %lu x 512 = %lu\n",
        (unsigned long)exehdr.exe_file_blocks,
        (unsigned long)exehdr.exe_file_blocks * 512UL);
    if (exehdr.last_block_bytes != 0U && exehdr.exe_file_blocks != 0U) {
        printf("                                  ^ (x -= 512) = %lu, last block not full 512 bytes\n",
            (unsigned long)exehdr.exe_file_blocks * 512UL - 512UL);
        printf("                                  ^ (x += %lu) = %lu, add last block bytes\n",
            (unsigned long)exehdr.last_block_bytes,
            ((unsigned long)exehdr.exe_file_blocks * 512UL) + (unsigned long)exehdr.last_block_bytes - 512UL);
    }
    printf("    number_of_relocations:        %u entries\n",
        exehdr.number_of_relocations);
    printf("  * size of relocation table:     %lu bytes\n",
        (unsigned long)exehdr.number_of_relocations * 4UL);
    printf("    header_size:                  %u paragraphs\n",
        exehdr.header_size_paragraphs);
    printf("  * header_size:                  %lu bytes\n",
        (unsigned long)exe_dos_header_file_header_size(&exehdr));
    printf("    min_additional_paragraphs:    %u paragraphs\n",
        exehdr.min_additional_paragraphs);
    printf("  * min_additional:               %lu bytes\n",
        (unsigned long)exe_dos_header_bss_size(&exehdr));
    printf("    max_additional_paragraphs:    %u paragraphs\n",
        exehdr.max_additional_paragraphs);
    printf("  * max_additional:               %lu bytes\n",
        (unsigned long)exe_dos_header_bss_max_size(&exehdr));
    printf("    init stack pointer:           base_seg+0x%04X:0x%04X\n",
        exehdr.init_stack_segment,
        exehdr.init_stack_pointer);
    printf("    checksum:                     0x%04X\n",
        exehdr.checksum);
    printf("    init instruction pointer:     base_seg+0x%04X:0x%04X\n",
        exehdr.init_code_segment,
        exehdr.init_instruction_pointer);
    printf("    relocation_table_offset:      %u bytes\n",
        exehdr.relocation_table_offset);
    printf("    overlay number:               %u\n",
        exehdr.overlay_number);

    if (exe_dos_header_to_layout(&exelayout,&exehdr) < 0) {
        fprintf(stderr,"EXE layout not appropriate for Windows NE\n");
        return 1;
    }

    if (!exe_header_can_contain_exe_extension(&exehdr)) {
        fprintf(stderr,"EXE header cannot contain extension\n");
        return 1;
    }

    /* go read the extension */
    if (lseek(src_fd,EXE_HEADER_EXTENSION_OFFSET,SEEK_SET) != EXE_HEADER_EXTENSION_OFFSET ||
        read(src_fd,&le_header_offset,4) != 4) {
        fprintf(stderr,"Cannot read extension\n");
        return 1;
    }
    printf("    EXE extension (if exists) at: %lu\n",(unsigned long)le_header_offset);
    if ((le_header_offset+EXE_HEADER_LE_HEADER_SIZE) >= file_size) {
        printf("! NE header not present (offset out of range)\n");
        return 0;
    }

    /* go read the extended header */
    if (lseek(src_fd,le_header_offset,SEEK_SET) != le_header_offset ||
        read(src_fd,&le_header,sizeof(le_header)) != sizeof(le_header)) {
        fprintf(stderr,"Cannot read LE header\n");
        return 1;
    }
    if (le_header.signature != EXE_LE_SIGNATURE &&
        le_header.signature != EXE_LX_SIGNATURE) {
        fprintf(stderr,"Not an LE/LX executable\n");
        return 1;
    }
    le_parser.le_header_offset = le_header_offset;
    le_parser.le_header = le_header;

    printf("* LE header at %lu\n",(unsigned long)le_parser.le_header_offset);
    printf("    Byte order:                     0x%02x (%s-endian)\n",
            le_header.byte_order,
            le_header.byte_order ? "big" : "little");
    printf("    Word order:                     0x%02x (%s-endian)\n",
            le_header.word_order,
            le_header.byte_order ? "big" : "little");
    printf("    Executable format level:        0x%08lx\n",
            (unsigned long)le_header.executable_format_level);
    printf("    CPU type:                       0x%02x (%s)\n",
            le_header.cpu_type,
            le_cpu_type_to_str(le_header.cpu_type));
    printf("    Target operating system:        0x%02x (%s)\n",
            le_header.target_operating_system,
            le_target_operating_system_to_str(le_header.target_operating_system));
    printf("    Module version:                 0x%08lx\n",
            (unsigned long)le_header.module_version);
    printf("    Module type flags:              0x%04lx\n",
            (unsigned long)le_header.module_type_flags);
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_DLL_INIT)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_DLL_INIT\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_NO_INTERNAL_FIXUP)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_NO_INTERNAL_FIXUP\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_NO_EXTERNAL_FIXUP)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_NO_EXTERNAL_FIXUP\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_MODULE_NOT_LOADABLE)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_MODULE_NOT_LOADABLE\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_IS_DLL)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_IS_DLL\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_LIBRARY_TERMINATION)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_LIBRARY_TERMINATION\n");
    switch (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_MASK) {
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_UNKNOWN:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_UNKNOWN\n");
            break;
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_INCOMPATIBLE:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_INCOMPATIBLE\n");
            break;
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_COMPATIBLE:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_COMPATIBLE\n");
            break;
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_USES_API:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_USES_API\n");
            break;
    };
    // ^ NTS: I would like to point out how funny it is that so far, every 32-bit DOS program I've
    //        compiled with Open Watcom has a valid LE header that indicates an OS/2 executable that
    //        is "compatible with the PM windowing system". I take this to mean that perhaps this
    //        structure was chosen for 32-bit DOS because OS/2 would run the program in a window
    //        anyway with an API available that mirrors the DOS API?

    printf("    Number of memory pages:         %lu\n",
            (unsigned long)le_header.number_of_memory_pages);
    printf("    Initial CS:IP                   segment #%lu (0x%04lx) : 0x%08lx\n",
            (unsigned long)le_header.initial_object_cs_number,
            (unsigned long)le_header.initial_object_cs_number,
            (unsigned long)le_header.initial_eip);
    printf("    Initial SS:SP                   segment #%lu (0x%04lx) : 0x%08lx\n",
            (unsigned long)le_header.initial_object_ss_number,
            (unsigned long)le_header.initial_object_ss_number,
            (unsigned long)le_header.initial_esp);
    printf("    Memory page size:               0x%08lx (%lu)\n",
            (unsigned long)le_header.memory_page_size,
            (unsigned long)le_header.memory_page_size);
    printf("    Bytes on last page:             0x%08lx (%lu)\n",
            (unsigned long)le_header.bytes_on_last_page,
            (unsigned long)le_header.bytes_on_last_page);
    printf("    Fixup section size:             0x%08lx (%lu)\n",
            (unsigned long)le_header.fixup_section_size,
            (unsigned long)le_header.fixup_section_size);
    printf("    Fixup section checksum:         0x%08lx\n",
            (unsigned long)le_header.fixup_section_checksum);
    printf("    Loader section size:            0x%08lx (%lu)\n",
            (unsigned long)le_header.loader_section_size,
            (unsigned long)le_header.loader_section_size);
    printf("    Loader section checksum:        0x%08lx\n",
            (unsigned long)le_header.loader_section_checksum);
    printf("    Offset of object table:         0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.offset_of_object_table,
            (unsigned long)le_header.offset_of_object_table,
            (unsigned long)le_header.offset_of_object_table + (unsigned long)le_header_offset,
            (unsigned long)le_header.offset_of_object_table + (unsigned long)le_header_offset);
    printf("    Object table entries:           0x%08lx (%lu)\n",
            (unsigned long)le_header.object_table_entries,
            (unsigned long)le_header.object_table_entries);
    printf("    Object page map offset:         0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.object_page_map_offset,
            (unsigned long)le_header.object_page_map_offset,
            (unsigned long)le_header.object_page_map_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.object_page_map_offset + (unsigned long)le_header_offset);
    printf("    Object iterate data map offset: 0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.object_iterate_data_map_offset,
            (unsigned long)le_header.object_iterate_data_map_offset,
            (unsigned long)le_header.object_iterate_data_map_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.object_iterate_data_map_offset + (unsigned long)le_header_offset);
    printf("    Resource table offset:          0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.resource_table_offset,
            (unsigned long)le_header.resource_table_offset,
            (unsigned long)le_header.resource_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.resource_table_offset + (unsigned long)le_header_offset);
    printf("    Resource table entries:         0x%08lx (%lu)\n",
            (unsigned long)le_header.resource_table_entries,
            (unsigned long)le_header.resource_table_entries);
    printf("    Resident names table offset:    0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.resident_names_table_offset,
            (unsigned long)le_header.resident_names_table_offset,
            (unsigned long)le_header.resident_names_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.resident_names_table_offset + (unsigned long)le_header_offset);
    printf("    Entry table offset:             0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.entry_table_offset,
            (unsigned long)le_header.entry_table_offset,
            (unsigned long)le_header.entry_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.entry_table_offset + (unsigned long)le_header_offset);
    printf("  * Entry table size:               0x%08lx (%lu)\n",
            (unsigned long)le_exe_header_entry_table_size(&le_header),
            (unsigned long)le_exe_header_entry_table_size(&le_header));
    printf("    Module directives table offset: 0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.module_directives_table_offset,
            (unsigned long)le_header.module_directives_table_offset,
            (unsigned long)le_header.module_directives_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.module_directives_table_offset + (unsigned long)le_header_offset);
    printf("    Module directives entries:      0x%08lx (%lu)\n",
            (unsigned long)le_header.module_directives_entries,
            (unsigned long)le_header.module_directives_entries);
    printf("    Fixup page table offset:        0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.fixup_page_table_offset,
            (unsigned long)le_header.fixup_page_table_offset,
            (unsigned long)le_header.fixup_page_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.fixup_page_table_offset + (unsigned long)le_header_offset);
    printf("    Fixup record table offset:      0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.fixup_record_table_offset,
            (unsigned long)le_header.fixup_record_table_offset,
            (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset);
    printf("    Imported modules name table ofs:0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.imported_modules_name_table_offset,
            (unsigned long)le_header.imported_modules_name_table_offset,
            (unsigned long)le_header.imported_modules_name_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.imported_modules_name_table_offset + (unsigned long)le_header_offset);
    printf("    Imported modules count:         0x%08lx (%lu)\n",
            (unsigned long)le_header.imported_modules_count,
            (unsigned long)le_header.imported_modules_count);
    printf("    Imported proc name table offset:0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.imported_procedure_name_table_offset,
            (unsigned long)le_header.imported_procedure_name_table_offset,
            (unsigned long)le_header.imported_procedure_name_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.imported_procedure_name_table_offset + (unsigned long)le_header_offset);
    printf("    Per-page checksum table offset: 0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.per_page_checksum_table_offset,
            (unsigned long)le_header.per_page_checksum_table_offset,
            (unsigned long)le_header.per_page_checksum_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.per_page_checksum_table_offset + (unsigned long)le_header_offset);
    printf("    Data pages offset:              0x%08lx (%lu)\n",
            (unsigned long)le_header.data_pages_offset,
            (unsigned long)le_header.data_pages_offset);
    printf("    Preload page count:             0x%08lx (%lu)\n",
            (unsigned long)le_header.preload_page_count,
            (unsigned long)le_header.preload_page_count);
    printf("    Nonresident name table offset:  0x%08lx (%lu)\n",
            (unsigned long)le_header.nonresident_names_table_offset,
            (unsigned long)le_header.nonresident_names_table_offset);
    printf("    Nonresident name table length:  0x%08lx (%lu)\n",
            (unsigned long)le_header.nonresident_names_table_length,
            (unsigned long)le_header.nonresident_names_table_length);
    printf("    Nonresident name table checksum:0x%08lx\n",
            (unsigned long)le_header.nonresident_names_table_checksum);
    printf("    Automatic data object:          0x%08lx (%lu)\n",
            (unsigned long)le_header.automatic_data_object,
            (unsigned long)le_header.automatic_data_object);
    printf("    Debug information offset:       0x%08lx (%lu)\n", /* FIXME: Relative to WHAT? */
            (unsigned long)le_header.debug_information_offset,
            (unsigned long)le_header.debug_information_offset);
    printf("    Debug information length:       0x%08lx (%lu)\n",
            (unsigned long)le_header.debug_information_length,
            (unsigned long)le_header.debug_information_length);
    printf("    Preload instances pages number: 0x%08lx (%lu)\n",
            (unsigned long)le_header.preload_instances_pages_number,
            (unsigned long)le_header.preload_instances_pages_number);
    printf("    Demand instances pages number:  0x%08lx (%lu)\n",
            (unsigned long)le_header.demand_instances_pages_number,
            (unsigned long)le_header.demand_instances_pages_number);
    printf("    Extra heap allocation:          0x%08lx (%lu)\n",
            (unsigned long)le_header.extra_heap_allocation,
            (unsigned long)le_header.extra_heap_allocation);

    if (le_header.offset_of_object_table != 0 && le_header.object_table_entries != 0) {
        unsigned long ofs = le_header.offset_of_object_table + (unsigned long)le_parser.le_header_offset;
        unsigned char *base = le_header_parseinfo_alloc_object_table(&le_parser);
        size_t readlen = le_header_parseinfo_get_object_table_buffer_size(&le_parser);

        if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,base,readlen) != readlen)
            le_header_parseinfo_free_object_table(&le_parser);
    }

    if (le_header.object_page_map_offset != 0 && le_header.number_of_memory_pages != 0) {
        unsigned long ofs = le_header.object_page_map_offset + (unsigned long)le_parser.le_header_offset;
        unsigned char *base = le_header_parseinfo_alloc_object_page_map_table(&le_parser);
        size_t readlen = le_header_parseinfo_get_object_page_map_table_read_buffer_size(&le_parser);

        if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,base,readlen) != readlen)
            le_header_parseinfo_free_object_page_map_table(&le_parser);

        /* "finish" reading by having the library convert the data in-place */
        if (le_parser.le_object_page_map_table != NULL)
            le_header_parseinfo_finish_read_get_object_page_map_table(&le_parser);
    }

    if (le_header.fixup_page_table_offset != 0 && le_header.number_of_memory_pages != 0) {
        unsigned long ofs = le_header.fixup_page_table_offset + (unsigned long)le_header_offset;
        unsigned char *base = le_header_parseinfo_alloc_fixup_page_table(&le_parser);
        size_t readlen = le_header_parseinfo_get_fixup_page_table_buffer_size(&le_parser);

        if (base != NULL) {
            // NTS: This table has one extra entry, so that you can determine the size of each fixup record entry per segment
            //      by the difference between each entry. Entries in the fixup record table (and therefore the offsets in this
            //      table) numerically increase for this reason.
            if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,le_parser.le_fixup_page_table,readlen) != (size_t)readlen)
                le_header_parseinfo_free_fixup_page_table(&le_parser);
        }
    }

    if (le_parser.le_fixup_page_table != NULL && le_header.fixup_record_table_offset != 0 && le_header.number_of_memory_pages != 0) {
        unsigned char *base,*scan,*fence;
        unsigned long ofs,sz;
        unsigned int i;

        // NTS: The le_fixup_page_table[] array is number_of_memory_pages+1 elements long
        printf("* Fixup record table, %lu entries\n",(unsigned long)le_header.number_of_memory_pages);
        for (i=0;i < le_header.number_of_memory_pages;i++) {
            if (le_parser.le_fixup_page_table[i+1] < le_parser.le_fixup_page_table[i]) {
                printf("    ! Skipping invalid entry, next offset < current offset\n");
                continue;
            }

            ofs = (unsigned long)le_parser.le_fixup_page_table[i] + (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset;
            sz = le_parser.le_fixup_page_table[i+1] - le_parser.le_fixup_page_table[i];
            printf("    Page #%u\n",i + 1);
            printf("        Offset:                         0x%08lx (%lu)\n",ofs,ofs);
            printf("        Size:                           0x%08lx (%lu)\n",sz,sz);

            if (sz != 0UL && sz < 0x40000UL) {
                base = malloc(sz);
                if (base != NULL) {
                    if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) == ofs && (unsigned long)read(src_fd,base,sz) == sz) {
                        scan = base;
                        fence = base + sz;
                        while (scan < fence) {
                            uint8_t srcoff_count,srcoff_i;
                            unsigned char src,flags;
                            int16_t srcoff;

                            /* NTS: srcoff is treated as a signed 16-bit integer for a reason.
                             *      first, don't forget these relocations are defined per page,
                             *      not overall the image. second, the LX specification says that,
                             *      to handle relocations that span pages, a separate fixup
                             *      record is specified for each page. From what I can see in
                             *      Watcom 32-bit DOS programs, it just emits a fixup record
                             *      on the next page with a negative offset.
                             *
                             *      Don't forget as a relocation relative to the page, positive
                             *      values will generally not exceed 4096 (or whatever the page
                             *      size) */

                            printf("            Entry at +%u (%lu)\n",
                                (unsigned int)(scan - base),
                                ((unsigned long)(scan - base)) + ofs);

                            src = *scan++;
                            if (src == 0 || scan >= fence) break;
                            flags = *scan++;

                            printf("                Source type:            0x%02X ",src);
                            switch (src&0xF) {
                                case 0x2:
                                    printf("16-bit selector fixup (16 bits)");
                                    break;
                                case 0x7:
                                    printf("32-bit offset fixup (32 bits)");
                                    break;
                                case 0x8:
                                    printf("32-bit self-relative offset fixup (32 bits)");
                                    break;
                                default:
                                    printf("unknown type=0x%X flags=0x%X",src&0xF,src>>4);
                                    scan = fence;
                                    break;
                            };
                            if (src & 0x10)
                                printf(" Fix-up to alias");
                            printf("\n");
                            printf("                Source flags:           0x%02X ",flags);
                            switch (flags&3) {
                                case 0x0:
                                    printf("Internal reference");
                                    break;
                                case 0x1:
                                    printf("Imported reference by ordinal");
                                    break;
                                case 0x2:
                                    printf("Imported reference by name");
                                    break;
                                case 0x3:
                                    printf("Internal reference via entry table");
                                    break;
                            };
                            if (flags&4) printf(" ADDITIVE");
                            if (flags&8) printf(" \"Internal chaining fixup\"");
                            if (flags&0x10) printf(" \"32-bit target offset\"");
                            if (flags&0x20) printf(" \"32-bit additive fixup value\"");
                            if (flags&0x40) printf(" \"16-bit object number/module ordinal\"");
                            if (flags&0x80) printf(" \"8-bit ordinal\"");
                            printf("\n");

                            if (src & 0xC0) { // bits [7:6]
                                printf("                ! Unknown source flags set, cannot continue\n");
                                break;
                            }

                            if (src & 0x20) {
                                if (scan >= fence) break;
                                srcoff_count = *scan++;//number of source offsets
                                // NTS: This is not used (as far as I can tell) with 32-bit DOS programs, but
                                //      Windows 386/VXD drivers definitely make use of this method to make
                                //      multiple fixups to the same target.
                            }
                            else {
                                srcoff_count = 1;
                            }

                            if (srcoff_count == 1) {
                                if ((scan+2) > fence) break;
                                srcoff = *((int16_t*)scan);
                                scan += 2;

                                printf("                Source offset:          0x%04X (%d)",srcoff&0xFFFFU,(int)srcoff);
                                if (srcoff < 0) printf(" (continues from previous page)"); /* explain negative numbers to avert user "WTF" responses */
                                printf("\n");
                            }

                            if ((flags&3) == 0) { // internal reference
                                uint16_t object;
                                uint32_t trgoff;

                                if (flags&0x40) {
                                    if ((scan+2) > fence) break;
                                    object = *((uint16_t*)scan); scan += 2;
                                }
                                else {
                                    if ((scan+1) > fence) break;
                                    object = *scan++;
                                }
                                printf("                Target object:          #%u\n",(unsigned int)object);

                                if ((src&0xF) != 0x2) { /* not 16-bit selector fixup */
                                    if (flags&0x10) { // 32-bit target offset
                                        if ((scan+4) > fence) break;
                                        trgoff = *((uint32_t*)scan); scan += 4;
                                    }
                                    else { // 16-bit target offset
                                        if ((scan+2) > fence) break;
                                        trgoff = *((uint16_t*)scan); scan += 2;
                                    }

                                    printf("                Target offset:          0x%08lX\n",(unsigned long)trgoff);
                                }
                                else {
                                    trgoff = 0;
                                }
                            }
                            else {
                                // TODO
                                scan = fence;
                                break;
                            }

                            for (srcoff_i=0;srcoff_i < srcoff_count;srcoff_i++) {
                                if (srcoff_count != 1) {
                                    if ((scan+2) > fence) break;
                                    srcoff = *((int16_t*)scan);
                                    scan += 2;

                                    printf("                Source offset:          0x%04X (%d)",srcoff&0xFFFFU,(int)srcoff);
                                    if (srcoff < 0) printf(" (continues from previous page)"); /* explain negative numbers to avert user "WTF" responses */
                                    printf("\n");
                                }
                            }
                        }
                    }
                    free(base);
                }
            }
        }
    }

    if (le_header.resident_names_table_offset != (uint32_t)0 &&
        le_header.entry_table_offset != (uint32_t)0 &&
        le_header.resident_names_table_offset < le_header.entry_table_offset) {
        uint32_t sz = le_header.entry_table_offset - le_header.resident_names_table_offset;
        unsigned long ofs = le_header.resident_names_table_offset + le_header_offset;

        if (sz != (uint32_t)0 && sz < (uint32_t)0x10000UL) {
            unsigned char *base,*scan,*fence,len;
            unsigned int ordinal;
            char tmp[255+1];

            printf("* Resident names table\n");

            base = malloc(sz);
            if (base != NULL) {
                if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) == ofs && (uint32_t)read(src_fd,base,sz) == sz) {
                    scan = base;
                    fence = base + sz;
                    while (scan < fence) {
                        len = *scan++;
                        if (len == 0) break;
                        if ((scan + len + 2) > fence) break;

                        if (len != 0) memcpy(tmp,scan,len);
                        tmp[len] = 0;
                        scan += len;

                        ordinal = *((uint16_t*)scan);
                        scan += 2;

                        printf("    \"%s\" ordinal %u\n",
                            tmp,ordinal);
                    }
                }
                free(base);
            }
        }
    }

    if (le_header.nonresident_names_table_offset != (uint32_t)0 &&
        le_header.nonresident_names_table_length != (uint32_t)0 &&
        le_header.nonresident_names_table_length < (uint32_t)0x20000UL) {
        unsigned char *base,*scan,*fence,len;
        unsigned int ordinal;
        char tmp[255+1];

        printf("* Non-resident names table\n");

        base = malloc(le_header.nonresident_names_table_length);
        if (base != NULL) {
            if ((unsigned long)lseek(src_fd,le_header.nonresident_names_table_offset,SEEK_SET) == le_header.nonresident_names_table_offset &&
                (uint32_t)read(src_fd,base,le_header.nonresident_names_table_length) == le_header.nonresident_names_table_length) {
                scan = base;
                fence = base + le_header.nonresident_names_table_length;
                while (scan < fence) {
                    len = *scan++;
                    if (len == 0) break;
                    if ((scan + len + 2) > fence) break;

                    if (len != 0) memcpy(tmp,scan,len);
                    tmp[len] = 0;
                    scan += len;

                    ordinal = *((uint16_t*)scan);
                    scan += 2;

                    printf("    \"%s\" ordinal %u\n",
                            tmp,ordinal);
                }
            }
            free(base);
        }
    }

    if (le_header.entry_table_offset != (uint32_t)0) {
        unsigned long ofs = le_header.entry_table_offset + le_header_offset;
        uint32_t sz = le_exe_header_entry_table_size(&le_header);

        if (sz != (uint32_t)0 && sz < (uint32_t)0x40000UL) {
            unsigned char *base,*scan,*fence;
            unsigned int i,ordinal = 1;

            base = malloc(sz);
            if (base != NULL) {
                if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) == ofs && (uint32_t)read(src_fd,base,sz) == sz) {
                    scan = base;
                    fence = base + sz;

                    printf("* Entry table\n");
                    while (scan < fence) {
                        unsigned char cnt,typ;

                        cnt = *scan++;
                        if (cnt == 0 || scan >= fence) break;
                        typ = *scan++;
                        if (scan >= fence) break;

                        if (typ == 0) {
                            for (i=0;i < cnt;i++,ordinal++) {
                                printf("    Entry #%u: empty\n",ordinal);
                            }
                        }
                        else if (typ == 1) {
                            uint16_t object,offset;
                            uint8_t flags;

                            if ((scan+2) > fence) break;
                            object = *((uint16_t*)scan); scan += 2;

                            for (i=0;i < cnt;i++,ordinal++) {
                                if ((scan+1+2) > fence) break;

                                flags = *scan++;
                                offset = *((uint16_t*)scan); scan += 2;

                                printf("    Entry #%u: 16-bit entry point\n",ordinal);
                                printf("        Object:         #%u\n",object);
                                printf("        Flags:          %02X ",flags);
                                if (flags & 1) printf("EXPORTED ");
                                if (flags & 0xF8) printf("%u parameters ",flags >> 3);
                                printf("\n");
                                printf("        Offset:         0x%04x\n",offset);
                            }
                        }
                        else if (typ == 3) {
                            uint16_t object;
                            uint32_t offset;
                            uint8_t flags;

                            if ((scan+2) > fence) break;
                            object = *((uint16_t*)scan); scan += 2;

                            for (i=0;i < cnt;i++,ordinal++) {
                                if ((scan+1+4) > fence) break;

                                flags = *scan++;
                                offset = *((uint32_t*)scan); scan += 4;

                                printf("    Entry #%u: 32-bit entry point\n",ordinal);
                                printf("        Object:         #%u\n",object);
                                printf("        Flags:          %02X ",flags);
                                if (flags & 1) printf("EXPORTED ");
                                if (flags & 0xF8) printf("%u parameters ",flags >> 3);
                                printf("\n");
                                printf("        Offset:         0x%08lx\n",(unsigned long)offset);
                            }
                        }
                        else {
                            printf("    ! Unknown block cnt=%u typ=0x%02x\n",cnt,typ);
                            break;
                        }
                    }
                }
                free(base);
            }
        }
    }

    if (le_parser.le_object_table != NULL) {
        struct exe_le_header_object_table_entry *ent;
        unsigned int i;

        printf("* Object table, %lu entries\n",(unsigned long)le_parser.le_header.object_table_entries);
        for (i=0;i < le_parser.le_header.object_table_entries;i++) {
            ent = le_parser.le_object_table + i;

            printf("    Object #%u\n",i + 1);
            printf("        Virtual segment size:           0x%08lx (%lu)\n",
                    (unsigned long)ent->virtual_segment_size,
                    (unsigned long)ent->virtual_segment_size);
            printf("        Relocation base address:        0x%08lx\n",
                    (unsigned long)ent->relocation_base_address);
            printf("        Object flags:                   0x%08lx\n",
                    (unsigned long)ent->object_flags);
            /* use a macro, save my wrists */
#define X(x) if (ent->object_flags & (x)) \
            printf("            " #x "\n");
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_READABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_WRITEABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_EXECUTABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESOURCE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_DISCARDABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_SHARED);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_PRELOAD);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_INVALID);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_ZEROFILLED);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESIDENT);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESIDENT_LONG_LOCKABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_1616ALIAS);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_386_BIG_DEFAULT);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_CONFORMING);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_IO_PRIVILEGE);
#undef X        /* end macro */
            printf("        Page map index:                 0x%08lx (%lu)\n",
                    (unsigned long)ent->page_map_index,
                    (unsigned long)ent->page_map_index);
            printf("        Page map entries:               0x%08lx (%lu)\n",
                    (unsigned long)ent->page_map_entries,
                    (unsigned long)ent->page_map_entries);
        }
    }

    if (le_parser.le_object_page_map_table != NULL) {
        unsigned int i;

        printf("* Object page map table, %lu entries\n",(unsigned long)le_parser.le_header.number_of_memory_pages);
        for (i=0;i < le_parser.le_header.number_of_memory_pages;i++) {
            struct exe_le_header_parseinfo_object_page_table_entry *ent =
                le_parser.le_object_page_map_table + i;

            printf("    Page #%u\n",i + 1);
            printf("        Flags:                          0x%04x\n",
                    (unsigned int)ent->flags);
            /* FIXME: I like how the LX specification says "the bit definitions for this word are below"
             *        and then lists an enumeration of values. So is it a bitfield or a WORD-sized enumeration, guys?
             *        Also, all the LE executables I have on hand have this field set to 0. */
            printf("        Data size:                      0x%04x bytes\n",
                    (unsigned int)ent->data_size);
            printf("        Page data offset:               %lu bytes\n",
                    (unsigned long)ent->page_data_offset);
        }
    }

    if (le_parser.le_fixup_page_table != NULL) {
        unsigned int i,mx;
        uint32_t ent;

        mx = le_header_parseinfo_fixup_page_table_entries(&le_parser);
        printf("* Fixup page table, %lu entries\n",(unsigned long)mx);

        for (i=0;i < mx;i++) {
            ent = le_parser.le_fixup_page_table[i];

            if ((i+1) == mx)
                printf("    Page #%u (end of fixup record table)\n",i + 1);
            else
                printf("    Page #%u\n",i + 1);

            printf("        Offset:                         %lu + fixup record table at %lu = file offset %lu\n",
                    (unsigned long)ent,
                    (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset,
                    (unsigned long)ent + (unsigned long)le_header_offset + (unsigned long)le_header.fixup_record_table_offset);
        }
    }

    le_header_parseinfo_free(&le_parser);
    close(src_fd);
    return 0;
}
