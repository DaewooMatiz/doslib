/* NOTES:
 *
 * So far, the test material for this program on hand:
 *
 * - Windows 3.x .386 device drivers and
 *   Windows 95 .VXD device drivers
 *
 * - DOS4/GW 32-bit DOS executables compiled by Open Watcom
 *
 * - 32-bit OS/2 executables generated by Open Watcom when compiling DOSLIB.
 *
 * This code implements dumping both LE and LX formats.
 *
 * I have not yet tested this against any actual OS/2 applications or libraries.
 *
 * Not all 32-bit DOS programs are LE/LX formats. Many, such as DOOM.EXE, use an
 * undocumented "BW" type executable also supported by DOS4GW.EXE.
 *
 * OS/2 targets generated by DOSLIB are either NE if 16-bit or LX if 32-bit.
 *
 * 32-bit DOS programs and Windows VXDs appear to use ONLY internal reference fixups,
 * with (at most) the source list feature for multiple fixups in one page that refer
 * to the same target.
 *
 * Fixups generally do not use the 32-bit target offset flag unless the offset exceeds
 * 64KB, obviously.
 *
 * A quick dump of the main executable for "Estatica" is a fairly lengthy list of fixups,
 * most 32-bit, and a LOT of pages. Same result dumping the main executable for "Blood".
 *
 * Only OS/2 executables use the other types of fixup, to import symbols.
 *
 * Windows VXDs can carry 16-bit real-mode code that is executed on startup. This
 * is often carried in a third segment that does not have the BIG (32-bit) flag
 * set, and often indicates the need for a 16:16 alias.
 *
 * If you examine the entry points and non-resident name table of a Windows 386/VXD driver,
 * you'll find only one entry point with the name of the driver and _DDB at the end.
 * I wonder if Windows locates this entry point by ordinal 1 or by DRIVER_NAME + _DDB.
 * Probably ordinal 1. */

#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>

#include <hw/dos/exehdr.h>

/* re-use a little code from the NE parser. */
#include <hw/dos/exenehdr.h>
#include <hw/dos/exenepar.h>
#include <hw/dos/exelehdr.h>
#include <hw/dos/exelepar.h>

#ifndef O_BINARY
#define O_BINARY (0)
#endif

static unsigned char            opt_sort_ordinal = 0;
static unsigned char            opt_sort_names = 0;

static char*                    src_file = NULL;
static int                      src_fd = -1;

static struct exe_dos_header    exehdr;
static struct exe_dos_layout    exelayout;

static void help(void) {
    fprintf(stderr,"EXELEDMP -i <exe file>\n");
    fprintf(stderr," -sn        Sort names\n");
    fprintf(stderr," -so        Sort by ordinal\n");
}

void print_entry_table_locate_name_by_ordinal(const struct exe_ne_header_name_entry_table * const nonresnames,const struct exe_ne_header_name_entry_table *resnames,const unsigned int ordinal) {
    char tmp[255+1];
    unsigned int i;

    if (resnames->table != NULL) {
        for (i=0;i < resnames->length;i++) {
            struct exe_ne_header_name_entry *ent = resnames->table + i;

            if (ne_name_entry_get_ordinal(resnames,ent) == ordinal) {
                ne_name_entry_get_name(tmp,sizeof(tmp),resnames,ent);
                printf(" RESIDENT NAME '%s' ",tmp);
                return;
            }
        }
    }

    if (nonresnames->table != NULL) {
        for (i=0;i < nonresnames->length;i++) {
            struct exe_ne_header_name_entry *ent = nonresnames->table + i;

            if (ne_name_entry_get_ordinal(nonresnames,ent) == ordinal) {
                ne_name_entry_get_name(tmp,sizeof(tmp),nonresnames,ent);
                printf(" NONRESIDENT NAME '%s' ",tmp);
                return;
            }
        }
    }
}

void name_entry_table_sort_by_user_options(struct exe_ne_header_name_entry_table * const t) {
    unsigned int first = 0;

    ne_name_entry_sort_by_table = t;
    if (t->raw == NULL || t->length <= 1)
        return;

    if (ne_name_entry_get_ordinal(t,&t->table[0]) == 0)
        first++;

    if (opt_sort_ordinal) {
        /* NTS: Do not sort the module name in entry 0 IF first entry is zero */
        qsort(t->table+first,t->length-first,sizeof(*(t->table)),ne_name_entry_sort_by_ordinal);
    }
    else if (opt_sort_names) {
        /* NTS: Do not sort the module name in entry 0 IF first entry is zero */
        qsort(t->table+first,t->length-first,sizeof(*(t->table)),ne_name_entry_sort_by_name);
    }
}

void print_name_table(const struct exe_ne_header_name_entry_table * const t) {
    const struct exe_ne_header_name_entry *ent = NULL;
    uint16_t ordinal;
    char tmp[255+1];
    unsigned int i;

    if (t->table == NULL || t->length == 0)
        return;

    for (i=0;i < t->length;i++) {
        ent = t->table + i;
        ordinal = ne_name_entry_get_ordinal(t,ent);
        ne_name_entry_get_name(tmp,sizeof(tmp),t,ent);

        /* NTS: LE executables do NOT reserve the first entry for module name,
         *      at least for nonresident names */
        if (ordinal == 0)
            printf("        Module name:    '%s'\n",tmp);
        else
            printf("        Ordinal #%-5d: '%s'\n",ordinal,tmp);
    }
}

///

int le_parser_is_windows_vxd(struct le_header_parseinfo * const p,uint16_t * const object,uint32_t * const offset) {
    if ((p->le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_IS_DLL) &&
        (p->le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_MASK) == LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_UNKNOWN &&
        p->le_header.target_operating_system == 0x04/*Windows 386*/ && p->le_entry_table.table != NULL && p->le_entry_table.length >= 1) {
        struct le_header_entry_table_entry *ent = p->le_entry_table.table;//ordinal 1
        unsigned char *raw;
        char tmp[255+1];
        unsigned int i;

        tmp[0] = 0;
        if (tmp[0] == 0 && p->le_resident_names.table != NULL) {
            for (i=0;i < p->le_resident_names.length;i++) {
                struct exe_ne_header_name_entry *ent = p->le_resident_names.table + i;

                if (ne_name_entry_get_ordinal(&p->le_resident_names,ent) == 1) {
                    ne_name_entry_get_name(tmp,sizeof(tmp),&p->le_resident_names,ent);
                    break;
                }
            }
        }

        if (tmp[0] == 0 && p->le_nonresident_names.table != NULL) {
            for (i=0;i < p->le_nonresident_names.length;i++) {
                struct exe_ne_header_name_entry *ent = p->le_nonresident_names.table + i;

                if (ne_name_entry_get_ordinal(&p->le_nonresident_names,ent) == 1) {
                    ne_name_entry_get_name(tmp,sizeof(tmp),&p->le_nonresident_names,ent);
                    break;
                }
            }
        }

        raw = le_header_entry_table_get_raw_entry(&p->le_entry_table,0/*ordinal 1*/); /* parser makes sure there is sufficient space for struct given type */
        if (raw != NULL && (ent->type == 3)/*32-bit*/) {
            uint32_t ent_offset;
            uint8_t flags;

            flags = *raw++;
            ent_offset = *((uint32_t*)raw); raw += 4;
            assert(raw <= (p->le_entry_table.raw+p->le_entry_table.raw_length));

            if (flags & 1/*exported*/) {
                /* is named, ends in _DDB */
                char *s = tmp + strlen(tmp) - 4;
                if (s > tmp && !strcasecmp(s,"_DDB")) {
                    *object = ent->object;
                    *offset = ent_offset;
                    return 1;
                }
            }
        }
    }

    return 0;
}

///

int main(int argc,char **argv) {
    struct le_header_parseinfo le_parser;
    struct exe_le_header le_header;
    uint32_t le_header_offset;
    uint32_t file_size;
    char *a;
    int i;

    assert(sizeof(le_parser.le_header) == EXE_HEADER_LE_HEADER_SIZE);
    le_header_parseinfo_init(&le_parser);
    memset(&exehdr,0,sizeof(exehdr));

    for (i=1;i < argc;) {
        a = argv[i++];

        if (*a == '-') {
            do { a++; } while (*a == '-');

            if (!strcmp(a,"h") || !strcmp(a,"help")) {
                help();
                return 1;
            }
            else if (!strcmp(a,"sn")) {
                opt_sort_names = 1;
            }
            else if (!strcmp(a,"so")) {
                opt_sort_ordinal = 1;
            }
            else if (!strcmp(a,"i")) {
                src_file = argv[i++];
                if (src_file == NULL) return 1;
            }
            else {
                fprintf(stderr,"Unknown switch %s\n",a);
                return 1;
            }
        }
        else {
            fprintf(stderr,"Unknown switch %s\n",a);
            return 1;
        }
    }

    assert(sizeof(exehdr) == 0x1C);

    if (src_file == NULL) {
        fprintf(stderr,"No source file specified\n");
        return 1;
    }

    src_fd = open(src_file,O_RDONLY|O_BINARY);
    if (src_fd < 0) {
        fprintf(stderr,"Unable to open '%s', %s\n",src_file,strerror(errno));
        return 1;
    }

    file_size = lseek(src_fd,0,SEEK_END);
    lseek(src_fd,0,SEEK_SET);

    if (read(src_fd,&exehdr,sizeof(exehdr)) != (int)sizeof(exehdr)) {
        fprintf(stderr,"EXE header read error\n");
        return 1;
    }

    if (exehdr.magic != 0x5A4DU/*MZ*/) {
        fprintf(stderr,"EXE header signature missing\n");
        return 1;
    }

    printf("File size:                        %lu bytes\n",
        (unsigned long)file_size);
    printf("MS-DOS EXE header:\n");
    printf("    last_block_bytes:             %u bytes\n",
        exehdr.last_block_bytes);
    printf("    exe_file_blocks:              %u bytes\n",
        exehdr.exe_file_blocks);
    printf("  * exe resident size (blocks):   %lu bytes\n",
        (unsigned long)exe_dos_header_file_resident_size(&exehdr));
    printf("                                  ^  x  = %lu x 512 = %lu\n",
        (unsigned long)exehdr.exe_file_blocks,
        (unsigned long)exehdr.exe_file_blocks * 512UL);
    if (exehdr.last_block_bytes != 0U && exehdr.exe_file_blocks != 0U) {
        printf("                                  ^ (x -= 512) = %lu, last block not full 512 bytes\n",
            (unsigned long)exehdr.exe_file_blocks * 512UL - 512UL);
        printf("                                  ^ (x += %lu) = %lu, add last block bytes\n",
            (unsigned long)exehdr.last_block_bytes,
            ((unsigned long)exehdr.exe_file_blocks * 512UL) + (unsigned long)exehdr.last_block_bytes - 512UL);
    }
    printf("    number_of_relocations:        %u entries\n",
        exehdr.number_of_relocations);
    printf("  * size of relocation table:     %lu bytes\n",
        (unsigned long)exehdr.number_of_relocations * 4UL);
    printf("    header_size:                  %u paragraphs\n",
        exehdr.header_size_paragraphs);
    printf("  * header_size:                  %lu bytes\n",
        (unsigned long)exe_dos_header_file_header_size(&exehdr));
    printf("    min_additional_paragraphs:    %u paragraphs\n",
        exehdr.min_additional_paragraphs);
    printf("  * min_additional:               %lu bytes\n",
        (unsigned long)exe_dos_header_bss_size(&exehdr));
    printf("    max_additional_paragraphs:    %u paragraphs\n",
        exehdr.max_additional_paragraphs);
    printf("  * max_additional:               %lu bytes\n",
        (unsigned long)exe_dos_header_bss_max_size(&exehdr));
    printf("    init stack pointer:           base_seg+0x%04X:0x%04X\n",
        exehdr.init_stack_segment,
        exehdr.init_stack_pointer);
    printf("    checksum:                     0x%04X\n",
        exehdr.checksum);
    printf("    init instruction pointer:     base_seg+0x%04X:0x%04X\n",
        exehdr.init_code_segment,
        exehdr.init_instruction_pointer);
    printf("    relocation_table_offset:      %u bytes\n",
        exehdr.relocation_table_offset);
    printf("    overlay number:               %u\n",
        exehdr.overlay_number);

    if (exe_dos_header_to_layout(&exelayout,&exehdr) < 0) {
        fprintf(stderr,"EXE layout not appropriate for Windows NE\n");
        return 1;
    }

    if (!exe_header_can_contain_exe_extension(&exehdr)) {
        fprintf(stderr,"EXE header cannot contain extension\n");
        return 1;
    }

    /* go read the extension */
    if (lseek(src_fd,EXE_HEADER_EXTENSION_OFFSET,SEEK_SET) != EXE_HEADER_EXTENSION_OFFSET ||
        read(src_fd,&le_header_offset,4) != 4) {
        fprintf(stderr,"Cannot read extension\n");
        return 1;
    }
    printf("    EXE extension (if exists) at: %lu\n",(unsigned long)le_header_offset);
    if ((le_header_offset+EXE_HEADER_LE_HEADER_SIZE) >= file_size) {
        printf("! NE header not present (offset out of range)\n");
        return 0;
    }

    /* go read the extended header */
    if (lseek(src_fd,le_header_offset,SEEK_SET) != le_header_offset ||
        read(src_fd,&le_header,sizeof(le_header)) != sizeof(le_header)) {
        fprintf(stderr,"Cannot read LE header\n");
        return 1;
    }
    if (le_header.signature != EXE_LE_SIGNATURE &&
        le_header.signature != EXE_LX_SIGNATURE) {
        fprintf(stderr,"Not an LE/LX executable\n");
        return 1;
    }
    le_parser.le_header_offset = le_header_offset;
    le_parser.le_header = le_header;

    printf("* LE header at %lu\n",(unsigned long)le_parser.le_header_offset);
    printf("    Byte order:                     0x%02x (%s-endian)\n",
            le_header.byte_order,
            le_header.byte_order ? "big" : "little");
    printf("    Word order:                     0x%02x (%s-endian)\n",
            le_header.word_order,
            le_header.byte_order ? "big" : "little");
    printf("    Executable format level:        0x%08lx\n",
            (unsigned long)le_header.executable_format_level);
    printf("    CPU type:                       0x%02x (%s)\n",
            le_header.cpu_type,
            le_cpu_type_to_str(le_header.cpu_type));
    printf("    Target operating system:        0x%02x (%s)\n",
            le_header.target_operating_system,
            le_target_operating_system_to_str(le_header.target_operating_system));
    printf("    Module version:                 0x%08lx\n",
            (unsigned long)le_header.module_version);
    printf("    Module type flags:              0x%04lx\n",
            (unsigned long)le_header.module_type_flags);
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_DLL_INIT)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_DLL_INIT\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_NO_INTERNAL_FIXUP)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_NO_INTERNAL_FIXUP\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_NO_EXTERNAL_FIXUP)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_NO_EXTERNAL_FIXUP\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_MODULE_NOT_LOADABLE)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_MODULE_NOT_LOADABLE\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_IS_DLL)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_IS_DLL\n");
    if (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_LIBRARY_TERMINATION)
        printf("        LE_HEADER_MODULE_TYPE_FLAGS_PER_PROCESS_LIBRARY_TERMINATION\n");
    switch (le_header.module_type_flags & LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_MASK) {
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_UNKNOWN:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_UNKNOWN\n");
            break;
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_INCOMPATIBLE:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_INCOMPATIBLE\n");
            break;
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_COMPATIBLE:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_COMPATIBLE\n");
            break;
        case LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_USES_API:
            printf("        LE_HEADER_MODULE_TYPE_FLAGS_PM_WINDOWING_USES_API\n");
            break;
    };
    // ^ NTS: I would like to point out how funny it is that so far, every 32-bit DOS program I've
    //        compiled with Open Watcom has a valid LE header that indicates an OS/2 executable that
    //        is "compatible with the PM windowing system". I take this to mean that perhaps this
    //        structure was chosen for 32-bit DOS because OS/2 would run the program in a window
    //        anyway with an API available that mirrors the DOS API?

    printf("    Number of memory pages:         %lu\n",
            (unsigned long)le_header.number_of_memory_pages);
    printf("    Initial CS:IP                   segment #%lu (0x%04lx) : 0x%08lx\n",
            (unsigned long)le_header.initial_object_cs_number,
            (unsigned long)le_header.initial_object_cs_number,
            (unsigned long)le_header.initial_eip);
    printf("    Initial SS:SP                   segment #%lu (0x%04lx) : 0x%08lx\n",
            (unsigned long)le_header.initial_object_ss_number,
            (unsigned long)le_header.initial_object_ss_number,
            (unsigned long)le_header.initial_esp);
    printf("    Memory page size:               0x%08lx (%lu)\n",
            (unsigned long)le_header.memory_page_size,
            (unsigned long)le_header.memory_page_size);
    printf("    Bytes on last page:             0x%08lx (%lu)\n",
            (unsigned long)le_header.bytes_on_last_page,
            (unsigned long)le_header.bytes_on_last_page);
    printf("    Fixup section size:             0x%08lx (%lu)\n",
            (unsigned long)le_header.fixup_section_size,
            (unsigned long)le_header.fixup_section_size);
    printf("    Fixup section checksum:         0x%08lx\n",
            (unsigned long)le_header.fixup_section_checksum);
    printf("    Loader section size:            0x%08lx (%lu)\n",
            (unsigned long)le_header.loader_section_size,
            (unsigned long)le_header.loader_section_size);
    printf("    Loader section checksum:        0x%08lx\n",
            (unsigned long)le_header.loader_section_checksum);
    printf("    Offset of object table:         0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.offset_of_object_table,
            (unsigned long)le_header.offset_of_object_table,
            (unsigned long)le_header.offset_of_object_table + (unsigned long)le_header_offset,
            (unsigned long)le_header.offset_of_object_table + (unsigned long)le_header_offset);
    printf("    Object table entries:           0x%08lx (%lu)\n",
            (unsigned long)le_header.object_table_entries,
            (unsigned long)le_header.object_table_entries);
    printf("    Object page map offset:         0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.object_page_map_offset,
            (unsigned long)le_header.object_page_map_offset,
            (unsigned long)le_header.object_page_map_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.object_page_map_offset + (unsigned long)le_header_offset);
    printf("    Object iterate data map offset: 0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.object_iterate_data_map_offset,
            (unsigned long)le_header.object_iterate_data_map_offset,
            (unsigned long)le_header.object_iterate_data_map_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.object_iterate_data_map_offset + (unsigned long)le_header_offset);
    printf("    Resource table offset:          0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.resource_table_offset,
            (unsigned long)le_header.resource_table_offset,
            (unsigned long)le_header.resource_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.resource_table_offset + (unsigned long)le_header_offset);
    printf("    Resource table entries:         0x%08lx (%lu)\n",
            (unsigned long)le_header.resource_table_entries,
            (unsigned long)le_header.resource_table_entries);
    printf("    Resident names table offset:    0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.resident_names_table_offset,
            (unsigned long)le_header.resident_names_table_offset,
            (unsigned long)le_header.resident_names_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.resident_names_table_offset + (unsigned long)le_header_offset);
    printf("    Entry table offset:             0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.entry_table_offset,
            (unsigned long)le_header.entry_table_offset,
            (unsigned long)le_header.entry_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.entry_table_offset + (unsigned long)le_header_offset);
    printf("  * Entry table size:               0x%08lx (%lu)\n",
            (unsigned long)le_exe_header_entry_table_size(&le_header),
            (unsigned long)le_exe_header_entry_table_size(&le_header));
    printf("    Module directives table offset: 0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.module_directives_table_offset,
            (unsigned long)le_header.module_directives_table_offset,
            (unsigned long)le_header.module_directives_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.module_directives_table_offset + (unsigned long)le_header_offset);
    printf("    Module directives entries:      0x%08lx (%lu)\n",
            (unsigned long)le_header.module_directives_entries,
            (unsigned long)le_header.module_directives_entries);
    printf("    Fixup page table offset:        0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.fixup_page_table_offset,
            (unsigned long)le_header.fixup_page_table_offset,
            (unsigned long)le_header.fixup_page_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.fixup_page_table_offset + (unsigned long)le_header_offset);
    printf("    Fixup record table offset:      0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.fixup_record_table_offset,
            (unsigned long)le_header.fixup_record_table_offset,
            (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset);
    printf("    Imported modules name table ofs:0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.imported_modules_name_table_offset,
            (unsigned long)le_header.imported_modules_name_table_offset,
            (unsigned long)le_header.imported_modules_name_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.imported_modules_name_table_offset + (unsigned long)le_header_offset);
    printf("    Imported modules count:         0x%08lx (%lu)\n",
            (unsigned long)le_header.imported_modules_count,
            (unsigned long)le_header.imported_modules_count);
    printf("    Imported proc name table offset:0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.imported_procedure_name_table_offset,
            (unsigned long)le_header.imported_procedure_name_table_offset,
            (unsigned long)le_header.imported_procedure_name_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.imported_procedure_name_table_offset + (unsigned long)le_header_offset);
    printf("    Per-page checksum table offset: 0x%08lx (%lu) rel to header, file offset 0x%08lx (%lu)\n",
            (unsigned long)le_header.per_page_checksum_table_offset,
            (unsigned long)le_header.per_page_checksum_table_offset,
            (unsigned long)le_header.per_page_checksum_table_offset + (unsigned long)le_header_offset,
            (unsigned long)le_header.per_page_checksum_table_offset + (unsigned long)le_header_offset);
    printf("    Data pages offset:              0x%08lx (%lu)\n",
            (unsigned long)le_header.data_pages_offset,
            (unsigned long)le_header.data_pages_offset);
    printf("    Preload page count:             0x%08lx (%lu)\n",
            (unsigned long)le_header.preload_page_count,
            (unsigned long)le_header.preload_page_count);
    printf("    Nonresident name table offset:  0x%08lx (%lu)\n",
            (unsigned long)le_header.nonresident_names_table_offset,
            (unsigned long)le_header.nonresident_names_table_offset);
    printf("    Nonresident name table length:  0x%08lx (%lu)\n",
            (unsigned long)le_header.nonresident_names_table_length,
            (unsigned long)le_header.nonresident_names_table_length);
    printf("    Nonresident name table checksum:0x%08lx\n",
            (unsigned long)le_header.nonresident_names_table_checksum);
    printf("    Automatic data object:          0x%08lx (%lu)\n",
            (unsigned long)le_header.automatic_data_object,
            (unsigned long)le_header.automatic_data_object);
    printf("    Debug information offset:       0x%08lx (%lu)\n", /* FIXME: Relative to WHAT? */
            (unsigned long)le_header.debug_information_offset,
            (unsigned long)le_header.debug_information_offset);
    printf("    Debug information length:       0x%08lx (%lu)\n",
            (unsigned long)le_header.debug_information_length,
            (unsigned long)le_header.debug_information_length);
    printf("    Preload instances pages number: 0x%08lx (%lu)\n",
            (unsigned long)le_header.preload_instances_pages_number,
            (unsigned long)le_header.preload_instances_pages_number);
    printf("    Demand instances pages number:  0x%08lx (%lu)\n",
            (unsigned long)le_header.demand_instances_pages_number,
            (unsigned long)le_header.demand_instances_pages_number);
    printf("    Extra heap allocation:          0x%08lx (%lu)\n",
            (unsigned long)le_header.extra_heap_allocation,
            (unsigned long)le_header.extra_heap_allocation);

    if (le_header.offset_of_object_table != 0 && le_header.object_table_entries != 0) {
        unsigned long ofs = le_header.offset_of_object_table + (unsigned long)le_parser.le_header_offset;
        unsigned char *base = le_header_parseinfo_alloc_object_table(&le_parser);
        size_t readlen = le_header_parseinfo_get_object_table_buffer_size(&le_parser);

        if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,base,readlen) != readlen)
            le_header_parseinfo_free_object_table(&le_parser);
    }

    if (le_header.object_page_map_offset != 0 && le_header.number_of_memory_pages != 0) {
        unsigned long ofs = le_header.object_page_map_offset + (unsigned long)le_parser.le_header_offset;
        unsigned char *base = le_header_parseinfo_alloc_object_page_map_table(&le_parser);
        size_t readlen = le_header_parseinfo_get_object_page_map_table_read_buffer_size(&le_parser);

        if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,base,readlen) != readlen)
            le_header_parseinfo_free_object_page_map_table(&le_parser);

        /* "finish" reading by having the library convert the data in-place */
        if (le_parser.le_object_page_map_table != NULL)
            le_header_parseinfo_finish_read_get_object_page_map_table(&le_parser);
    }

    if (le_header.fixup_page_table_offset != 0 && le_header.number_of_memory_pages != 0) {
        unsigned long ofs = le_header.fixup_page_table_offset + (unsigned long)le_header_offset;
        unsigned char *base = le_header_parseinfo_alloc_fixup_page_table(&le_parser);
        size_t readlen = le_header_parseinfo_get_fixup_page_table_buffer_size(&le_parser);

        if (base != NULL) {
            // NTS: This table has one extra entry, so that you can determine the size of each fixup record entry per segment
            //      by the difference between each entry. Entries in the fixup record table (and therefore the offsets in this
            //      table) numerically increase for this reason.
            if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,base,readlen) != (size_t)readlen)
                le_header_parseinfo_free_fixup_page_table(&le_parser);

            le_header_parseinfo_fixup_record_list_setup_prepare_from_page_table(&le_parser);
        }
    }

    if (le_parser.le_fixup_records.table != NULL && le_parser.le_fixup_records.length != 0) {
        struct le_header_fixup_record_table *frtable;
        unsigned char *base;
        unsigned int i;

        for (i=0;i < le_header.number_of_memory_pages;i++) {
            frtable = le_parser.le_fixup_records.table + i;

            if (frtable->file_length == 0) continue;

            base = le_header_fixup_record_table_alloc_raw(frtable,frtable->file_length);
            if (base == NULL) continue;

            if (!((unsigned long)lseek(src_fd,frtable->file_offset,SEEK_SET) == (unsigned long)frtable->file_offset &&
                (unsigned long)read(src_fd,base,frtable->file_length) == (unsigned long)frtable->file_length))
                le_header_fixup_record_table_free_raw(frtable);

            if (frtable->raw != NULL)
                le_header_fixup_record_table_parse(frtable);
        }
    }

    /* load resident name table */
    if (le_header.resident_names_table_offset != (uint32_t)0 && le_header.entry_table_offset != (uint32_t)0 &&
        le_header.resident_names_table_offset < le_header.entry_table_offset &&
        (unsigned long)lseek(src_fd,le_header.resident_names_table_offset + le_header_offset,SEEK_SET) == (le_header.resident_names_table_offset + le_header_offset)) {
        uint32_t sz = le_header.entry_table_offset - le_header.resident_names_table_offset;
        unsigned char *base;

        base = exe_ne_header_name_entry_table_alloc_raw(&le_parser.le_resident_names,sz);
        if (base != NULL) {
            if ((unsigned long)read(src_fd,base,sz) != sz)
                exe_ne_header_name_entry_table_free_raw(&le_parser.le_resident_names);
        }

        exe_ne_header_name_entry_table_parse_raw(&le_parser.le_resident_names);
        name_entry_table_sort_by_user_options(&le_parser.le_resident_names);
    }

    /* load nonresident name table */
    if (le_header.nonresident_names_table_offset != (uint32_t)0 &&
        le_header.nonresident_names_table_length != (uint32_t)0 &&
        (unsigned long)lseek(src_fd,le_header.nonresident_names_table_offset,SEEK_SET) == le_header.nonresident_names_table_offset) {
        unsigned char *base;

        base = exe_ne_header_name_entry_table_alloc_raw(&le_parser.le_nonresident_names,le_header.nonresident_names_table_length);
        if (base != NULL) {
            if ((unsigned long)read(src_fd,base,le_header.nonresident_names_table_length) != le_header.nonresident_names_table_length)
                exe_ne_header_name_entry_table_free_raw(&le_parser.le_nonresident_names);
        }

        exe_ne_header_name_entry_table_parse_raw(&le_parser.le_nonresident_names);
        name_entry_table_sort_by_user_options(&le_parser.le_nonresident_names);
    }

    if (le_header.entry_table_offset != (uint32_t)0) {
        unsigned long ofs = le_parser.le_header.entry_table_offset + le_parser.le_header_offset;
        uint32_t readlen = le_exe_header_entry_table_size(&le_parser.le_header);
        unsigned char *base = le_header_entry_table_alloc(&le_parser.le_entry_table,readlen);

        if (base != NULL) {
            // NTS: This table has one extra entry, so that you can determine the size of each fixup record entry per segment
            //      by the difference between each entry. Entries in the fixup record table (and therefore the offsets in this
            //      table) numerically increase for this reason.
            if ((unsigned long)lseek(src_fd,ofs,SEEK_SET) != ofs || (size_t)read(src_fd,base,readlen) != (size_t)readlen)
                le_header_entry_table_free(&le_parser.le_entry_table);
        }

        if (le_parser.le_entry_table.raw != NULL)
            le_header_entry_table_parse(&le_parser.le_entry_table);
    }

    if (le_parser.le_object_table != NULL) {
        struct exe_le_header_object_table_entry *ent;
        unsigned int i;

        printf("* Object table, %lu entries\n",(unsigned long)le_parser.le_header.object_table_entries);
        for (i=0;i < le_parser.le_header.object_table_entries;i++) {
            ent = le_parser.le_object_table + i;

            printf("    Object #%u\n",i + 1);
            printf("        Virtual segment size:           0x%08lx (%lu)\n",
                    (unsigned long)ent->virtual_segment_size,
                    (unsigned long)ent->virtual_segment_size);
            printf("        Relocation base address:        0x%08lx\n",
                    (unsigned long)ent->relocation_base_address);
            printf("        Object flags:                   0x%08lx\n",
                    (unsigned long)ent->object_flags);
            /* use a macro, save my wrists */
#define X(x) if (ent->object_flags & (x)) \
            printf("            " #x "\n");
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_READABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_WRITEABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_EXECUTABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESOURCE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_DISCARDABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_SHARED);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_PRELOAD);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_INVALID);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_ZEROFILLED);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESIDENT);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_RESIDENT_LONG_LOCKABLE);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_1616ALIAS);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_386_BIG_DEFAULT);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_CONFORMING);
            X(LE_HEADER_OBJECT_TABLE_ENTRY_FLAGS_IO_PRIVILEGE);
#undef X        /* end macro */
            printf("        Page map index:                 0x%08lx (%lu)\n",
                    (unsigned long)ent->page_map_index,
                    (unsigned long)ent->page_map_index);
            printf("        Page map entries:               0x%08lx (%lu)\n",
                    (unsigned long)ent->page_map_entries,
                    (unsigned long)ent->page_map_entries);
        }
    }

    /* non-resident name table */
    printf("* Non-resident name table, %u entries\n",
        (unsigned int)le_parser.le_nonresident_names.length);
    print_name_table(&le_parser.le_nonresident_names);

    /* resident name table */
    printf("* Resident name table, %u entries\n",
        (unsigned int)le_parser.le_resident_names.length);
    print_name_table(&le_parser.le_resident_names);

    if (le_parser.le_object_page_map_table != NULL) {
        unsigned int i;

        printf("* Object page map table, %lu entries\n",(unsigned long)le_parser.le_header.number_of_memory_pages);
        for (i=0;i < le_parser.le_header.number_of_memory_pages;i++) {
            struct exe_le_header_parseinfo_object_page_table_entry *ent =
                le_parser.le_object_page_map_table + i;

            printf("    Page #%u\n",i + 1);
            printf("        Flags:                          0x%04x\n",
                    (unsigned int)ent->flags);
            /* FIXME: I like how the LX specification says "the bit definitions for this word are below"
             *        and then lists an enumeration of values. So is it a bitfield or a WORD-sized enumeration, guys?
             *        Also, all the LE executables I have on hand have this field set to 0. */
            printf("        Data size:                      0x%04x bytes\n",
                    (unsigned int)ent->data_size);
            printf("        Page data offset:               %lu bytes\n",
                    (unsigned long)ent->page_data_offset);
        }
    }

    if (le_parser.le_fixup_page_table != NULL) {
        unsigned int i,mx;
        uint32_t ent;

        mx = le_header_parseinfo_fixup_page_table_entries(&le_parser);
        printf("* Fixup page table, %lu entries\n",(unsigned long)mx);

        for (i=0;i < mx;i++) {
            ent = le_parser.le_fixup_page_table[i];

            if ((i+1) == mx)
                printf("    Page #%u (end of fixup record table)\n",i + 1);
            else
                printf("    Page #%u\n",i + 1);

            printf("        Offset:                         %lu + fixup record table at %lu = file offset %lu\n",
                    (unsigned long)ent,
                    (unsigned long)le_header.fixup_record_table_offset + (unsigned long)le_header_offset,
                    (unsigned long)ent + (unsigned long)le_header_offset + (unsigned long)le_header.fixup_record_table_offset);
        }
    }

    if (le_parser.le_fixup_records.table != NULL && le_parser.le_fixup_records.length != 0 && le_parser.le_fixup_records.table != NULL) {
        struct le_header_fixup_record_table *frtable;
        unsigned char src,flags;
        unsigned char *rawfence;
        unsigned int srcoff_i;
        uint8_t srcoff_count;
        unsigned char *raw;
        unsigned int i,ti;
        int16_t srcoff;
        size_t rawlen;

        printf("* Fixup record table, %lu entries\n",(unsigned long)le_parser.le_fixup_records.length);
        for (i=0;i < le_header.number_of_memory_pages;i++) {
            frtable = le_parser.le_fixup_records.table + i;
 
            printf("    Page #%u\n",i + 1);
            printf("        Offset:                         0x%08lx (%lu)\n",
                (unsigned long)frtable->file_offset,
                (unsigned long)frtable->file_offset);
            printf("        Size:                           0x%08lx (%lu)\n",
                (unsigned long)frtable->file_length,
                (unsigned long)frtable->file_length);

            if (frtable->file_length != 0 && (frtable->raw == NULL))
                printf("        ! Unable to load into memory\n");

            for (ti=0;ti < (unsigned int)frtable->length;ti++) {
                raw = le_header_fixup_record_table_get_raw_entry(frtable,ti);
                rawlen = le_header_fixup_record_table_get_raw_entry_length(frtable,ti);
                if (raw == NULL) {
                    printf("            ! Unable to read entry %u\n",ti + 1);
                    continue;
                }
                rawfence = raw + rawlen;

                printf("            Entry %u (%zu bytes at rel=%zu file=%lu)\n",
                    ti + 1,rawlen,(size_t)(raw - frtable->raw),
                    (unsigned long)(raw - frtable->raw) + (unsigned long)frtable->file_offset);

                // caller ensures the record is long enough
                src = *raw++;
                flags = *raw++;
                printf("                Source type:            0x%02X ",src);
                switch (src&0xF) {
                    case 0x2:
                        printf("16-bit selector fixup (16 bits)");
                        break;
                    case 0x7:
                        printf("32-bit offset fixup (32 bits)");
                        break;
                    case 0x8:
                        printf("32-bit self-relative offset fixup (32 bits)");
                        break;
                    default:
                        printf("Unknown");
                        continue;
                };
                if (src & 0x10)
                    printf(" Fix-up to alias");
                printf("\n");
                printf("                Source flags:           0x%02X ",flags);
                switch (flags&3) {
                    case 0x0:
                        printf("Internal reference");
                        break;
                    case 0x1:
                        printf("Imported reference by ordinal");
                        break;
                    case 0x2:
                        printf("Imported reference by name");
                        break;
                    case 0x3:
                        printf("Internal reference via entry table");
                        break;
                };
                if (flags&4) printf(" ADDITIVE");
                if (flags&8) printf(" \"Internal chaining fixup\"");
                if (flags&0x10) printf(" \"32-bit target offset\"");
                if (flags&0x20) printf(" \"32-bit additive fixup value\"");
                if (flags&0x40) printf(" \"16-bit object number/module ordinal\"");
                if (flags&0x80) printf(" \"8-bit ordinal\"");
                printf("\n");

                if (src & 0xC0) { // bits [7:6]
                    printf("                ! Unrecognized bits!\n");
                    continue;
                }

                if (src & 0x20) {
                    srcoff_count = *raw++; //number of source offsets. object follows, then array of srcoff
                }
                else {
                    srcoff_count = 1;
                    srcoff = *((int16_t*)raw); raw += 2;
                }

                if ((flags&3) == 0) { // internal reference
                    uint16_t object;
                    uint32_t trgoff;

                    if (flags&0x40) {
                        object = *((uint16_t*)raw); raw += 2;
                    }
                    else {
                        object = *raw++;
                    }
                    printf("                Target object:          #%u\n",(unsigned int)object);

                    if ((src&0xF) != 0x2) { /* not 16-bit selector fixup */
                        if (flags&0x10) { // 32-bit target offset
                            trgoff = *((uint32_t*)raw); raw += 4;
                        }
                        else { // 16-bit target offset
                            trgoff = *((uint16_t*)raw); raw += 2;
                        }

                        printf("                Target offset:          0x%08lX\n",(unsigned long)trgoff);
                    }
                    else {
                        trgoff = 0;
                    }
                }
                else {
                    continue;
                }

                if (src & 0x20) {
                    for (srcoff_i=0;srcoff_i < srcoff_count;srcoff_i++) {
                        srcoff = *((int16_t*)raw); raw += 2;

                        printf("                Source offset:          0x%04X (%d)",srcoff&0xFFFFU,(int)srcoff);
                        if (srcoff < 0) printf(" (continues from previous page)"); /* explain negative numbers to avert user "WTF" responses */
                        printf("\n");
                    }
                }
                else {
                    printf("                Source offset:          0x%04X (%d)",srcoff&0xFFFFU,(int)srcoff);
                    if (srcoff < 0) printf(" (continues from previous page)"); /* explain negative numbers to avert user "WTF" responses */
                    printf("\n");
                }

                assert(raw <= rawfence);
            }
        }
    }

    if (le_parser.le_entry_table.table != NULL) {
        struct le_header_entry_table_entry *ent;
        unsigned char *raw;
        unsigned int i,mx;

        mx = le_parser.le_entry_table.length;
        printf("* Entry table, %lu entries\n",(unsigned long)mx);

        for (i=0;i < mx;i++) {
            ent = le_parser.le_entry_table.table + i;
            raw = le_header_entry_table_get_raw_entry(&le_parser.le_entry_table,i); /* parser makes sure there is sufficient space for struct given type */
            if (raw == NULL) continue;

            printf("    Ordinal #%u: ",i + 1);
            print_entry_table_locate_name_by_ordinal(&le_parser.le_nonresident_names,&le_parser.le_resident_names,i + 1);
            if (ent->type == 0)
                printf("empty\n");
            else if (ent->type == 2) {
                uint16_t offset;
                uint8_t flags;

                flags = *raw++;
                offset = *((uint16_t*)raw); raw += 2;
                assert(raw <= (le_parser.le_entry_table.raw+le_parser.le_entry_table.raw_length));

                printf("16-bit entry point\n");
                printf("        Object:         #%u\n",ent->object);
                printf("        Flags:          %02X ",flags);
                if (flags & 1) printf("EXPORTED ");
                if (flags & 0xF8) printf("%u parameters ",flags >> 3);
                printf("\n");
                printf("        Offset:         0x%04lx\n",(unsigned long)offset);
            }
            else if (ent->type == 3) {
                uint32_t offset;
                uint8_t flags;

                flags = *raw++;
                offset = *((uint32_t*)raw); raw += 4;
                assert(raw <= (le_parser.le_entry_table.raw+le_parser.le_entry_table.raw_length));

                printf("32-bit entry point\n");
                printf("        Object:         #%u\n",ent->object);
                printf("        Flags:          %02X ",flags);
                if (flags & 1) printf("EXPORTED ");
                if (flags & 0xF8) printf("%u parameters ",flags >> 3);
                printf("\n");
                printf("        Offset:         0x%08lx\n",(unsigned long)offset);
            }
            else {
                printf("unknown type %02x\n",ent->type);
            }
        }
    }

    {
        /* if this is a Windows VXD, then we want to locate the DDB block for more fun */
        uint16_t object=0;
        uint32_t offset=0;

        if (le_parser_is_windows_vxd(&le_parser,&object,&offset)) {
            struct windows_vxd_ddb_win31 *ddb_31;
            struct le_vmap_trackio io;
            unsigned char ddb[256];
            unsigned int i;
            char tmp[9];
            int rd;

            printf("* This appears to be a 32-bit Windows 386/VXD driver\n");
            printf("    VXD DDB block in Object #%u : 0x%08lx\n",
                (unsigned int)object,(unsigned long)offset);

            if (le_segofs_to_trackio(&io,object,offset,&le_parser)) {
                printf("        File offset %lu (0x%lX) (page #%lu at %lu + page offset 0x%lX / 0x%lX)\n",
                        (unsigned long)io.file_ofs + (unsigned long)io.page_ofs,
                        (unsigned long)io.file_ofs + (unsigned long)io.page_ofs,
                        (unsigned long)io.page_number,
                        (unsigned long)io.file_ofs,
                        (unsigned long)io.page_ofs,
                        (unsigned long)io.page_size);

                // now read it
                rd = le_trackio_read(ddb,sizeof(ddb),src_fd,&io,&le_parser);
                if (rd >= (int)sizeof(*ddb_31)) {
                    ddb_31 = (struct windows_vxd_ddb_win31*)ddb;

                    printf("        Windows 386/VXD DDB structure:\n");
                    printf("            DDB_Next:               0x%08lX\n",(unsigned long)ddb_31->DDB_Next);
                    printf("            DDB_SDK_Version:        %u.%u (0x%04X)\n",
                            ddb_31->DDB_SDK_Version>>8,
                            ddb_31->DDB_SDK_Version&0xFFU,
                            ddb_31->DDB_SDK_Version);
                    printf("            DDB_Req_Device_Number:  0x%04x\n",ddb_31->DDB_Req_Device_Number);
                    printf("            DDB_Dev_*_Version:      %u.%u\n",ddb_31->DDB_Dev_Major_Version,ddb_31->DDB_Dev_Minor_Version);
                    printf("            DDB_Flags:              0x%04x\n",ddb_31->DDB_Flags);

                    memcpy(tmp,ddb_31->DDB_Name,8); tmp[8] = 0;
                    printf("            DDB_Name:               \"%s\"\n",tmp);

                    printf("            DDB_Init_Order:         0x%08lx\n",(unsigned long)ddb_31->DDB_Init_Order);
                    printf("            DDB_Control_Proc:       0x%08lx\n",(unsigned long)ddb_31->DDB_Control_Proc);
                    printf("            DDB_V86_API_Proc:       0x%08lx\n",(unsigned long)ddb_31->DDB_V86_API_Proc);
                    printf("            DDB_PM_API_Proc:        0x%08lx\n",(unsigned long)ddb_31->DDB_PM_API_Proc);
                    printf("            DDB_V86_API_CSIP:       %04X:%04X\n",
                            (unsigned int)(ddb_31->DDB_V86_API_CSIP >> 16UL),
                            (unsigned int)(ddb_31->DDB_V86_API_CSIP & 0xFFFFUL));
                    printf("            DDB_PM_API_CSIP:        %04X:%04X\n",
                            (unsigned int)(ddb_31->DDB_PM_API_CSIP >> 16UL),
                            (unsigned int)(ddb_31->DDB_PM_API_CSIP & 0xFFFFUL));
                    printf("            DDB_Reference_Data:     0x%08lx\n",(unsigned long)ddb_31->DDB_Reference_Data);
                    printf("            DDB_Service_Table_Ptr:  0x%08lx\n",(unsigned long)ddb_31->DDB_Service_Table_Ptr);
                    printf("            DDB_Service_Table_Size: 0x%08lx\n",(unsigned long)ddb_31->DDB_Service_Table_Size);

                    // go dump the service table
                    // NTS: Some VXD drivers indicate a table size, but the offset (ptr) is zero. dumping from that location shows more zeros.
                    //      What is the meaning of that, exactly? Is it a clever way of defining the table such that the VXD can patch it with
                    //      entry points later?
                    //
                    //      Examples:
                    //        - Creative Sound Blaster 16 drivers for Windows 3.1 (VSBPD.386)
                    //        - Microsoft PCI VXD driver (pci.vxd)
                    if (ddb_31->DDB_Service_Table_Size != 0 && le_segofs_to_trackio(&io,object,ddb_31->DDB_Service_Table_Ptr,&le_parser)) {
                        uint32_t ptr;

                        printf("            DDB service table:\n");
                        for (i=0;i < (unsigned int)ddb_31->DDB_Service_Table_Size;i++) {
                            if (le_trackio_read((unsigned char*)(&ptr),sizeof(uint32_t),src_fd,&io,&le_parser) != sizeof(uint32_t))
                                break;

                            printf("                0x%08lX\n",(unsigned long)ptr);
                        }
                    }
                }
            }
        }
    }

    le_header_parseinfo_free(&le_parser);
    close(src_fd);
    return 0;
}
