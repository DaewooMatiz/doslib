     1                                  ; v86kern2.asm
     2                                  ;
     3                                  ; Test program: Proof-of-concept minimalist virtual 8086 "monitor"
     4                                  ; (C) 2010-2012 Jonathan Campbell.
     5                                  ; Hackipedia DOS library.
     6                                  ;
     7                                  ; This code is licensed under the LGPL.
     8                                  ; <insert LGPL legal text here>
     9                                  ;
    10                                  ;
    11                                  ; MODE: 16-bit real mode MS-DOS .COM executable
    12                                  ;       Assumes DS == ES == SS
    13                                  
    14                                  ; NOTES:
    15                                  ;   - This works... for the most part.
    16                                  ;   - Somehow this works even with DOSBox's funky ROM-based interrupt emulation
    17                                  ;   - The emulation provided is sufficient for real-mode exceptions including INT 3h debug and
    18                                  ;     INT 1h trace. It also handles the correct exception to permit DOS programs to use the
    19                                  ;     FPU if present.
    20                                  ;   - This program also demonstrates a minimal I/O port trapping implementation. In this example,
    21                                  ;     port 0x64 (keyboard controller command port) and port 0x92 (PS/2 & AT Port A) are intercepted
    22                                  ;     to ensure that whatever the program does, the A20 gate is always enabled. This resolves the
    23                                  ;     random crashes observed in Windows 95 DOS mode where HIMEM.SYS and the DOS kernel were
    24                                  ;     apparently playing around with the A20 line.
    25                                  ;
    26                                  ; FIXME:
    27                                  ;   - Privileged instructions like mov cr0,<reg> trigger an exception and this program makes no
    28                                  ;     attempt to emulate those instructions.
    29                                  ;     
    30                                  ;   - Whatever the BIOS does in response to CTRL+ALT+DEL it doesn't work well when we are active.
    31                                  ;
    32                                  ;   - Incomplete VCPI implementation and EMM emulation with no pages to alloc
    33                                  ;
    34                                  ;   - Paging is not enabled
    35                                  ;
    36                                  ; OTHER NOTES:
    37                                  ;   - This code makes no attempt to emulate the LDT manipulation that most BIOS implementations
    38                                  ;     apparently like to do when handling INT 15H extended memory copy. Programs that use extended
    39                                  ;     memory via HIMEM.SYS or via INT 15H will crash. [FIXED: VM86 monitor intercepts INT 15H
    40                                  ;     calls. If the function call is for extended memory copy, the VM86 monitor will carry out
    41                                  ;     the copy itself and return].
    42                                  
    43                                  ; Standard selectors in protected mode
    44                                  NULL_SEL	equ		(0 << 3)
    45                                  CODE16_SEL	equ		(1 << 3)
    46                                  DATA16_SEL	equ		(2 << 3)
    47                                  CODE32_SEL	equ		(3 << 3)
    48                                  DATA32_SEL	equ		(4 << 3)
    49                                  FLAT16_SEL	equ		(5 << 3)
    50                                  FLAT32_SEL	equ		(6 << 3)
    51                                  LDT_SEL		equ		(7 << 3)
    52                                  TSS_SEL		equ		(8 << 3)
    53                                  TSS_VM86_SEL	equ		(9 << 3)
    54                                  MAX_SEL		equ		(10 << 3)
    55                                  
    56                                  ; We reprogram the PIC to direct IRQ 0-15 to this base interrupt
    57                                  RM_INT_API	equ		0xEF
    58                                  IRQ_BASE_INT	equ		0xF0
    59                                  
    60                                  ; Extensible virtual 8086 mode kernel for DOS
    61                                  ; (C) 2011 Jonathan Campbell
    62                                  
    63                                  		bits		16
    64                                  		section		.code
    65                                  		[map		v86kern2.map]
    66                                  		org		0x100
    67                                  
    68                                  ; ============= ENTRY POINT
    69 00000000 8CC8                    		mov		ax,cs
    70 00000002 A3[5620]                		mov		word [my_realmode_seg],ax
    71 00000005 BD[0000]                		mov		bp,stack_base
    72 00000008 BC[0010]                		mov		sp,stack_init			; SP is normally at 0xFFF0 so move it back down
    73 0000000B C706[5420]0000          		mov		word [himem_sys_buffer_handle],0
    74 00000011 C706[5220]0000          		mov		word [himem_sys_buffer_phys+2],0
    75 00000017 C706[5020]0000          		mov		word [himem_sys_buffer_phys],0
    76 0000001D C706[4E20]0000          		mov		word [himem_sys_entry+2],0
    77 00000023 C706[4C20]0000          		mov		word [himem_sys_entry],0
    78 00000029 C606[8A20]00            		mov		byte [user_req_unload],0
    79 0000002E C606[E028]03            		mov		byte [user_req_iopl],3
    80 00000033 C606[8820]00            		mov		byte [irq_pending],0
    81 00000038 C606[E128]00            		mov		byte [i_am_tsr],0
    82 0000003D C606[8B20]00            		mov		byte [v86_if],0
    83 00000042 EB4E                    		jmp		_entry
    84                                  
    85                                  ; ============= CPU DETECT
    86 00000044 9C                      cpu_is_386:	pushf
    87 00000045 58                      		pop		ax
    88 00000046 25FF0F                  		and		ax,0x0FFF
    89 00000049 50                      		push		ax
    90 0000004A 9D                      		popf
    91 0000004B 9C                      		pushf
    92 0000004C 58                      		pop		ax
    93 0000004D 2500F0                  		and		ax,0xF000
    94 00000050 3D00F0                  		cmp		ax,0xF000
    95 00000053 740F                    		jz		cpu_is_386_not
    96                                  ; 286 test: EFLAGS will always have bits 12-15 clear
    97 00000055 0D00F0                  		or		ax,0xF000
    98 00000058 50                      		push		ax
    99 00000059 9D                      		popf
   100 0000005A 9C                      		pushf
   101 0000005B 58                      		pop		ax
   102 0000005C 2500F0                  		and		ax,0xF000
   103 0000005F 7403                    		jz		cpu_is_386_not
   104                                  ; it's a 386
   105 00000061 31C0                    		xor		ax,ax			; ZF=1
   106 00000063 C3                      		ret
   107 00000064 B80100                  cpu_is_386_not:	mov		ax,1
   108 00000067 09C0                    		or		ax,ax			; ZF=0
   109 00000069 C3                      		ret
   110                                  
   111                                  ; ============= EXIT WITH MESSAGE ($-terminated string at DS:DX)
   112 0000006A B409                    _exit_with_msg:	mov		ah,9
   113 0000006C CD21                    		int		21h			; fall through to _exit
   114                                  ; ============= EXIT
   115 0000006E 8CC8                    _exit:		mov		ax,cs
   116 00000070 8ED8                    		mov		ds,ax
   117 00000072 833E[5420]00            		cmp		word [himem_sys_buffer_handle],0 ; if there is a handle to free, then do it
   118 00000077 7414                    		jz		.no_handle
   119 00000079 B40D                    		mov		ah,0Dh			; HIMEM.SYS function 0Dh unlock memory block
   120 0000007B 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
   121 0000007F FF1E[4C20]              		call far	word [himem_sys_entry]
   122 00000083 B40A                    		mov		ah,0Ah			; HIMEM.SYS function 0Ah free memory block
   123 00000085 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
   124 00000089 FF1E[4C20]              		call far	word [himem_sys_entry]
   125 0000008D B8004C                  .no_handle:	mov		ax,4C00h
   126 00000090 CD21                    		int		21h
   127                                  
   128                                  ; ============= PROGRAM STARTS HERE
   129 00000092 E8AA1F                  _entry:		call		parse_argv
   130 00000095 7406                    		jz		.argv_ok
   131 00000097 BA[7101]                		mov		dx,str_help
   132 0000009A E8CDFF                  		call		_exit_with_msg
   133 0000009D E8A4FF                  .argv_ok:	call		cpu_is_386		; CHECK: 386 or higher
   134 000000A0 7405                    		jz		.is386
   135 000000A2 BA[0800]                		mov		dx,str_require_386
   136 000000A5 EBC3                    		jmp		_exit_with_msg
   137 000000A7 803E[8A20]00            .is386:		cmp		byte [user_req_unload],0; CHECK: Did user request that we unload?
   138 000000AC 7403                    		jz		.not_unload
   139 000000AE E96121                  		jmp		unload_this_program
   140 000000B1 0F01E0                  .not_unload:	smsw		ax			; CHECK: Virtual 8086 mode not already enabled
   141 000000B4 A801                    		test		al,1
   142 000000B6 7405                    		jz		.not_v86
   143 000000B8 BA[3600]                		mov		dx,str_v86_detected
   144 000000BB EBAD                    		jmp		_exit_with_msg
   145 000000BD 66813E[0000]000001-     .not_v86:	cmp		dword [himem_sys_buffer_size],64*1024	; CHECK: buffer size is 64KB or larger
   146 000000C5 00                 
   147 000000C6 7D05                    		jge		.buffer_size_large_enough
   148 000000C8 BA[2501]                		mov		dx,str_buffer_too_small
   149 000000CB EB9D                    		jmp		_exit_with_msg
   150                                  .buffer_size_large_enough:
   151 000000CD 66813E[0000]000000-     		cmp		dword [himem_sys_buffer_size],16*1024*1024
   152 000000D5 01                 
   153 000000D6 7E05                    		jle		.buffer_size_small_enough
   154 000000D8 BA[3601]                		mov		dx,str_buffer_too_large
   155 000000DB EB8D                    		jmp		_exit_with_msg
   156                                  .buffer_size_small_enough:
   157 000000DD B80043                  		mov		ax,4300h		; CHECK: HIMEM.SYS is present
   158 000000E0 CD2F                    		int		2Fh
   159 000000E2 3C80                    		cmp		al,80h
   160 000000E4 7402                    		jz		.yes_himem_sys
   161 000000E6 EB5D                    		jmp		.skip_himem
   162 000000E8 B81043                  .yes_himem_sys:	mov		ax,4310h		; Get HIMEM.SYS entry point (cannot fail)
   163 000000EB CD2F                    		int		2Fh
   164 000000ED 891E[4C20]              		mov		word [himem_sys_entry],bx
   165 000000F1 8C06[4E20]              		mov		word [himem_sys_entry+2],es
   166 000000F5 B405                    		mov		ah,5h			; HIMEM.SYS Local Enable A20
   167 000000F7 FF1E[4C20]              		call far	word [himem_sys_entry]
   168 000000FB 83F801                  		cmp		ax,1
   169 000000FE 7406                    		jz		.yes_himem_a20
   170 00000100 BA[C700]                		mov		dx,str_himem_a20_error
   171 00000103 E964FF                  		jmp		_exit_with_msg
   172 00000106 B409                    .yes_himem_a20:	mov		ah,09h			; HIMEM.SYS allocate block
   173 00000108 FA                      		cli					; <- in case BIOS interrupts do not save upper 16 bits
   174 00000109 668B16[0000]            		mov		edx,[himem_sys_buffer_size]
   175 0000010E 6681C2FF030000          		add		edx,1023
   176 00000115 66C1EA0A                		shr		edx,10			; EDX = (X BYTES+1023)/1024 KB
   177 00000119 FF1E[4C20]              		call far	word [himem_sys_entry]
   178 0000011D 83F801                  		cmp		ax,1
   179 00000120 7406                    		jz		.yes_himem_buf
   180 00000122 BA[E600]                		mov		dx,str_himem_alloc_err
   181 00000125 E942FF                  		jmp		_exit_with_msg
   182 00000128 8916[5420]              .yes_himem_buf:	mov		word [himem_sys_buffer_handle],dx ; store memory handle
   183 0000012C B40C                    		mov		ah,0Ch			; HIMEM.SYS lock memory block
   184 0000012E FF1E[4C20]              		call far	word [himem_sys_entry]	; NOTE: DX = memory handle (still)
   185 00000132 83F801                  		cmp		ax,1
   186 00000135 7406                    		jz		.yes_himem_lock
   187 00000137 BA[0601]                		mov		dx,str_himem_lock_err
   188 0000013A E92DFF                  		jmp		_exit_with_msg
   189 0000013D 891E[5020]              .yes_himem_lock:mov		word [himem_sys_buffer_phys],bx	; store DX:BX physical memory address
   190 00000141 8916[5220]              		mov		word [himem_sys_buffer_phys+2],dx
   191                                  .skip_himem:
   192                                  
   193                                  ; tss physical addrs
   194 00000145 6631C0                  		xor		eax,eax
   195 00000148 8CC8                    		mov		ax,cs
   196 0000014A 66C1E004                		shl		eax,4
   197 0000014E 6605[3E290000]          		add		eax,tss_main
   198 00000154 66A3[5C20]              		mov		[tss_phys_base],eax ; = 104 bytes
   199                                  
   200 00000158 6631C0                  		xor		eax,eax
   201 0000015B 8CC8                    		mov		ax,cs
   202 0000015D 66C1E004                		shl		eax,4
   203 00000161 6605[BE290000]          		add		eax,tss_vm86
   204 00000167 66A3[6020]              		mov		[tss_vm86_phys_base],eax ; = 8192+104 bytes
   205                                  
   206                                  ; PRINT "BUFFER AT: " + *((DWORD*)himem_sys_buffer_phys) + "\n"
   207 0000016B BA[5201]                		mov		dx,str_buffer_at
   208 0000016E E80D20                  		call		dos_puts
   209 00000171 FA                      		cli
   210 00000172 66A1[5020]              		mov		eax,[himem_sys_buffer_phys]
   211 00000176 BF[0410]                		mov		di,scratch_str
   212 00000179 E87820                  		call		eax_to_hex_16_dos
   213 0000017C 89FA                    		mov		dx,di
   214 0000017E E8FD1F                  		call		dos_puts
   215                                  
   216 00000181 FA                      		cli
   217 00000182 66A1[5020]              		mov		eax,[himem_sys_buffer_phys]
   218 00000186 660306[0000]            		add		eax,[himem_sys_buffer_size]
   219 0000018B 6648                    		dec		eax
   220 0000018D C606[0410]2D            		mov		byte [scratch_str],'-'
   221 00000192 BF[0510]                		mov		di,scratch_str+1
   222 00000195 E85C20                  		call		eax_to_hex_16_dos
   223 00000198 BA[0410]                		mov		dx,scratch_str
   224 0000019B E8E01F                  		call		dos_puts
   225                                  
   226 0000019E BA[5E01]                		mov		dx,str_crlf
   227 000001A1 E8DA1F                  		call		dos_puts
   228                                  
   229 000001A4 6631C0                  		xor		eax,eax
   230 000001A7 8CC8                    		mov		ax,cs
   231 000001A9 8EC0                    		mov		es,ax
   232 000001AB 66C1E004                		shl		eax,4
   233 000001AF 66A3[5820]              		mov		dword [my_phys_base],eax
   234                                  
   235                                  ; we use the extended memory buffer for VCPI emulation (page allocation)
   236 000001B3 66A1[5020]              		mov		eax,dword [himem_sys_buffer_phys]
   237 000001B7 66A3[EA28]              		mov		dword [vcpi_alloc_bitmap_phys],eax
   238 000001BB 66A3[EE28]              		mov		dword [vcpi_alloc_bitmap_size],eax
   239 000001BF 66A3[F228]              		mov		dword [vcpi_alloc_pages_phys],eax
   240                                  
   241 000001C3 6683F800                		cmp		eax,0
   242 000001C7 741F                    		jz		.nothing
   243                                  
   244 000001C9 660500100000            		add		eax,4096		; assume bitmap size of 4K, enough for 4MB of pages
   245 000001CF 66A3[F228]              		mov		dword [vcpi_alloc_pages_phys],eax
   246                                  
   247 000001D3 668B1E[0000]            		mov		ebx,dword [himem_sys_buffer_size]
   248 000001D8 6681C3FF0F0000          		add		ebx,0xFFF
   249 000001DF 66C1EB0F                		shr		ebx,12+3		; EBX = size of bitmap (up to 4K)
   250 000001E3 66891E[EE28]            		mov		dword [vcpi_alloc_bitmap_size],ebx
   251                                  .nothing:
   252                                  
   253                                  ; clear the IDT and GDT
   254 000001E8 FC                      		cld
   255 000001E9 31C0                    		xor		ax,ax
   256                                  
   257 000001EB B92800                  		mov		cx,MAX_SEL / 2
   258 000001EE BF[9020]                		mov		di,gdt
   259 000001F1 F3AB                    		rep		stosw
   260                                  
   261                                  ; prepare the IDTR and GDTR.
   262                                  ; real mode versions: limit=0xFFFF base=0
   263 000001F3 6631C0                  		xor		eax,eax
   264 000001F6 48                      		dec		ax			; AX = 0xFFFF
   265 000001F7 A3[8020]                		mov		word [idtr_real],ax
   266 000001FA A3[7020]                		mov		word [gdtr_real],ax
   267 000001FD 40                      		inc		ax
   268 000001FE 66A3[8220]              		mov		dword [idtr_real+2],eax
   269 00000202 66A3[7220]              		mov		dword [gdtr_real+2],eax
   270                                  ; protected mode GDTR limit=MAX_SEL-1 base=(code segment)+var
   271 00000206 C706[6820]4F00          		mov		word [gdtr_pmode],MAX_SEL - 1
   272 0000020C C706[7820]FF07          		mov		word [idtr_pmode],(256 << 3) - 1
   273 00000212 66A1[5820]              		mov		eax,[my_phys_base]
   274 00000216 6605[90200000]          		add		eax,gdt
   275 0000021C 66A3[6A20]              		mov		dword [gdtr_pmode+2],eax
   276 00000220 66A1[5820]              		mov		eax,[my_phys_base]
   277 00000224 6605[E0200000]          		add		eax,idt
   278 0000022A 66A3[7A20]              		mov		dword [idtr_pmode+2],eax
   279                                  
   280                                  ; build the GDT
   281 0000022E FC                      		cld
   282 0000022F 8D3E[9820]              		lea		di,[gdt+CODE16_SEL]
   283                                  ; Code selector (CODE_16SEL)
   284 00000233 48                      		dec		ax			; 0x0000 - 1 = 0xFFFF
   285 00000234 AB                      		stosw					; LIMIT
   286 00000235 A1[5820]                		mov		ax,[my_phys_base]
   287 00000238 AB                      		stosw					; BASE[15:0]
   288 00000239 A0[5A20]                		mov		al,[my_phys_base+2]
   289 0000023C B49A                    		mov		ah,0x9A
   290 0000023E AB                      		stosw					; BASE[23:16] access byte=executable readable
   291 0000023F B00F                    		mov		al,0x0F
   292 00000241 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   293 00000245 AB                      		stosw
   294                                  ; Data selector (DATA16_SEL)
   295 00000246 31C0                    		xor		ax,ax
   296 00000248 48                      		dec		ax			; 0xFFFF
   297 00000249 AB                      		stosw					; LIMIT
   298 0000024A A1[5820]                		mov		ax,[my_phys_base]
   299 0000024D AB                      		stosw					; BASE[15:0]
   300 0000024E A0[5A20]                		mov		al,[my_phys_base+2]
   301 00000251 B492                    		mov		ah,0x92
   302 00000253 AB                      		stosw					; BASE[23:16] access byte=data writeable
   303 00000254 B00F                    		mov		al,0x0F
   304 00000256 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   305 0000025A AB                      		stosw
   306                                  ; Code selector (CODE_32SEL)
   307 0000025B 48                      		dec		ax			; 0x0000 - 1 = 0xFFFF
   308 0000025C AB                      		stosw					; LIMIT
   309 0000025D A1[5820]                		mov		ax,[my_phys_base]
   310 00000260 AB                      		stosw					; BASE[15:0]
   311 00000261 A0[5A20]                		mov		al,[my_phys_base+2]
   312 00000264 B49A                    		mov		ah,0x9A
   313 00000266 AB                      		stosw					; BASE[23:16] access byte=executable readable
   314 00000267 B0CF                    		mov		al,0xCF
   315 00000269 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   316 0000026D AB                      		stosw
   317                                  ; Data selector (DATA32_SEL)
   318 0000026E 31C0                    		xor		ax,ax
   319 00000270 48                      		dec		ax			; 0xFFFF
   320 00000271 AB                      		stosw					; LIMIT
   321 00000272 A1[5820]                		mov		ax,[my_phys_base]
   322 00000275 AB                      		stosw					; BASE[15:0]
   323 00000276 A0[5A20]                		mov		al,[my_phys_base+2]
   324 00000279 B492                    		mov		ah,0x92
   325 0000027B AB                      		stosw					; BASE[23:16] access byte=data writeable
   326 0000027C B0CF                    		mov		al,0xCF
   327 0000027E 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   328 00000282 AB                      		stosw
   329                                  ; Data selector (FLAT16_SEL)
   330 00000283 31C0                    		xor		ax,ax
   331 00000285 48                      		dec		ax			; 0xFFFF
   332 00000286 AB                      		stosw					; LIMIT
   333 00000287 31C0                    		xor		ax,ax
   334 00000289 AB                      		stosw					; BASE[15:0]
   335 0000028A B492                    		mov		ah,0x92
   336 0000028C AB                      		stosw					; BASE[23:16] access byte=data writeable
   337 0000028D B08F                    		mov		al,0x8F
   338 0000028F 30E4                    		xor		ah,ah
   339 00000291 AB                      		stosw
   340                                  ; Data selector (FLAT32_SEL)
   341 00000292 31C0                    		xor		ax,ax
   342 00000294 48                      		dec		ax			; 0xFFFF
   343 00000295 AB                      		stosw					; LIMIT
   344 00000296 31C0                    		xor		ax,ax
   345 00000298 AB                      		stosw					; BASE[15:0]
   346 00000299 B492                    		mov		ah,0x92
   347 0000029B AB                      		stosw					; BASE[23:16] access byte=data writeable
   348 0000029C B0CF                    		mov		al,0xCF
   349 0000029E 30E4                    		xor		ah,ah
   350 000002A0 AB                      		stosw
   351                                  ; LDT selector (LDT_SEL)
   352 000002A1 B80700                  		mov		ax,7			; I have no use for the LDT
   353 000002A4 AB                      		stosw					; LIMIT
   354 000002A5 A1[5820]                		mov		ax,[my_phys_base]
   355 000002A8 AB                      		stosw					; BASE[15:0]
   356 000002A9 A0[5A20]                		mov		al,[my_phys_base+2]
   357 000002AC B482                    		mov		ah,0x82
   358 000002AE AB                      		stosw					; BASE[23:16] access byte=data writeable LDT type 2
   359 000002AF B00F                    		mov		al,0x0F
   360 000002B1 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   361 000002B5 AB                      		stosw
   362                                  ; TSS selector (TSS_SEL)
   363 000002B6 B86700                  		mov		ax,104-1
   364 000002B9 AB                      		stosw					; LIMIT
   365 000002BA A1[5C20]                		mov		ax,[tss_phys_base]
   366 000002BD AB                      		stosw					; BASE[15:0]
   367 000002BE A0[5E20]                		mov		al,[tss_phys_base+2]
   368 000002C1 B489                    		mov		ah,0x89
   369 000002C3 AB                      		stosw					; BASE[23:16] access byte=data writeable non-busy TSS type 9
   370 000002C4 B00F                    		mov		al,0x0F
   371 000002C6 8A26[5F20]              		mov		ah,[tss_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   372 000002CA AB                      		stosw
   373                                  ; TSS selector (TSS_VM86_SEL)
   374 000002CB B86720                  		mov		ax,104+8192-1
   375 000002CE AB                      		stosw					; LIMIT
   376 000002CF A1[6020]                		mov		ax,[tss_vm86_phys_base]
   377 000002D2 AB                      		stosw					; BASE[15:0]
   378 000002D3 A0[6220]                		mov		al,[tss_vm86_phys_base+2]
   379 000002D6 B489                    		mov		ah,0x89
   380 000002D8 AB                      		stosw					; BASE[23:16] access byte=data writeable non-busy TSS type 9
   381 000002D9 B00F                    		mov		al,0x0F
   382 000002DB 8A26[6320]              		mov		ah,[tss_vm86_phys_base+3] ; LIMIT[19:16] flags=0 BASE[31:24]
   383 000002DF AB                      		stosw
   384                                  
   385                                  ; prepare the CPU registers
   386 000002E0 0F011E[7820]            		lidt		[idtr_pmode]
   387 000002E5 0F0116[6820]            		lgdt		[gdtr_pmode]
   388                                  
   389                                  ; enter protected mode
   390 000002EA 66B811000000            		mov		eax,0x00000011
   391 000002F0 660B06[0400]            		or		eax,[cr0_more]
   392 000002F5 0F22C0                  		mov		cr0,eax
   393 000002F8 EA[FD02]0800            		jmp		CODE16_SEL:pmode16_entry
   394 000002FD B81000                  pmode16_entry:	mov		ax,DATA16_SEL
   395 00000300 8ED8                    		mov		ds,ax
   396 00000302 8EC0                    		mov		es,ax
   397 00000304 8EE0                    		mov		fs,ax
   398 00000306 8EE8                    		mov		gs,ax
   399 00000308 8ED0                    		mov		ss,ax
   400 0000030A BC[0010]                		mov		sp,stack_init
   401                                  
   402                                  ; load task register
   403 0000030D B84000                  		mov		ax,TSS_SEL
   404 00000310 0F00D8                  		ltr		ax
   405                                  
   406                                  ; load LDT
   407 00000313 B83800                  		mov		ax,LDT_SEL
   408 00000316 0F00D0                  		lldt		ax
   409                                  
   410                                  ; now enter 32-bit protected mode
   411 00000319 EA[1E03]1800            		jmp		CODE32_SEL:pmode32_entry
   412                                  		bits		32
   413 0000031E 66B82000                pmode32_entry:	mov		ax,DATA32_SEL
   414 00000322 8ED8                    		mov		ds,ax
   415 00000324 8EC0                    		mov		es,ax
   416 00000326 8ED0                    		mov		ss,ax
   417 00000328 66B83000                		mov		ax,FLAT32_SEL
   418 0000032C 8EE0                    		mov		fs,ax
   419 0000032E 8EE8                    		mov		gs,ax
   420 00000330 BC[00100000]            		mov		esp,stack_init
   421                                  ; at this point: we are in 32-bit protected mode!
   422                                  
   423                                  ; ============= setup the TSS representing our task (for when we return)
   424 00000335 FC                      		cld
   425 00000336 8B3D[5C200000]          		mov		edi,[tss_phys_base]
   426 0000033C 2B3D[58200000]          		sub		edi,[my_phys_base]
   427                                  
   428 00000342 31C0                    		xor		eax,eax					; TSS+0x00 = no backlink
   429 00000344 AB                      		stosd
   430 00000345 B8[00100000]            		mov		eax,stack_init				; TSS+0x04 = ESP for CPL0
   431 0000034A AB                      		stosd
   432 0000034B B820000000              		mov		eax,DATA32_SEL				; TSS+0x08 = SS for CPL0
   433 00000350 AB                      		stosd
   434 00000351 B8[00100000]            		mov		eax,stack_init				; TSS+0x0C = ESP for CPL1
   435 00000356 AB                      		stosd
   436 00000357 B820000000              		mov		eax,DATA32_SEL				; TSS+0x10 = SS for CPL1
   437 0000035C AB                      		stosd
   438 0000035D B8[00100000]            		mov		eax,stack_init				; TSS+0x14 = ESP for CPL2
   439 00000362 AB                      		stosd
   440 00000363 B820000000              		mov		eax,DATA32_SEL				; TSS+0x18 = SS for CPL2
   441 00000368 AB                      		stosd
   442 00000369 31C0                    		xor		eax,eax					; TSS+0x1C = CR3
   443 0000036B AB                      		stosd
   444 0000036C B800000000              		mov		eax,0					; TSS+0x20 = EIP [FIXME]
   445 00000371 AB                      		stosd
   446 00000372 B802000000              		mov		eax,0x00000002				; TSS+0x24 = EFLAGS VM=0
   447 00000377 AB                      		stosd
   448 00000378 31C0                    		xor		eax,eax					; TSS+0x28 = EAX
   449 0000037A AB                      		stosd
   450 0000037B 31C0                    		xor		eax,eax					; TSS+0x2C = ECX
   451 0000037D AB                      		stosd
   452 0000037E 31C0                    		xor		eax,eax					; TSS+0x30 = EDX
   453 00000380 AB                      		stosd
   454 00000381 31C0                    		xor		eax,eax					; TSS+0x34 = EBX
   455 00000383 AB                      		stosd
   456 00000384 B8[00100000]            		mov		eax,stack_init				; TSS+0x38 = ESP
   457 00000389 AB                      		stosd
   458 0000038A 31C0                    		xor		eax,eax					; TSS+0x3C = EBP
   459 0000038C AB                      		stosd
   460 0000038D 31C0                    		xor		eax,eax					; TSS+0x40 = ESI
   461 0000038F AB                      		stosd
   462 00000390 31C0                    		xor		eax,eax					; TSS+0x44 = EDI
   463 00000392 AB                      		stosd
   464 00000393 66B82000                		mov		ax,DATA32_SEL				; TSS+0x48 = ES
   465 00000397 AB                      		stosd
   466 00000398 66B81800                		mov		ax,CODE32_SEL				; TSS+0x4C = CS
   467 0000039C AB                      		stosd
   468 0000039D 66B82000                		mov		ax,DATA32_SEL				; TSS+0x50 = SS
   469 000003A1 AB                      		stosd
   470 000003A2 66B82000                		mov		ax,DATA32_SEL				; TSS+0x54 = DS
   471 000003A6 AB                      		stosd
   472 000003A7 66B82000                		mov		ax,DATA32_SEL				; TSS+0x58 = FS
   473 000003AB AB                      		stosd
   474 000003AC 66B82000                		mov		ax,DATA32_SEL				; TSS+0x5C = GS
   475 000003B0 AB                      		stosd
   476 000003B1 31C0                    		xor		eax,eax					; TSS+0x60 = LDTR
   477 000003B3 AB                      		stosd
   478 000003B4 B800006800              		mov		eax,(104 << 16)				; TSS+0x64 = I/O map base
   479 000003B9 AB                      		stosd
   480                                  
   481                                  ; ============= setup the TSS representing the virtual 8086 mode task
   482 000003BA FC                      		cld
   483 000003BB 8B3D[60200000]          		mov		edi,[tss_vm86_phys_base]
   484 000003C1 2B3D[58200000]          		sub		edi,[my_phys_base]
   485                                  
   486 000003C7 31C0                    		xor		eax,eax					; TSS+0x00 = no backlink
   487 000003C9 AB                      		stosd
   488 000003CA B8[00100000]            		mov		eax,stack_init				; TSS+0x04 = ESP for CPL0
   489 000003CF AB                      		stosd
   490 000003D0 B820000000              		mov		eax,DATA32_SEL				; TSS+0x08 = SS for CPL0
   491 000003D5 AB                      		stosd
   492 000003D6 B8[00100000]            		mov		eax,stack_init				; TSS+0x0C = ESP for CPL1
   493 000003DB AB                      		stosd
   494 000003DC B820000000              		mov		eax,DATA32_SEL				; TSS+0x10 = SS for CPL1
   495 000003E1 AB                      		stosd
   496 000003E2 B8[00100000]            		mov		eax,stack_init				; TSS+0x14 = ESP for CPL2
   497 000003E7 AB                      		stosd
   498 000003E8 B820000000              		mov		eax,DATA32_SEL				; TSS+0x18 = SS for CPL2
   499 000003ED AB                      		stosd
   500 000003EE 31C0                    		xor		eax,eax					; TSS+0x1C = CR3
   501 000003F0 AB                      		stosd
   502 000003F1 B8[1C1F0000]            		mov		eax,vm86_entry				; TSS+0x20 = EIP
   503 000003F6 AB                      		stosd
   504 000003F7 B802020200              		mov		eax,0x00020202				; TSS+0x24 = EFLAGS VM=1 IOPL=N IF=1
   505 000003FC 0FB61D[E0280000]        		movzx		ebx,byte [user_req_iopl]
   506 00000403 80E303                  		and		bl,3
   507 00000406 C1E30C                  		shl		ebx,12
   508 00000409 09D8                    		or		eax,ebx					; EFLAGS |= user_req_iopl << 12
   509 0000040B AB                      		stosd
   510 0000040C 31C0                    		xor		eax,eax					; TSS+0x28 = EAX
   511 0000040E AB                      		stosd
   512 0000040F 31C0                    		xor		eax,eax					; TSS+0x2C = ECX
   513 00000411 AB                      		stosd
   514 00000412 31C0                    		xor		eax,eax					; TSS+0x30 = EDX
   515 00000414 AB                      		stosd
   516 00000415 31C0                    		xor		eax,eax					; TSS+0x34 = EBX
   517 00000417 AB                      		stosd
   518 00000418 B8[44200000]            		mov		eax,stack_init_vm86			; TSS+0x38 = ESP
   519 0000041D AB                      		stosd
   520 0000041E 31C0                    		xor		eax,eax					; TSS+0x3C = EBP
   521 00000420 AB                      		stosd
   522 00000421 31C0                    		xor		eax,eax					; TSS+0x40 = ESI
   523 00000423 AB                      		stosd
   524 00000424 31C0                    		xor		eax,eax					; TSS+0x44 = EDI
   525 00000426 AB                      		stosd
   526 00000427 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x48 = ES
   527 0000042D AB                      		stosd
   528 0000042E 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x4C = CS
   529 00000434 AB                      		stosd
   530 00000435 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x50 = SS
   531 0000043B AB                      		stosd
   532 0000043C 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x54 = DS
   533 00000442 AB                      		stosd
   534 00000443 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x58 = FS
   535 00000449 AB                      		stosd
   536 0000044A 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x5C = GS
   537 00000450 AB                      		stosd
   538 00000451 31C0                    		xor		eax,eax					; TSS+0x60 = LDTR
   539 00000453 AB                      		stosd
   540 00000454 B800006800              		mov		eax,(104 << 16)				; TSS+0x64 = I/O map base (0x68 == 104)
   541 00000459 AB                      		stosd
   542 0000045A 31C0                    		xor		eax,eax
   543 0000045C B900080000              		mov		ecx,8192 >> 2				; TSS+0x68 = I/O permission map (pre-set to all open)
   544 00000461 F3AB                    		rep		stosd
   545                                  
   546                                  ; actually, we want it to trap some ports off the bat
   547 00000463 8B3D[60200000]          		mov		edi,[tss_vm86_phys_base]
   548 00000469 2B3D[58200000]          		sub		edi,[my_phys_base]
   549 0000046F 83C768                  		add		edi,0x68				; TSS+0x68 = I/O permission map
   550 00000472 804F0C10                		or		byte [edi+(0x64/8)],1 << (0x64 & 7)	; trap port 0x64
   551 00000476 804F1204                		or		byte [edi+(0x92/8)],1 << (0x92 & 7)	; trap port 0x92
   552                                  
   553                                  ; zero VCPI page map
   554 0000047A A1[EA280000]            		mov		eax,dword [vcpi_alloc_bitmap_phys]
   555 0000047F 83F800                  		cmp		eax,0
   556 00000482 741C                    		jz		.nothing
   557 00000484 06                      		push		es
   558 00000485 66B83000                		mov		ax,FLAT32_SEL
   559 00000489 8EC0                    		mov		es,ax
   560 0000048B 31C0                    		xor		eax,eax
   561 0000048D FC                      		cld
   562 0000048E 8B3D[EA280000]          		mov		edi,dword [vcpi_alloc_bitmap_phys]
   563 00000494 8B0D[EE280000]          		mov		ecx,dword [vcpi_alloc_bitmap_size]
   564 0000049A C1E902                  		shr		ecx,2
   565 0000049D F3AB                    		rep		stosd
   566 0000049F 07                      		pop		es
   567                                  .nothing:
   568                                  
   569                                  ; set up the IDT
   570 000004A0 FC                      		cld
   571                                  
   572 000004A1 BF[E0200000]            		mov		edi,idt
   573 000004A6 BE[780F0000]            		mov		esi,interrupt_procs
   574                                  
   575                                  ; the first 32 interrupts (0x00-0x1F) are marked CPL=0. This causes
   576                                  ; real-mode software interrupts in that range to instead cause a GPF
   577                                  ; which we can then safely reflect back to real mode. If all were
   578                                  ; marked CPL=3 then a real-mode software interrupt would trigger an
   579                                  ; actual INT in the IDT and it would be extremely difficult for
   580                                  ; fault handlers to differentiate between actual faults vs. software
   581                                  ; interrupts.
   582 000004AB B914000000              		mov		ecx,0x14
   583 000004B0 66AD                    .idtdef0:	lodsw
   584 000004B2 66AB                    		stosw					; base[15:0]
   585 000004B4 66B81800                		mov		ax,CODE32_SEL
   586 000004B8 66AB                    		stosw
   587 000004BA 66B8008E                		mov		ax,0x8E00		; DPL=0 (so that software interrupts 0x00-0x1F can be handled by our GPF)
   588 000004BE 66AB                    		stosw
   589 000004C0 6631C0                  		xor		ax,ax
   590 000004C3 66AB                    		stosw
   591 000004C5 E2E9                    		loop		.idtdef0
   592                                  
   593 000004C7 B9EC000000              		mov		ecx,0x100 - 0x14
   594 000004CC 66AD                    .idtdef3:	lodsw
   595 000004CE 66AB                    		stosw					; base[15:0]
   596 000004D0 66B81800                		mov		ax,CODE32_SEL
   597 000004D4 66AB                    		stosw
   598 000004D6 66B800EE                		mov		ax,0xEE00		; DPL=3
   599 000004DA 66AB                    		stosw
   600 000004DC 6631C0                  		xor		ax,ax
   601 000004DF 66AB                    		stosw
   602 000004E1 E2E9                    		loop		.idtdef3
   603                                  
   604                                  ; next we need to reprogram the PIC so that IRQ 0-7 do not conflict with the CPU exceptions.
   605 000004E3 B010                    		mov		al,0x10			; ICW1 A0=0
   606 000004E5 E620                    		out		20h,al
   607 000004E7 B0F0                    		mov		al,IRQ_BASE_INT		; ICW2 A0=1
   608 000004E9 E621                    		out		21h,al
   609 000004EB B004                    		mov		al,0x04			; ICW3 A0=1 slave on IRQ 2
   610 000004ED E621                    		out		21h,al
   611                                  
   612 000004EF B010                    		mov		al,0x10			; ICW1 A0=0
   613 000004F1 E6A0                    		out		0xA0,al
   614 000004F3 B0F8                    		mov		al,IRQ_BASE_INT+8	; ICW2 A0=1
   615 000004F5 E6A1                    		out		0xA1,al
   616 000004F7 B002                    		mov		al,0x02			; ICW3 A0=1
   617 000004F9 E6A1                    		out		0xA1,al
   618                                  
   619                                  ; jump into virtual 8086 mode
   620 000004FB EA000000004800          		jmp		TSS_VM86_SEL:0
   621                                  
   622                                  ; interrupt jump table. emits a 4-byte instruction (no error code)
   623                                  ;    interrupt_entry_4 <vector>
   624                                  %macro interrupt_entry_4 1
   625                                  ; non-error code version. We push a dummy error code along with the intnum.
   626                                  interrupt_%1:	push		byte 0
   627                                  		push		%1
   628                                  		jmp		interrupt_routine
   629                                  %endmacro
   630                                  
   631                                  ; interrupt jump table. emits a 4-byte instruction (no error code), meant for IRQs
   632                                  ;    interrupt_entry_4 <vector>
   633                                  %macro interrupt_entry_4irq 1
   634                                  ; non-error code version. We push a dummy error code along with the intnum.
   635                                  interrupt_%1:	push		byte 0
   636                                  		push		%1
   637                                  		jmp		interrupt_routine_irq
   638                                  %endmacro
   639                                  
   640                                  ; interrupt jump table. emits a 4-byte instruction (no error code), meant for IRQs
   641                                  ;    interrupt_entry_4 <vector>
   642                                  %macro interrupt_entry_4_tf 1
   643                                  ; non-error code version. We push a dummy error code along with the intnum.
   644                                  interrupt_%1:	push		byte 0
   645                                  		push		%1
   646                                  		jmp		interrupt_routine_tf
   647                                  %endmacro
   648                                  
   649                                  ; error code version. The CPU pushes an error code on the stack. We just push the intnum and move on,
   650                                  %macro interrupt_entry_4_ec 1
   651                                  interrupt_%1:	push		%1
   652                                  		jmp		interrupt_routine
   653                                  %endmacro
   654                                  
   655                                  ; specialized for GPF fault. no time to jump to generic interrupt handlers.
   656                                  %macro interrupt_entry_4gpf 1
   657                                  interrupt_%1:	push		%1
   658                                  		jmp		interrupt_routine_gpf
   659                                  %endmacro
   660                                  
   661                                  ; specialized for EMM/VCPI entry. no time to jump to generic interrupt handlers.
   662                                  %macro interrupt_entry_4emm 1
   663                                  interrupt_%1:	push		byte 0
   664                                  		push		%1
   665                                  		jmp		interrupt_routine_emm
   666                                  %endmacro
   667                                  
   668                                  		interrupt_entry_4    0x00
   669                              <1> 
   670 00000502 6A00                <1> interrupt_%1: push byte 0
   671 00000504 6A00                <1>  push %1
   672 00000506 E9C1100000          <1>  jmp interrupt_routine
   673                                  		interrupt_entry_4_tf 0x01
   674                              <1> 
   675 0000050B 6A00                <1> interrupt_%1: push byte 0
   676 0000050D 6A01                <1>  push %1
   677 0000050F E9170D0000          <1>  jmp interrupt_routine_tf
   678                                  		interrupt_entry_4    0x02
   679                              <1> 
   680 00000514 6A00                <1> interrupt_%1: push byte 0
   681 00000516 6A02                <1>  push %1
   682 00000518 E9AF100000          <1>  jmp interrupt_routine
   683                                  		interrupt_entry_4    0x03
   684                              <1> 
   685 0000051D 6A00                <1> interrupt_%1: push byte 0
   686 0000051F 6A03                <1>  push %1
   687 00000521 E9A6100000          <1>  jmp interrupt_routine
   688                                  		interrupt_entry_4    0x04
   689                              <1> 
   690 00000526 6A00                <1> interrupt_%1: push byte 0
   691 00000528 6A04                <1>  push %1
   692 0000052A E99D100000          <1>  jmp interrupt_routine
   693                                  		interrupt_entry_4    0x05
   694                              <1> 
   695 0000052F 6A00                <1> interrupt_%1: push byte 0
   696 00000531 6A05                <1>  push %1
   697 00000533 E994100000          <1>  jmp interrupt_routine
   698                                  		interrupt_entry_4    0x06
   699                              <1> 
   700 00000538 6A00                <1> interrupt_%1: push byte 0
   701 0000053A 6A06                <1>  push %1
   702 0000053C E98B100000          <1>  jmp interrupt_routine
   703                                  		interrupt_entry_4    0x07
   704                              <1> 
   705 00000541 6A00                <1> interrupt_%1: push byte 0
   706 00000543 6A07                <1>  push %1
   707 00000545 E982100000          <1>  jmp interrupt_routine
   708                                  		interrupt_entry_4_ec 0x08
   709 0000054A 6A08                <1> interrupt_%1: push %1
   710 0000054C E97B100000          <1>  jmp interrupt_routine
   711                                  		interrupt_entry_4    0x09
   712                              <1> 
   713 00000551 6A00                <1> interrupt_%1: push byte 0
   714 00000553 6A09                <1>  push %1
   715 00000555 E972100000          <1>  jmp interrupt_routine
   716                                  		interrupt_entry_4_ec 0x0A
   717 0000055A 6A0A                <1> interrupt_%1: push %1
   718 0000055C E96B100000          <1>  jmp interrupt_routine
   719                                  		interrupt_entry_4_ec 0x0B
   720 00000561 6A0B                <1> interrupt_%1: push %1
   721 00000563 E964100000          <1>  jmp interrupt_routine
   722                                  		interrupt_entry_4_ec 0x0C
   723 00000568 6A0C                <1> interrupt_%1: push %1
   724 0000056A E95D100000          <1>  jmp interrupt_routine
   725                                  		interrupt_entry_4gpf 0x0D
   726 0000056F 6A0D                <1> interrupt_%1: push %1
   727 00000571 E9540D0000          <1>  jmp interrupt_routine_gpf
   728                                  		interrupt_entry_4    0x0E
   729                              <1> 
   730 00000576 6A00                <1> interrupt_%1: push byte 0
   731 00000578 6A0E                <1>  push %1
   732 0000057A E94D100000          <1>  jmp interrupt_routine
   733                                  		interrupt_entry_4    0x0F
   734                              <1> 
   735 0000057F 6A00                <1> interrupt_%1: push byte 0
   736 00000581 6A0F                <1>  push %1
   737 00000583 E944100000          <1>  jmp interrupt_routine
   738                                  		interrupt_entry_4    0x10
   739                              <1> 
   740 00000588 6A00                <1> interrupt_%1: push byte 0
   741 0000058A 6A10                <1>  push %1
   742 0000058C E93B100000          <1>  jmp interrupt_routine
   743                                  		interrupt_entry_4    0x11
   744                              <1> 
   745 00000591 6A00                <1> interrupt_%1: push byte 0
   746 00000593 6A11                <1>  push %1
   747 00000595 E932100000          <1>  jmp interrupt_routine
   748                                  		interrupt_entry_4    0x12
   749                              <1> 
   750 0000059A 6A00                <1> interrupt_%1: push byte 0
   751 0000059C 6A12                <1>  push %1
   752 0000059E E929100000          <1>  jmp interrupt_routine
   753                                  		interrupt_entry_4    0x13
   754                              <1> 
   755 000005A3 6A00                <1> interrupt_%1: push byte 0
   756 000005A5 6A13                <1>  push %1
   757 000005A7 E920100000          <1>  jmp interrupt_routine
   758                                  		interrupt_entry_4    0x14		; <== FIRST INTERRUPT NOT TO TRAP VIA GPF
   759                              <1> 
   760 000005AC 6A00                <1> interrupt_%1: push byte 0
   761 000005AE 6A14                <1>  push %1
   762 000005B0 E917100000          <1>  jmp interrupt_routine
   763                                  		interrupt_entry_4    0x15
   764                              <1> 
   765 000005B5 6A00                <1> interrupt_%1: push byte 0
   766 000005B7 6A15                <1>  push %1
   767 000005B9 E90E100000          <1>  jmp interrupt_routine
   768                                  		interrupt_entry_4    0x16
   769                              <1> 
   770 000005BE 6A00                <1> interrupt_%1: push byte 0
   771 000005C0 6A16                <1>  push %1
   772 000005C2 E905100000          <1>  jmp interrupt_routine
   773                                  		interrupt_entry_4    0x17
   774                              <1> 
   775 000005C7 6A00                <1> interrupt_%1: push byte 0
   776 000005C9 6A17                <1>  push %1
   777 000005CB E9FC0F0000          <1>  jmp interrupt_routine
   778                                  		interrupt_entry_4    0x18
   779                              <1> 
   780 000005D0 6A00                <1> interrupt_%1: push byte 0
   781 000005D2 6A18                <1>  push %1
   782 000005D4 E9F30F0000          <1>  jmp interrupt_routine
   783                                  		interrupt_entry_4    0x19
   784                              <1> 
   785 000005D9 6A00                <1> interrupt_%1: push byte 0
   786 000005DB 6A19                <1>  push %1
   787 000005DD E9EA0F0000          <1>  jmp interrupt_routine
   788                                  		interrupt_entry_4    0x1A
   789                              <1> 
   790 000005E2 6A00                <1> interrupt_%1: push byte 0
   791 000005E4 6A1A                <1>  push %1
   792 000005E6 E9E10F0000          <1>  jmp interrupt_routine
   793                                  		interrupt_entry_4    0x1B
   794                              <1> 
   795 000005EB 6A00                <1> interrupt_%1: push byte 0
   796 000005ED 6A1B                <1>  push %1
   797 000005EF E9D80F0000          <1>  jmp interrupt_routine
   798                                  		interrupt_entry_4    0x1C
   799                              <1> 
   800 000005F4 6A00                <1> interrupt_%1: push byte 0
   801 000005F6 6A1C                <1>  push %1
   802 000005F8 E9CF0F0000          <1>  jmp interrupt_routine
   803                                  		interrupt_entry_4    0x1D
   804                              <1> 
   805 000005FD 6A00                <1> interrupt_%1: push byte 0
   806 000005FF 6A1D                <1>  push %1
   807 00000601 E9C60F0000          <1>  jmp interrupt_routine
   808                                  		interrupt_entry_4    0x1E
   809                              <1> 
   810 00000606 6A00                <1> interrupt_%1: push byte 0
   811 00000608 6A1E                <1>  push %1
   812 0000060A E9BD0F0000          <1>  jmp interrupt_routine
   813                                  		interrupt_entry_4    0x1F
   814                              <1> 
   815 0000060F 6A00                <1> interrupt_%1: push byte 0
   816 00000611 6A1F                <1>  push %1
   817 00000613 E9B40F0000          <1>  jmp interrupt_routine
   818                                  		interrupt_entry_4    0x20
   819                              <1> 
   820 00000618 6A00                <1> interrupt_%1: push byte 0
   821 0000061A 6A20                <1>  push %1
   822 0000061C E9AB0F0000          <1>  jmp interrupt_routine
   823                                  		interrupt_entry_4    0x21
   824                              <1> 
   825 00000621 6A00                <1> interrupt_%1: push byte 0
   826 00000623 6A21                <1>  push %1
   827 00000625 E9A20F0000          <1>  jmp interrupt_routine
   828                                  		interrupt_entry_4    0x22
   829                              <1> 
   830 0000062A 6A00                <1> interrupt_%1: push byte 0
   831 0000062C 6A22                <1>  push %1
   832 0000062E E9990F0000          <1>  jmp interrupt_routine
   833                                  		interrupt_entry_4    0x23
   834                              <1> 
   835 00000633 6A00                <1> interrupt_%1: push byte 0
   836 00000635 6A23                <1>  push %1
   837 00000637 E9900F0000          <1>  jmp interrupt_routine
   838                                  		interrupt_entry_4    0x24
   839                              <1> 
   840 0000063C 6A00                <1> interrupt_%1: push byte 0
   841 0000063E 6A24                <1>  push %1
   842 00000640 E9870F0000          <1>  jmp interrupt_routine
   843                                  		interrupt_entry_4    0x25
   844                              <1> 
   845 00000645 6A00                <1> interrupt_%1: push byte 0
   846 00000647 6A25                <1>  push %1
   847 00000649 E97E0F0000          <1>  jmp interrupt_routine
   848                                  		interrupt_entry_4    0x26
   849                              <1> 
   850 0000064E 6A00                <1> interrupt_%1: push byte 0
   851 00000650 6A26                <1>  push %1
   852 00000652 E9750F0000          <1>  jmp interrupt_routine
   853                                  		interrupt_entry_4    0x27
   854                              <1> 
   855 00000657 6A00                <1> interrupt_%1: push byte 0
   856 00000659 6A27                <1>  push %1
   857 0000065B E96C0F0000          <1>  jmp interrupt_routine
   858                                  		interrupt_entry_4    0x28
   859                              <1> 
   860 00000660 6A00                <1> interrupt_%1: push byte 0
   861 00000662 6A28                <1>  push %1
   862 00000664 E9630F0000          <1>  jmp interrupt_routine
   863                                  		interrupt_entry_4    0x29
   864                              <1> 
   865 00000669 6A00                <1> interrupt_%1: push byte 0
   866 0000066B 6A29                <1>  push %1
   867 0000066D E95A0F0000          <1>  jmp interrupt_routine
   868                                  		interrupt_entry_4    0x2A
   869                              <1> 
   870 00000672 6A00                <1> interrupt_%1: push byte 0
   871 00000674 6A2A                <1>  push %1
   872 00000676 E9510F0000          <1>  jmp interrupt_routine
   873                                  		interrupt_entry_4    0x2B
   874                              <1> 
   875 0000067B 6A00                <1> interrupt_%1: push byte 0
   876 0000067D 6A2B                <1>  push %1
   877 0000067F E9480F0000          <1>  jmp interrupt_routine
   878                                  		interrupt_entry_4    0x2C
   879                              <1> 
   880 00000684 6A00                <1> interrupt_%1: push byte 0
   881 00000686 6A2C                <1>  push %1
   882 00000688 E93F0F0000          <1>  jmp interrupt_routine
   883                                  		interrupt_entry_4    0x2D
   884                              <1> 
   885 0000068D 6A00                <1> interrupt_%1: push byte 0
   886 0000068F 6A2D                <1>  push %1
   887 00000691 E9360F0000          <1>  jmp interrupt_routine
   888                                  		interrupt_entry_4    0x2E
   889                              <1> 
   890 00000696 6A00                <1> interrupt_%1: push byte 0
   891 00000698 6A2E                <1>  push %1
   892 0000069A E92D0F0000          <1>  jmp interrupt_routine
   893                                  		interrupt_entry_4    0x2F
   894                              <1> 
   895 0000069F 6A00                <1> interrupt_%1: push byte 0
   896 000006A1 6A2F                <1>  push %1
   897 000006A3 E9240F0000          <1>  jmp interrupt_routine
   898                                  		interrupt_entry_4    0x30
   899                              <1> 
   900 000006A8 6A00                <1> interrupt_%1: push byte 0
   901 000006AA 6A30                <1>  push %1
   902 000006AC E91B0F0000          <1>  jmp interrupt_routine
   903                                  		interrupt_entry_4    0x31
   904                              <1> 
   905 000006B1 6A00                <1> interrupt_%1: push byte 0
   906 000006B3 6A31                <1>  push %1
   907 000006B5 E9120F0000          <1>  jmp interrupt_routine
   908                                  		interrupt_entry_4    0x32
   909                              <1> 
   910 000006BA 6A00                <1> interrupt_%1: push byte 0
   911 000006BC 6A32                <1>  push %1
   912 000006BE E9090F0000          <1>  jmp interrupt_routine
   913                                  		interrupt_entry_4    0x33
   914                              <1> 
   915 000006C3 6A00                <1> interrupt_%1: push byte 0
   916 000006C5 6A33                <1>  push %1
   917 000006C7 E9000F0000          <1>  jmp interrupt_routine
   918                                  		interrupt_entry_4    0x34
   919                              <1> 
   920 000006CC 6A00                <1> interrupt_%1: push byte 0
   921 000006CE 6A34                <1>  push %1
   922 000006D0 E9F70E0000          <1>  jmp interrupt_routine
   923                                  		interrupt_entry_4    0x35
   924                              <1> 
   925 000006D5 6A00                <1> interrupt_%1: push byte 0
   926 000006D7 6A35                <1>  push %1
   927 000006D9 E9EE0E0000          <1>  jmp interrupt_routine
   928                                  		interrupt_entry_4    0x36
   929                              <1> 
   930 000006DE 6A00                <1> interrupt_%1: push byte 0
   931 000006E0 6A36                <1>  push %1
   932 000006E2 E9E50E0000          <1>  jmp interrupt_routine
   933                                  		interrupt_entry_4    0x37
   934                              <1> 
   935 000006E7 6A00                <1> interrupt_%1: push byte 0
   936 000006E9 6A37                <1>  push %1
   937 000006EB E9DC0E0000          <1>  jmp interrupt_routine
   938                                  		interrupt_entry_4    0x38
   939                              <1> 
   940 000006F0 6A00                <1> interrupt_%1: push byte 0
   941 000006F2 6A38                <1>  push %1
   942 000006F4 E9D30E0000          <1>  jmp interrupt_routine
   943                                  		interrupt_entry_4    0x39
   944                              <1> 
   945 000006F9 6A00                <1> interrupt_%1: push byte 0
   946 000006FB 6A39                <1>  push %1
   947 000006FD E9CA0E0000          <1>  jmp interrupt_routine
   948                                  		interrupt_entry_4    0x3A
   949                              <1> 
   950 00000702 6A00                <1> interrupt_%1: push byte 0
   951 00000704 6A3A                <1>  push %1
   952 00000706 E9C10E0000          <1>  jmp interrupt_routine
   953                                  		interrupt_entry_4    0x3B
   954                              <1> 
   955 0000070B 6A00                <1> interrupt_%1: push byte 0
   956 0000070D 6A3B                <1>  push %1
   957 0000070F E9B80E0000          <1>  jmp interrupt_routine
   958                                  		interrupt_entry_4    0x3C
   959                              <1> 
   960 00000714 6A00                <1> interrupt_%1: push byte 0
   961 00000716 6A3C                <1>  push %1
   962 00000718 E9AF0E0000          <1>  jmp interrupt_routine
   963                                  		interrupt_entry_4    0x3D
   964                              <1> 
   965 0000071D 6A00                <1> interrupt_%1: push byte 0
   966 0000071F 6A3D                <1>  push %1
   967 00000721 E9A60E0000          <1>  jmp interrupt_routine
   968                                  		interrupt_entry_4    0x3E
   969                              <1> 
   970 00000726 6A00                <1> interrupt_%1: push byte 0
   971 00000728 6A3E                <1>  push %1
   972 0000072A E99D0E0000          <1>  jmp interrupt_routine
   973                                  		interrupt_entry_4    0x3F
   974                              <1> 
   975 0000072F 6A00                <1> interrupt_%1: push byte 0
   976 00000731 6A3F                <1>  push %1
   977 00000733 E9940E0000          <1>  jmp interrupt_routine
   978                                  		interrupt_entry_4    0x40
   979                              <1> 
   980 00000738 6A00                <1> interrupt_%1: push byte 0
   981 0000073A 6A40                <1>  push %1
   982 0000073C E98B0E0000          <1>  jmp interrupt_routine
   983                                  		interrupt_entry_4    0x41
   984                              <1> 
   985 00000741 6A00                <1> interrupt_%1: push byte 0
   986 00000743 6A41                <1>  push %1
   987 00000745 E9820E0000          <1>  jmp interrupt_routine
   988                                  		interrupt_entry_4    0x42
   989                              <1> 
   990 0000074A 6A00                <1> interrupt_%1: push byte 0
   991 0000074C 6A42                <1>  push %1
   992 0000074E E9790E0000          <1>  jmp interrupt_routine
   993                                  		interrupt_entry_4    0x43
   994                              <1> 
   995 00000753 6A00                <1> interrupt_%1: push byte 0
   996 00000755 6A43                <1>  push %1
   997 00000757 E9700E0000          <1>  jmp interrupt_routine
   998                                  		interrupt_entry_4    0x44
   999                              <1> 
  1000 0000075C 6A00                <1> interrupt_%1: push byte 0
  1001 0000075E 6A44                <1>  push %1
  1002 00000760 E9670E0000          <1>  jmp interrupt_routine
  1003                                  		interrupt_entry_4    0x45
  1004                              <1> 
  1005 00000765 6A00                <1> interrupt_%1: push byte 0
  1006 00000767 6A45                <1>  push %1
  1007 00000769 E95E0E0000          <1>  jmp interrupt_routine
  1008                                  		interrupt_entry_4    0x46
  1009                              <1> 
  1010 0000076E 6A00                <1> interrupt_%1: push byte 0
  1011 00000770 6A46                <1>  push %1
  1012 00000772 E9550E0000          <1>  jmp interrupt_routine
  1013                                  		interrupt_entry_4    0x47
  1014                              <1> 
  1015 00000777 6A00                <1> interrupt_%1: push byte 0
  1016 00000779 6A47                <1>  push %1
  1017 0000077B E94C0E0000          <1>  jmp interrupt_routine
  1018                                  		interrupt_entry_4    0x48
  1019                              <1> 
  1020 00000780 6A00                <1> interrupt_%1: push byte 0
  1021 00000782 6A48                <1>  push %1
  1022 00000784 E9430E0000          <1>  jmp interrupt_routine
  1023                                  		interrupt_entry_4    0x49
  1024                              <1> 
  1025 00000789 6A00                <1> interrupt_%1: push byte 0
  1026 0000078B 6A49                <1>  push %1
  1027 0000078D E93A0E0000          <1>  jmp interrupt_routine
  1028                                  		interrupt_entry_4    0x4A
  1029                              <1> 
  1030 00000792 6A00                <1> interrupt_%1: push byte 0
  1031 00000794 6A4A                <1>  push %1
  1032 00000796 E9310E0000          <1>  jmp interrupt_routine
  1033                                  		interrupt_entry_4    0x4B
  1034                              <1> 
  1035 0000079B 6A00                <1> interrupt_%1: push byte 0
  1036 0000079D 6A4B                <1>  push %1
  1037 0000079F E9280E0000          <1>  jmp interrupt_routine
  1038                                  		interrupt_entry_4    0x4C
  1039                              <1> 
  1040 000007A4 6A00                <1> interrupt_%1: push byte 0
  1041 000007A6 6A4C                <1>  push %1
  1042 000007A8 E91F0E0000          <1>  jmp interrupt_routine
  1043                                  		interrupt_entry_4    0x4D
  1044                              <1> 
  1045 000007AD 6A00                <1> interrupt_%1: push byte 0
  1046 000007AF 6A4D                <1>  push %1
  1047 000007B1 E9160E0000          <1>  jmp interrupt_routine
  1048                                  		interrupt_entry_4    0x4E
  1049                              <1> 
  1050 000007B6 6A00                <1> interrupt_%1: push byte 0
  1051 000007B8 6A4E                <1>  push %1
  1052 000007BA E90D0E0000          <1>  jmp interrupt_routine
  1053                                  		interrupt_entry_4    0x4F
  1054                              <1> 
  1055 000007BF 6A00                <1> interrupt_%1: push byte 0
  1056 000007C1 6A4F                <1>  push %1
  1057 000007C3 E9040E0000          <1>  jmp interrupt_routine
  1058                                  		interrupt_entry_4    0x50
  1059                              <1> 
  1060 000007C8 6A00                <1> interrupt_%1: push byte 0
  1061 000007CA 6A50                <1>  push %1
  1062 000007CC E9FB0D0000          <1>  jmp interrupt_routine
  1063                                  		interrupt_entry_4    0x51
  1064                              <1> 
  1065 000007D1 6A00                <1> interrupt_%1: push byte 0
  1066 000007D3 6A51                <1>  push %1
  1067 000007D5 E9F20D0000          <1>  jmp interrupt_routine
  1068                                  		interrupt_entry_4    0x52
  1069                              <1> 
  1070 000007DA 6A00                <1> interrupt_%1: push byte 0
  1071 000007DC 6A52                <1>  push %1
  1072 000007DE E9E90D0000          <1>  jmp interrupt_routine
  1073                                  		interrupt_entry_4    0x53
  1074                              <1> 
  1075 000007E3 6A00                <1> interrupt_%1: push byte 0
  1076 000007E5 6A53                <1>  push %1
  1077 000007E7 E9E00D0000          <1>  jmp interrupt_routine
  1078                                  		interrupt_entry_4    0x54
  1079                              <1> 
  1080 000007EC 6A00                <1> interrupt_%1: push byte 0
  1081 000007EE 6A54                <1>  push %1
  1082 000007F0 E9D70D0000          <1>  jmp interrupt_routine
  1083                                  		interrupt_entry_4    0x55
  1084                              <1> 
  1085 000007F5 6A00                <1> interrupt_%1: push byte 0
  1086 000007F7 6A55                <1>  push %1
  1087 000007F9 E9CE0D0000          <1>  jmp interrupt_routine
  1088                                  		interrupt_entry_4    0x56
  1089                              <1> 
  1090 000007FE 6A00                <1> interrupt_%1: push byte 0
  1091 00000800 6A56                <1>  push %1
  1092 00000802 E9C50D0000          <1>  jmp interrupt_routine
  1093                                  		interrupt_entry_4    0x57
  1094                              <1> 
  1095 00000807 6A00                <1> interrupt_%1: push byte 0
  1096 00000809 6A57                <1>  push %1
  1097 0000080B E9BC0D0000          <1>  jmp interrupt_routine
  1098                                  		interrupt_entry_4    0x58
  1099                              <1> 
  1100 00000810 6A00                <1> interrupt_%1: push byte 0
  1101 00000812 6A58                <1>  push %1
  1102 00000814 E9B30D0000          <1>  jmp interrupt_routine
  1103                                  		interrupt_entry_4    0x59
  1104                              <1> 
  1105 00000819 6A00                <1> interrupt_%1: push byte 0
  1106 0000081B 6A59                <1>  push %1
  1107 0000081D E9AA0D0000          <1>  jmp interrupt_routine
  1108                                  		interrupt_entry_4    0x5A
  1109                              <1> 
  1110 00000822 6A00                <1> interrupt_%1: push byte 0
  1111 00000824 6A5A                <1>  push %1
  1112 00000826 E9A10D0000          <1>  jmp interrupt_routine
  1113                                  		interrupt_entry_4    0x5B
  1114                              <1> 
  1115 0000082B 6A00                <1> interrupt_%1: push byte 0
  1116 0000082D 6A5B                <1>  push %1
  1117 0000082F E9980D0000          <1>  jmp interrupt_routine
  1118                                  		interrupt_entry_4    0x5C
  1119                              <1> 
  1120 00000834 6A00                <1> interrupt_%1: push byte 0
  1121 00000836 6A5C                <1>  push %1
  1122 00000838 E98F0D0000          <1>  jmp interrupt_routine
  1123                                  		interrupt_entry_4    0x5D
  1124                              <1> 
  1125 0000083D 6A00                <1> interrupt_%1: push byte 0
  1126 0000083F 6A5D                <1>  push %1
  1127 00000841 E9860D0000          <1>  jmp interrupt_routine
  1128                                  		interrupt_entry_4    0x5E
  1129                              <1> 
  1130 00000846 6A00                <1> interrupt_%1: push byte 0
  1131 00000848 6A5E                <1>  push %1
  1132 0000084A E97D0D0000          <1>  jmp interrupt_routine
  1133                                  		interrupt_entry_4    0x5F
  1134                              <1> 
  1135 0000084F 6A00                <1> interrupt_%1: push byte 0
  1136 00000851 6A5F                <1>  push %1
  1137 00000853 E9740D0000          <1>  jmp interrupt_routine
  1138                                  		interrupt_entry_4    0x60
  1139                              <1> 
  1140 00000858 6A00                <1> interrupt_%1: push byte 0
  1141 0000085A 6A60                <1>  push %1
  1142 0000085C E96B0D0000          <1>  jmp interrupt_routine
  1143                                  		interrupt_entry_4    0x61
  1144                              <1> 
  1145 00000861 6A00                <1> interrupt_%1: push byte 0
  1146 00000863 6A61                <1>  push %1
  1147 00000865 E9620D0000          <1>  jmp interrupt_routine
  1148                                  		interrupt_entry_4    0x62
  1149                              <1> 
  1150 0000086A 6A00                <1> interrupt_%1: push byte 0
  1151 0000086C 6A62                <1>  push %1
  1152 0000086E E9590D0000          <1>  jmp interrupt_routine
  1153                                  		interrupt_entry_4    0x63
  1154                              <1> 
  1155 00000873 6A00                <1> interrupt_%1: push byte 0
  1156 00000875 6A63                <1>  push %1
  1157 00000877 E9500D0000          <1>  jmp interrupt_routine
  1158                                  		interrupt_entry_4    0x64
  1159                              <1> 
  1160 0000087C 6A00                <1> interrupt_%1: push byte 0
  1161 0000087E 6A64                <1>  push %1
  1162 00000880 E9470D0000          <1>  jmp interrupt_routine
  1163                                  		interrupt_entry_4    0x65
  1164                              <1> 
  1165 00000885 6A00                <1> interrupt_%1: push byte 0
  1166 00000887 6A65                <1>  push %1
  1167 00000889 E93E0D0000          <1>  jmp interrupt_routine
  1168                                  		interrupt_entry_4    0x66
  1169                              <1> 
  1170 0000088E 6A00                <1> interrupt_%1: push byte 0
  1171 00000890 6A66                <1>  push %1
  1172 00000892 E9350D0000          <1>  jmp interrupt_routine
  1173                                  		interrupt_entry_4emm 0x67
  1174 00000897 6A00                <1> interrupt_%1: push byte 0
  1175 00000899 6A67                <1>  push %1
  1176 0000089B E9ED0F0000          <1>  jmp interrupt_routine_emm
  1177                                  		interrupt_entry_4    0x68
  1178                              <1> 
  1179 000008A0 6A00                <1> interrupt_%1: push byte 0
  1180 000008A2 6A68                <1>  push %1
  1181 000008A4 E9230D0000          <1>  jmp interrupt_routine
  1182                                  		interrupt_entry_4    0x69
  1183                              <1> 
  1184 000008A9 6A00                <1> interrupt_%1: push byte 0
  1185 000008AB 6A69                <1>  push %1
  1186 000008AD E91A0D0000          <1>  jmp interrupt_routine
  1187                                  		interrupt_entry_4    0x6A
  1188                              <1> 
  1189 000008B2 6A00                <1> interrupt_%1: push byte 0
  1190 000008B4 6A6A                <1>  push %1
  1191 000008B6 E9110D0000          <1>  jmp interrupt_routine
  1192                                  		interrupt_entry_4    0x6B
  1193                              <1> 
  1194 000008BB 6A00                <1> interrupt_%1: push byte 0
  1195 000008BD 6A6B                <1>  push %1
  1196 000008BF E9080D0000          <1>  jmp interrupt_routine
  1197                                  		interrupt_entry_4    0x6C
  1198                              <1> 
  1199 000008C4 6A00                <1> interrupt_%1: push byte 0
  1200 000008C6 6A6C                <1>  push %1
  1201 000008C8 E9FF0C0000          <1>  jmp interrupt_routine
  1202                                  		interrupt_entry_4    0x6D
  1203                              <1> 
  1204 000008CD 6A00                <1> interrupt_%1: push byte 0
  1205 000008CF 6A6D                <1>  push %1
  1206 000008D1 E9F60C0000          <1>  jmp interrupt_routine
  1207                                  		interrupt_entry_4    0x6E
  1208                              <1> 
  1209 000008D6 6A00                <1> interrupt_%1: push byte 0
  1210 000008D8 6A6E                <1>  push %1
  1211 000008DA E9ED0C0000          <1>  jmp interrupt_routine
  1212                                  		interrupt_entry_4    0x6F
  1213                              <1> 
  1214 000008DF 6A00                <1> interrupt_%1: push byte 0
  1215 000008E1 6A6F                <1>  push %1
  1216 000008E3 E9E40C0000          <1>  jmp interrupt_routine
  1217                                  		interrupt_entry_4    0x70
  1218                              <1> 
  1219 000008E8 6A00                <1> interrupt_%1: push byte 0
  1220 000008EA 6A70                <1>  push %1
  1221 000008EC E9DB0C0000          <1>  jmp interrupt_routine
  1222                                  		interrupt_entry_4    0x71
  1223                              <1> 
  1224 000008F1 6A00                <1> interrupt_%1: push byte 0
  1225 000008F3 6A71                <1>  push %1
  1226 000008F5 E9D20C0000          <1>  jmp interrupt_routine
  1227                                  		interrupt_entry_4    0x72
  1228                              <1> 
  1229 000008FA 6A00                <1> interrupt_%1: push byte 0
  1230 000008FC 6A72                <1>  push %1
  1231 000008FE E9C90C0000          <1>  jmp interrupt_routine
  1232                                  		interrupt_entry_4    0x73
  1233                              <1> 
  1234 00000903 6A00                <1> interrupt_%1: push byte 0
  1235 00000905 6A73                <1>  push %1
  1236 00000907 E9C00C0000          <1>  jmp interrupt_routine
  1237                                  		interrupt_entry_4    0x74
  1238                              <1> 
  1239 0000090C 6A00                <1> interrupt_%1: push byte 0
  1240 0000090E 6A74                <1>  push %1
  1241 00000910 E9B70C0000          <1>  jmp interrupt_routine
  1242                                  		interrupt_entry_4    0x75
  1243                              <1> 
  1244 00000915 6A00                <1> interrupt_%1: push byte 0
  1245 00000917 6A75                <1>  push %1
  1246 00000919 E9AE0C0000          <1>  jmp interrupt_routine
  1247                                  		interrupt_entry_4    0x76
  1248                              <1> 
  1249 0000091E 6A00                <1> interrupt_%1: push byte 0
  1250 00000920 6A76                <1>  push %1
  1251 00000922 E9A50C0000          <1>  jmp interrupt_routine
  1252                                  		interrupt_entry_4    0x77
  1253                              <1> 
  1254 00000927 6A00                <1> interrupt_%1: push byte 0
  1255 00000929 6A77                <1>  push %1
  1256 0000092B E99C0C0000          <1>  jmp interrupt_routine
  1257                                  		interrupt_entry_4    0x78
  1258                              <1> 
  1259 00000930 6A00                <1> interrupt_%1: push byte 0
  1260 00000932 6A78                <1>  push %1
  1261 00000934 E9930C0000          <1>  jmp interrupt_routine
  1262                                  		interrupt_entry_4    0x79
  1263                              <1> 
  1264 00000939 6A00                <1> interrupt_%1: push byte 0
  1265 0000093B 6A79                <1>  push %1
  1266 0000093D E98A0C0000          <1>  jmp interrupt_routine
  1267                                  		interrupt_entry_4    0x7A
  1268                              <1> 
  1269 00000942 6A00                <1> interrupt_%1: push byte 0
  1270 00000944 6A7A                <1>  push %1
  1271 00000946 E9810C0000          <1>  jmp interrupt_routine
  1272                                  		interrupt_entry_4    0x7B
  1273                              <1> 
  1274 0000094B 6A00                <1> interrupt_%1: push byte 0
  1275 0000094D 6A7B                <1>  push %1
  1276 0000094F E9780C0000          <1>  jmp interrupt_routine
  1277                                  		interrupt_entry_4    0x7C
  1278                              <1> 
  1279 00000954 6A00                <1> interrupt_%1: push byte 0
  1280 00000956 6A7C                <1>  push %1
  1281 00000958 E96F0C0000          <1>  jmp interrupt_routine
  1282                                  		interrupt_entry_4    0x7D
  1283                              <1> 
  1284 0000095D 6A00                <1> interrupt_%1: push byte 0
  1285 0000095F 6A7D                <1>  push %1
  1286 00000961 E9660C0000          <1>  jmp interrupt_routine
  1287                                  		interrupt_entry_4    0x7E
  1288                              <1> 
  1289 00000966 6A00                <1> interrupt_%1: push byte 0
  1290 00000968 6A7E                <1>  push %1
  1291 0000096A E95D0C0000          <1>  jmp interrupt_routine
  1292                                  		interrupt_entry_4    0x7F
  1293                              <1> 
  1294 0000096F 6A00                <1> interrupt_%1: push byte 0
  1295 00000971 6A7F                <1>  push %1
  1296 00000973 E9540C0000          <1>  jmp interrupt_routine
  1297                                  		interrupt_entry_4    0x80
  1298                              <1> 
  1299 00000978 6A00                <1> interrupt_%1: push byte 0
  1300 0000097A 6880000000          <1>  push %1
  1301 0000097F E9480C0000          <1>  jmp interrupt_routine
  1302                                  		interrupt_entry_4    0x81
  1303                              <1> 
  1304 00000984 6A00                <1> interrupt_%1: push byte 0
  1305 00000986 6881000000          <1>  push %1
  1306 0000098B E93C0C0000          <1>  jmp interrupt_routine
  1307                                  		interrupt_entry_4    0x82
  1308                              <1> 
  1309 00000990 6A00                <1> interrupt_%1: push byte 0
  1310 00000992 6882000000          <1>  push %1
  1311 00000997 E9300C0000          <1>  jmp interrupt_routine
  1312                                  		interrupt_entry_4    0x83
  1313                              <1> 
  1314 0000099C 6A00                <1> interrupt_%1: push byte 0
  1315 0000099E 6883000000          <1>  push %1
  1316 000009A3 E9240C0000          <1>  jmp interrupt_routine
  1317                                  		interrupt_entry_4    0x84
  1318                              <1> 
  1319 000009A8 6A00                <1> interrupt_%1: push byte 0
  1320 000009AA 6884000000          <1>  push %1
  1321 000009AF E9180C0000          <1>  jmp interrupt_routine
  1322                                  		interrupt_entry_4    0x85
  1323                              <1> 
  1324 000009B4 6A00                <1> interrupt_%1: push byte 0
  1325 000009B6 6885000000          <1>  push %1
  1326 000009BB E90C0C0000          <1>  jmp interrupt_routine
  1327                                  		interrupt_entry_4    0x86
  1328                              <1> 
  1329 000009C0 6A00                <1> interrupt_%1: push byte 0
  1330 000009C2 6886000000          <1>  push %1
  1331 000009C7 E9000C0000          <1>  jmp interrupt_routine
  1332                                  		interrupt_entry_4    0x87
  1333                              <1> 
  1334 000009CC 6A00                <1> interrupt_%1: push byte 0
  1335 000009CE 6887000000          <1>  push %1
  1336 000009D3 E9F40B0000          <1>  jmp interrupt_routine
  1337                                  		interrupt_entry_4    0x88
  1338                              <1> 
  1339 000009D8 6A00                <1> interrupt_%1: push byte 0
  1340 000009DA 6888000000          <1>  push %1
  1341 000009DF E9E80B0000          <1>  jmp interrupt_routine
  1342                                  		interrupt_entry_4    0x89
  1343                              <1> 
  1344 000009E4 6A00                <1> interrupt_%1: push byte 0
  1345 000009E6 6889000000          <1>  push %1
  1346 000009EB E9DC0B0000          <1>  jmp interrupt_routine
  1347                                  		interrupt_entry_4    0x8A
  1348                              <1> 
  1349 000009F0 6A00                <1> interrupt_%1: push byte 0
  1350 000009F2 688A000000          <1>  push %1
  1351 000009F7 E9D00B0000          <1>  jmp interrupt_routine
  1352                                  		interrupt_entry_4    0x8B
  1353                              <1> 
  1354 000009FC 6A00                <1> interrupt_%1: push byte 0
  1355 000009FE 688B000000          <1>  push %1
  1356 00000A03 E9C40B0000          <1>  jmp interrupt_routine
  1357                                  		interrupt_entry_4    0x8C
  1358                              <1> 
  1359 00000A08 6A00                <1> interrupt_%1: push byte 0
  1360 00000A0A 688C000000          <1>  push %1
  1361 00000A0F E9B80B0000          <1>  jmp interrupt_routine
  1362                                  		interrupt_entry_4    0x8D
  1363                              <1> 
  1364 00000A14 6A00                <1> interrupt_%1: push byte 0
  1365 00000A16 688D000000          <1>  push %1
  1366 00000A1B E9AC0B0000          <1>  jmp interrupt_routine
  1367                                  		interrupt_entry_4    0x8E
  1368                              <1> 
  1369 00000A20 6A00                <1> interrupt_%1: push byte 0
  1370 00000A22 688E000000          <1>  push %1
  1371 00000A27 E9A00B0000          <1>  jmp interrupt_routine
  1372                                  		interrupt_entry_4    0x8F
  1373                              <1> 
  1374 00000A2C 6A00                <1> interrupt_%1: push byte 0
  1375 00000A2E 688F000000          <1>  push %1
  1376 00000A33 E9940B0000          <1>  jmp interrupt_routine
  1377                                  		interrupt_entry_4    0x90
  1378                              <1> 
  1379 00000A38 6A00                <1> interrupt_%1: push byte 0
  1380 00000A3A 6890000000          <1>  push %1
  1381 00000A3F E9880B0000          <1>  jmp interrupt_routine
  1382                                  		interrupt_entry_4    0x91
  1383                              <1> 
  1384 00000A44 6A00                <1> interrupt_%1: push byte 0
  1385 00000A46 6891000000          <1>  push %1
  1386 00000A4B E97C0B0000          <1>  jmp interrupt_routine
  1387                                  		interrupt_entry_4    0x92
  1388                              <1> 
  1389 00000A50 6A00                <1> interrupt_%1: push byte 0
  1390 00000A52 6892000000          <1>  push %1
  1391 00000A57 E9700B0000          <1>  jmp interrupt_routine
  1392                                  		interrupt_entry_4    0x93
  1393                              <1> 
  1394 00000A5C 6A00                <1> interrupt_%1: push byte 0
  1395 00000A5E 6893000000          <1>  push %1
  1396 00000A63 E9640B0000          <1>  jmp interrupt_routine
  1397                                  		interrupt_entry_4    0x94
  1398                              <1> 
  1399 00000A68 6A00                <1> interrupt_%1: push byte 0
  1400 00000A6A 6894000000          <1>  push %1
  1401 00000A6F E9580B0000          <1>  jmp interrupt_routine
  1402                                  		interrupt_entry_4    0x95
  1403                              <1> 
  1404 00000A74 6A00                <1> interrupt_%1: push byte 0
  1405 00000A76 6895000000          <1>  push %1
  1406 00000A7B E94C0B0000          <1>  jmp interrupt_routine
  1407                                  		interrupt_entry_4    0x96
  1408                              <1> 
  1409 00000A80 6A00                <1> interrupt_%1: push byte 0
  1410 00000A82 6896000000          <1>  push %1
  1411 00000A87 E9400B0000          <1>  jmp interrupt_routine
  1412                                  		interrupt_entry_4    0x97
  1413                              <1> 
  1414 00000A8C 6A00                <1> interrupt_%1: push byte 0
  1415 00000A8E 6897000000          <1>  push %1
  1416 00000A93 E9340B0000          <1>  jmp interrupt_routine
  1417                                  		interrupt_entry_4    0x98
  1418                              <1> 
  1419 00000A98 6A00                <1> interrupt_%1: push byte 0
  1420 00000A9A 6898000000          <1>  push %1
  1421 00000A9F E9280B0000          <1>  jmp interrupt_routine
  1422                                  		interrupt_entry_4    0x99
  1423                              <1> 
  1424 00000AA4 6A00                <1> interrupt_%1: push byte 0
  1425 00000AA6 6899000000          <1>  push %1
  1426 00000AAB E91C0B0000          <1>  jmp interrupt_routine
  1427                                  		interrupt_entry_4    0x9A
  1428                              <1> 
  1429 00000AB0 6A00                <1> interrupt_%1: push byte 0
  1430 00000AB2 689A000000          <1>  push %1
  1431 00000AB7 E9100B0000          <1>  jmp interrupt_routine
  1432                                  		interrupt_entry_4    0x9B
  1433                              <1> 
  1434 00000ABC 6A00                <1> interrupt_%1: push byte 0
  1435 00000ABE 689B000000          <1>  push %1
  1436 00000AC3 E9040B0000          <1>  jmp interrupt_routine
  1437                                  		interrupt_entry_4    0x9C
  1438                              <1> 
  1439 00000AC8 6A00                <1> interrupt_%1: push byte 0
  1440 00000ACA 689C000000          <1>  push %1
  1441 00000ACF E9F80A0000          <1>  jmp interrupt_routine
  1442                                  		interrupt_entry_4    0x9D
  1443                              <1> 
  1444 00000AD4 6A00                <1> interrupt_%1: push byte 0
  1445 00000AD6 689D000000          <1>  push %1
  1446 00000ADB E9EC0A0000          <1>  jmp interrupt_routine
  1447                                  		interrupt_entry_4    0x9E
  1448                              <1> 
  1449 00000AE0 6A00                <1> interrupt_%1: push byte 0
  1450 00000AE2 689E000000          <1>  push %1
  1451 00000AE7 E9E00A0000          <1>  jmp interrupt_routine
  1452                                  		interrupt_entry_4    0x9F
  1453                              <1> 
  1454 00000AEC 6A00                <1> interrupt_%1: push byte 0
  1455 00000AEE 689F000000          <1>  push %1
  1456 00000AF3 E9D40A0000          <1>  jmp interrupt_routine
  1457                                  		interrupt_entry_4    0xA0
  1458                              <1> 
  1459 00000AF8 6A00                <1> interrupt_%1: push byte 0
  1460 00000AFA 68A0000000          <1>  push %1
  1461 00000AFF E9C80A0000          <1>  jmp interrupt_routine
  1462                                  		interrupt_entry_4    0xA1
  1463                              <1> 
  1464 00000B04 6A00                <1> interrupt_%1: push byte 0
  1465 00000B06 68A1000000          <1>  push %1
  1466 00000B0B E9BC0A0000          <1>  jmp interrupt_routine
  1467                                  		interrupt_entry_4    0xA2
  1468                              <1> 
  1469 00000B10 6A00                <1> interrupt_%1: push byte 0
  1470 00000B12 68A2000000          <1>  push %1
  1471 00000B17 E9B00A0000          <1>  jmp interrupt_routine
  1472                                  		interrupt_entry_4    0xA3
  1473                              <1> 
  1474 00000B1C 6A00                <1> interrupt_%1: push byte 0
  1475 00000B1E 68A3000000          <1>  push %1
  1476 00000B23 E9A40A0000          <1>  jmp interrupt_routine
  1477                                  		interrupt_entry_4    0xA4
  1478                              <1> 
  1479 00000B28 6A00                <1> interrupt_%1: push byte 0
  1480 00000B2A 68A4000000          <1>  push %1
  1481 00000B2F E9980A0000          <1>  jmp interrupt_routine
  1482                                  		interrupt_entry_4    0xA5
  1483                              <1> 
  1484 00000B34 6A00                <1> interrupt_%1: push byte 0
  1485 00000B36 68A5000000          <1>  push %1
  1486 00000B3B E98C0A0000          <1>  jmp interrupt_routine
  1487                                  		interrupt_entry_4    0xA6
  1488                              <1> 
  1489 00000B40 6A00                <1> interrupt_%1: push byte 0
  1490 00000B42 68A6000000          <1>  push %1
  1491 00000B47 E9800A0000          <1>  jmp interrupt_routine
  1492                                  		interrupt_entry_4    0xA7
  1493                              <1> 
  1494 00000B4C 6A00                <1> interrupt_%1: push byte 0
  1495 00000B4E 68A7000000          <1>  push %1
  1496 00000B53 E9740A0000          <1>  jmp interrupt_routine
  1497                                  		interrupt_entry_4    0xA8
  1498                              <1> 
  1499 00000B58 6A00                <1> interrupt_%1: push byte 0
  1500 00000B5A 68A8000000          <1>  push %1
  1501 00000B5F E9680A0000          <1>  jmp interrupt_routine
  1502                                  		interrupt_entry_4    0xA9
  1503                              <1> 
  1504 00000B64 6A00                <1> interrupt_%1: push byte 0
  1505 00000B66 68A9000000          <1>  push %1
  1506 00000B6B E95C0A0000          <1>  jmp interrupt_routine
  1507                                  		interrupt_entry_4    0xAA
  1508                              <1> 
  1509 00000B70 6A00                <1> interrupt_%1: push byte 0
  1510 00000B72 68AA000000          <1>  push %1
  1511 00000B77 E9500A0000          <1>  jmp interrupt_routine
  1512                                  		interrupt_entry_4    0xAB
  1513                              <1> 
  1514 00000B7C 6A00                <1> interrupt_%1: push byte 0
  1515 00000B7E 68AB000000          <1>  push %1
  1516 00000B83 E9440A0000          <1>  jmp interrupt_routine
  1517                                  		interrupt_entry_4    0xAC
  1518                              <1> 
  1519 00000B88 6A00                <1> interrupt_%1: push byte 0
  1520 00000B8A 68AC000000          <1>  push %1
  1521 00000B8F E9380A0000          <1>  jmp interrupt_routine
  1522                                  		interrupt_entry_4    0xAD
  1523                              <1> 
  1524 00000B94 6A00                <1> interrupt_%1: push byte 0
  1525 00000B96 68AD000000          <1>  push %1
  1526 00000B9B E92C0A0000          <1>  jmp interrupt_routine
  1527                                  		interrupt_entry_4    0xAE
  1528                              <1> 
  1529 00000BA0 6A00                <1> interrupt_%1: push byte 0
  1530 00000BA2 68AE000000          <1>  push %1
  1531 00000BA7 E9200A0000          <1>  jmp interrupt_routine
  1532                                  		interrupt_entry_4    0xAF
  1533                              <1> 
  1534 00000BAC 6A00                <1> interrupt_%1: push byte 0
  1535 00000BAE 68AF000000          <1>  push %1
  1536 00000BB3 E9140A0000          <1>  jmp interrupt_routine
  1537                                  		interrupt_entry_4    0xB0
  1538                              <1> 
  1539 00000BB8 6A00                <1> interrupt_%1: push byte 0
  1540 00000BBA 68B0000000          <1>  push %1
  1541 00000BBF E9080A0000          <1>  jmp interrupt_routine
  1542                                  		interrupt_entry_4    0xB1
  1543                              <1> 
  1544 00000BC4 6A00                <1> interrupt_%1: push byte 0
  1545 00000BC6 68B1000000          <1>  push %1
  1546 00000BCB E9FC090000          <1>  jmp interrupt_routine
  1547                                  		interrupt_entry_4    0xB2
  1548                              <1> 
  1549 00000BD0 6A00                <1> interrupt_%1: push byte 0
  1550 00000BD2 68B2000000          <1>  push %1
  1551 00000BD7 E9F0090000          <1>  jmp interrupt_routine
  1552                                  		interrupt_entry_4    0xB3
  1553                              <1> 
  1554 00000BDC 6A00                <1> interrupt_%1: push byte 0
  1555 00000BDE 68B3000000          <1>  push %1
  1556 00000BE3 E9E4090000          <1>  jmp interrupt_routine
  1557                                  		interrupt_entry_4    0xB4
  1558                              <1> 
  1559 00000BE8 6A00                <1> interrupt_%1: push byte 0
  1560 00000BEA 68B4000000          <1>  push %1
  1561 00000BEF E9D8090000          <1>  jmp interrupt_routine
  1562                                  		interrupt_entry_4    0xB5
  1563                              <1> 
  1564 00000BF4 6A00                <1> interrupt_%1: push byte 0
  1565 00000BF6 68B5000000          <1>  push %1
  1566 00000BFB E9CC090000          <1>  jmp interrupt_routine
  1567                                  		interrupt_entry_4    0xB6
  1568                              <1> 
  1569 00000C00 6A00                <1> interrupt_%1: push byte 0
  1570 00000C02 68B6000000          <1>  push %1
  1571 00000C07 E9C0090000          <1>  jmp interrupt_routine
  1572                                  		interrupt_entry_4    0xB7
  1573                              <1> 
  1574 00000C0C 6A00                <1> interrupt_%1: push byte 0
  1575 00000C0E 68B7000000          <1>  push %1
  1576 00000C13 E9B4090000          <1>  jmp interrupt_routine
  1577                                  		interrupt_entry_4    0xB8
  1578                              <1> 
  1579 00000C18 6A00                <1> interrupt_%1: push byte 0
  1580 00000C1A 68B8000000          <1>  push %1
  1581 00000C1F E9A8090000          <1>  jmp interrupt_routine
  1582                                  		interrupt_entry_4    0xB9
  1583                              <1> 
  1584 00000C24 6A00                <1> interrupt_%1: push byte 0
  1585 00000C26 68B9000000          <1>  push %1
  1586 00000C2B E99C090000          <1>  jmp interrupt_routine
  1587                                  		interrupt_entry_4    0xBA
  1588                              <1> 
  1589 00000C30 6A00                <1> interrupt_%1: push byte 0
  1590 00000C32 68BA000000          <1>  push %1
  1591 00000C37 E990090000          <1>  jmp interrupt_routine
  1592                                  		interrupt_entry_4    0xBB
  1593                              <1> 
  1594 00000C3C 6A00                <1> interrupt_%1: push byte 0
  1595 00000C3E 68BB000000          <1>  push %1
  1596 00000C43 E984090000          <1>  jmp interrupt_routine
  1597                                  		interrupt_entry_4    0xBC
  1598                              <1> 
  1599 00000C48 6A00                <1> interrupt_%1: push byte 0
  1600 00000C4A 68BC000000          <1>  push %1
  1601 00000C4F E978090000          <1>  jmp interrupt_routine
  1602                                  		interrupt_entry_4    0xBD
  1603                              <1> 
  1604 00000C54 6A00                <1> interrupt_%1: push byte 0
  1605 00000C56 68BD000000          <1>  push %1
  1606 00000C5B E96C090000          <1>  jmp interrupt_routine
  1607                                  		interrupt_entry_4    0xBE
  1608                              <1> 
  1609 00000C60 6A00                <1> interrupt_%1: push byte 0
  1610 00000C62 68BE000000          <1>  push %1
  1611 00000C67 E960090000          <1>  jmp interrupt_routine
  1612                                  		interrupt_entry_4    0xBF
  1613                              <1> 
  1614 00000C6C 6A00                <1> interrupt_%1: push byte 0
  1615 00000C6E 68BF000000          <1>  push %1
  1616 00000C73 E954090000          <1>  jmp interrupt_routine
  1617                                  		interrupt_entry_4    0xC0
  1618                              <1> 
  1619 00000C78 6A00                <1> interrupt_%1: push byte 0
  1620 00000C7A 68C0000000          <1>  push %1
  1621 00000C7F E948090000          <1>  jmp interrupt_routine
  1622                                  		interrupt_entry_4    0xC1
  1623                              <1> 
  1624 00000C84 6A00                <1> interrupt_%1: push byte 0
  1625 00000C86 68C1000000          <1>  push %1
  1626 00000C8B E93C090000          <1>  jmp interrupt_routine
  1627                                  		interrupt_entry_4    0xC2
  1628                              <1> 
  1629 00000C90 6A00                <1> interrupt_%1: push byte 0
  1630 00000C92 68C2000000          <1>  push %1
  1631 00000C97 E930090000          <1>  jmp interrupt_routine
  1632                                  		interrupt_entry_4    0xC3
  1633                              <1> 
  1634 00000C9C 6A00                <1> interrupt_%1: push byte 0
  1635 00000C9E 68C3000000          <1>  push %1
  1636 00000CA3 E924090000          <1>  jmp interrupt_routine
  1637                                  		interrupt_entry_4    0xC4
  1638                              <1> 
  1639 00000CA8 6A00                <1> interrupt_%1: push byte 0
  1640 00000CAA 68C4000000          <1>  push %1
  1641 00000CAF E918090000          <1>  jmp interrupt_routine
  1642                                  		interrupt_entry_4    0xC5
  1643                              <1> 
  1644 00000CB4 6A00                <1> interrupt_%1: push byte 0
  1645 00000CB6 68C5000000          <1>  push %1
  1646 00000CBB E90C090000          <1>  jmp interrupt_routine
  1647                                  		interrupt_entry_4    0xC6
  1648                              <1> 
  1649 00000CC0 6A00                <1> interrupt_%1: push byte 0
  1650 00000CC2 68C6000000          <1>  push %1
  1651 00000CC7 E900090000          <1>  jmp interrupt_routine
  1652                                  		interrupt_entry_4    0xC7
  1653                              <1> 
  1654 00000CCC 6A00                <1> interrupt_%1: push byte 0
  1655 00000CCE 68C7000000          <1>  push %1
  1656 00000CD3 E9F4080000          <1>  jmp interrupt_routine
  1657                                  		interrupt_entry_4    0xC8
  1658                              <1> 
  1659 00000CD8 6A00                <1> interrupt_%1: push byte 0
  1660 00000CDA 68C8000000          <1>  push %1
  1661 00000CDF E9E8080000          <1>  jmp interrupt_routine
  1662                                  		interrupt_entry_4    0xC9
  1663                              <1> 
  1664 00000CE4 6A00                <1> interrupt_%1: push byte 0
  1665 00000CE6 68C9000000          <1>  push %1
  1666 00000CEB E9DC080000          <1>  jmp interrupt_routine
  1667                                  		interrupt_entry_4    0xCA
  1668                              <1> 
  1669 00000CF0 6A00                <1> interrupt_%1: push byte 0
  1670 00000CF2 68CA000000          <1>  push %1
  1671 00000CF7 E9D0080000          <1>  jmp interrupt_routine
  1672                                  		interrupt_entry_4    0xCB
  1673                              <1> 
  1674 00000CFC 6A00                <1> interrupt_%1: push byte 0
  1675 00000CFE 68CB000000          <1>  push %1
  1676 00000D03 E9C4080000          <1>  jmp interrupt_routine
  1677                                  		interrupt_entry_4    0xCC
  1678                              <1> 
  1679 00000D08 6A00                <1> interrupt_%1: push byte 0
  1680 00000D0A 68CC000000          <1>  push %1
  1681 00000D0F E9B8080000          <1>  jmp interrupt_routine
  1682                                  		interrupt_entry_4    0xCD
  1683                              <1> 
  1684 00000D14 6A00                <1> interrupt_%1: push byte 0
  1685 00000D16 68CD000000          <1>  push %1
  1686 00000D1B E9AC080000          <1>  jmp interrupt_routine
  1687                                  		interrupt_entry_4    0xCE
  1688                              <1> 
  1689 00000D20 6A00                <1> interrupt_%1: push byte 0
  1690 00000D22 68CE000000          <1>  push %1
  1691 00000D27 E9A0080000          <1>  jmp interrupt_routine
  1692                                  		interrupt_entry_4    0xCF
  1693                              <1> 
  1694 00000D2C 6A00                <1> interrupt_%1: push byte 0
  1695 00000D2E 68CF000000          <1>  push %1
  1696 00000D33 E994080000          <1>  jmp interrupt_routine
  1697                                  		interrupt_entry_4    0xD0
  1698                              <1> 
  1699 00000D38 6A00                <1> interrupt_%1: push byte 0
  1700 00000D3A 68D0000000          <1>  push %1
  1701 00000D3F E988080000          <1>  jmp interrupt_routine
  1702                                  		interrupt_entry_4    0xD1
  1703                              <1> 
  1704 00000D44 6A00                <1> interrupt_%1: push byte 0
  1705 00000D46 68D1000000          <1>  push %1
  1706 00000D4B E97C080000          <1>  jmp interrupt_routine
  1707                                  		interrupt_entry_4    0xD2
  1708                              <1> 
  1709 00000D50 6A00                <1> interrupt_%1: push byte 0
  1710 00000D52 68D2000000          <1>  push %1
  1711 00000D57 E970080000          <1>  jmp interrupt_routine
  1712                                  		interrupt_entry_4    0xD3
  1713                              <1> 
  1714 00000D5C 6A00                <1> interrupt_%1: push byte 0
  1715 00000D5E 68D3000000          <1>  push %1
  1716 00000D63 E964080000          <1>  jmp interrupt_routine
  1717                                  		interrupt_entry_4    0xD4
  1718                              <1> 
  1719 00000D68 6A00                <1> interrupt_%1: push byte 0
  1720 00000D6A 68D4000000          <1>  push %1
  1721 00000D6F E958080000          <1>  jmp interrupt_routine
  1722                                  		interrupt_entry_4    0xD5
  1723                              <1> 
  1724 00000D74 6A00                <1> interrupt_%1: push byte 0
  1725 00000D76 68D5000000          <1>  push %1
  1726 00000D7B E94C080000          <1>  jmp interrupt_routine
  1727                                  		interrupt_entry_4    0xD6
  1728                              <1> 
  1729 00000D80 6A00                <1> interrupt_%1: push byte 0
  1730 00000D82 68D6000000          <1>  push %1
  1731 00000D87 E940080000          <1>  jmp interrupt_routine
  1732                                  		interrupt_entry_4    0xD7
  1733                              <1> 
  1734 00000D8C 6A00                <1> interrupt_%1: push byte 0
  1735 00000D8E 68D7000000          <1>  push %1
  1736 00000D93 E934080000          <1>  jmp interrupt_routine
  1737                                  		interrupt_entry_4    0xD8
  1738                              <1> 
  1739 00000D98 6A00                <1> interrupt_%1: push byte 0
  1740 00000D9A 68D8000000          <1>  push %1
  1741 00000D9F E928080000          <1>  jmp interrupt_routine
  1742                                  		interrupt_entry_4    0xD9
  1743                              <1> 
  1744 00000DA4 6A00                <1> interrupt_%1: push byte 0
  1745 00000DA6 68D9000000          <1>  push %1
  1746 00000DAB E91C080000          <1>  jmp interrupt_routine
  1747                                  		interrupt_entry_4    0xDA
  1748                              <1> 
  1749 00000DB0 6A00                <1> interrupt_%1: push byte 0
  1750 00000DB2 68DA000000          <1>  push %1
  1751 00000DB7 E910080000          <1>  jmp interrupt_routine
  1752                                  		interrupt_entry_4    0xDB
  1753                              <1> 
  1754 00000DBC 6A00                <1> interrupt_%1: push byte 0
  1755 00000DBE 68DB000000          <1>  push %1
  1756 00000DC3 E904080000          <1>  jmp interrupt_routine
  1757                                  		interrupt_entry_4    0xDC
  1758                              <1> 
  1759 00000DC8 6A00                <1> interrupt_%1: push byte 0
  1760 00000DCA 68DC000000          <1>  push %1
  1761 00000DCF E9F8070000          <1>  jmp interrupt_routine
  1762                                  		interrupt_entry_4    0xDD
  1763                              <1> 
  1764 00000DD4 6A00                <1> interrupt_%1: push byte 0
  1765 00000DD6 68DD000000          <1>  push %1
  1766 00000DDB E9EC070000          <1>  jmp interrupt_routine
  1767                                  		interrupt_entry_4    0xDE
  1768                              <1> 
  1769 00000DE0 6A00                <1> interrupt_%1: push byte 0
  1770 00000DE2 68DE000000          <1>  push %1
  1771 00000DE7 E9E0070000          <1>  jmp interrupt_routine
  1772                                  		interrupt_entry_4    0xDF
  1773                              <1> 
  1774 00000DEC 6A00                <1> interrupt_%1: push byte 0
  1775 00000DEE 68DF000000          <1>  push %1
  1776 00000DF3 E9D4070000          <1>  jmp interrupt_routine
  1777                                  		interrupt_entry_4    0xE0
  1778                              <1> 
  1779 00000DF8 6A00                <1> interrupt_%1: push byte 0
  1780 00000DFA 68E0000000          <1>  push %1
  1781 00000DFF E9C8070000          <1>  jmp interrupt_routine
  1782                                  		interrupt_entry_4    0xE1
  1783                              <1> 
  1784 00000E04 6A00                <1> interrupt_%1: push byte 0
  1785 00000E06 68E1000000          <1>  push %1
  1786 00000E0B E9BC070000          <1>  jmp interrupt_routine
  1787                                  		interrupt_entry_4    0xE2
  1788                              <1> 
  1789 00000E10 6A00                <1> interrupt_%1: push byte 0
  1790 00000E12 68E2000000          <1>  push %1
  1791 00000E17 E9B0070000          <1>  jmp interrupt_routine
  1792                                  		interrupt_entry_4    0xE3
  1793                              <1> 
  1794 00000E1C 6A00                <1> interrupt_%1: push byte 0
  1795 00000E1E 68E3000000          <1>  push %1
  1796 00000E23 E9A4070000          <1>  jmp interrupt_routine
  1797                                  		interrupt_entry_4    0xE4
  1798                              <1> 
  1799 00000E28 6A00                <1> interrupt_%1: push byte 0
  1800 00000E2A 68E4000000          <1>  push %1
  1801 00000E2F E998070000          <1>  jmp interrupt_routine
  1802                                  		interrupt_entry_4    0xE5
  1803                              <1> 
  1804 00000E34 6A00                <1> interrupt_%1: push byte 0
  1805 00000E36 68E5000000          <1>  push %1
  1806 00000E3B E98C070000          <1>  jmp interrupt_routine
  1807                                  		interrupt_entry_4    0xE6
  1808                              <1> 
  1809 00000E40 6A00                <1> interrupt_%1: push byte 0
  1810 00000E42 68E6000000          <1>  push %1
  1811 00000E47 E980070000          <1>  jmp interrupt_routine
  1812                                  		interrupt_entry_4    0xE7
  1813                              <1> 
  1814 00000E4C 6A00                <1> interrupt_%1: push byte 0
  1815 00000E4E 68E7000000          <1>  push %1
  1816 00000E53 E974070000          <1>  jmp interrupt_routine
  1817                                  		interrupt_entry_4    0xE8
  1818                              <1> 
  1819 00000E58 6A00                <1> interrupt_%1: push byte 0
  1820 00000E5A 68E8000000          <1>  push %1
  1821 00000E5F E968070000          <1>  jmp interrupt_routine
  1822                                  		interrupt_entry_4    0xE9
  1823                              <1> 
  1824 00000E64 6A00                <1> interrupt_%1: push byte 0
  1825 00000E66 68E9000000          <1>  push %1
  1826 00000E6B E95C070000          <1>  jmp interrupt_routine
  1827                                  		interrupt_entry_4    0xEA
  1828                              <1> 
  1829 00000E70 6A00                <1> interrupt_%1: push byte 0
  1830 00000E72 68EA000000          <1>  push %1
  1831 00000E77 E950070000          <1>  jmp interrupt_routine
  1832                                  		interrupt_entry_4    0xEB
  1833                              <1> 
  1834 00000E7C 6A00                <1> interrupt_%1: push byte 0
  1835 00000E7E 68EB000000          <1>  push %1
  1836 00000E83 E944070000          <1>  jmp interrupt_routine
  1837                                  		interrupt_entry_4    0xEC
  1838                              <1> 
  1839 00000E88 6A00                <1> interrupt_%1: push byte 0
  1840 00000E8A 68EC000000          <1>  push %1
  1841 00000E8F E938070000          <1>  jmp interrupt_routine
  1842                                  		interrupt_entry_4    0xED
  1843                              <1> 
  1844 00000E94 6A00                <1> interrupt_%1: push byte 0
  1845 00000E96 68ED000000          <1>  push %1
  1846 00000E9B E92C070000          <1>  jmp interrupt_routine
  1847                                  		interrupt_entry_4    0xEE
  1848                              <1> 
  1849 00000EA0 6A00                <1> interrupt_%1: push byte 0
  1850 00000EA2 68EE000000          <1>  push %1
  1851 00000EA7 E920070000          <1>  jmp interrupt_routine
  1852                                  		interrupt_entry_4    0xEF
  1853                              <1> 
  1854 00000EAC 6A00                <1> interrupt_%1: push byte 0
  1855 00000EAE 68EF000000          <1>  push %1
  1856 00000EB3 E914070000          <1>  jmp interrupt_routine
  1857                                  		interrupt_entry_4irq 0xF0
  1858                              <1> 
  1859 00000EB8 6A00                <1> interrupt_%1: push byte 0
  1860 00000EBA 68F0000000          <1>  push %1
  1861 00000EBF E9AC030000          <1>  jmp interrupt_routine_irq
  1862                                  		interrupt_entry_4irq 0xF1
  1863                              <1> 
  1864 00000EC4 6A00                <1> interrupt_%1: push byte 0
  1865 00000EC6 68F1000000          <1>  push %1
  1866 00000ECB E9A0030000          <1>  jmp interrupt_routine_irq
  1867                                  		interrupt_entry_4irq 0xF2
  1868                              <1> 
  1869 00000ED0 6A00                <1> interrupt_%1: push byte 0
  1870 00000ED2 68F2000000          <1>  push %1
  1871 00000ED7 E994030000          <1>  jmp interrupt_routine_irq
  1872                                  		interrupt_entry_4irq 0xF3
  1873                              <1> 
  1874 00000EDC 6A00                <1> interrupt_%1: push byte 0
  1875 00000EDE 68F3000000          <1>  push %1
  1876 00000EE3 E988030000          <1>  jmp interrupt_routine_irq
  1877                                  		interrupt_entry_4irq 0xF4
  1878                              <1> 
  1879 00000EE8 6A00                <1> interrupt_%1: push byte 0
  1880 00000EEA 68F4000000          <1>  push %1
  1881 00000EEF E97C030000          <1>  jmp interrupt_routine_irq
  1882                                  		interrupt_entry_4irq 0xF5
  1883                              <1> 
  1884 00000EF4 6A00                <1> interrupt_%1: push byte 0
  1885 00000EF6 68F5000000          <1>  push %1
  1886 00000EFB E970030000          <1>  jmp interrupt_routine_irq
  1887                                  		interrupt_entry_4irq 0xF6
  1888                              <1> 
  1889 00000F00 6A00                <1> interrupt_%1: push byte 0
  1890 00000F02 68F6000000          <1>  push %1
  1891 00000F07 E964030000          <1>  jmp interrupt_routine_irq
  1892                                  		interrupt_entry_4irq 0xF7
  1893                              <1> 
  1894 00000F0C 6A00                <1> interrupt_%1: push byte 0
  1895 00000F0E 68F7000000          <1>  push %1
  1896 00000F13 E958030000          <1>  jmp interrupt_routine_irq
  1897                                  		interrupt_entry_4irq 0xF8
  1898                              <1> 
  1899 00000F18 6A00                <1> interrupt_%1: push byte 0
  1900 00000F1A 68F8000000          <1>  push %1
  1901 00000F1F E94C030000          <1>  jmp interrupt_routine_irq
  1902                                  		interrupt_entry_4irq 0xF9
  1903                              <1> 
  1904 00000F24 6A00                <1> interrupt_%1: push byte 0
  1905 00000F26 68F9000000          <1>  push %1
  1906 00000F2B E940030000          <1>  jmp interrupt_routine_irq
  1907                                  		interrupt_entry_4irq 0xFA
  1908                              <1> 
  1909 00000F30 6A00                <1> interrupt_%1: push byte 0
  1910 00000F32 68FA000000          <1>  push %1
  1911 00000F37 E934030000          <1>  jmp interrupt_routine_irq
  1912                                  		interrupt_entry_4irq 0xFB
  1913                              <1> 
  1914 00000F3C 6A00                <1> interrupt_%1: push byte 0
  1915 00000F3E 68FB000000          <1>  push %1
  1916 00000F43 E928030000          <1>  jmp interrupt_routine_irq
  1917                                  		interrupt_entry_4irq 0xFC
  1918                              <1> 
  1919 00000F48 6A00                <1> interrupt_%1: push byte 0
  1920 00000F4A 68FC000000          <1>  push %1
  1921 00000F4F E91C030000          <1>  jmp interrupt_routine_irq
  1922                                  		interrupt_entry_4irq 0xFD
  1923                              <1> 
  1924 00000F54 6A00                <1> interrupt_%1: push byte 0
  1925 00000F56 68FD000000          <1>  push %1
  1926 00000F5B E910030000          <1>  jmp interrupt_routine_irq
  1927                                  		interrupt_entry_4irq 0xFE
  1928                              <1> 
  1929 00000F60 6A00                <1> interrupt_%1: push byte 0
  1930 00000F62 68FE000000          <1>  push %1
  1931 00000F67 E904030000          <1>  jmp interrupt_routine_irq
  1932                                  		interrupt_entry_4irq 0xFF
  1933                              <1> 
  1934 00000F6C 6A00                <1> interrupt_%1: push byte 0
  1935 00000F6E 68FF000000          <1>  push %1
  1936 00000F73 E9F8020000          <1>  jmp interrupt_routine_irq
  1937                                  
  1938 00000F78 [0205]                  interrupt_procs:dw		interrupt_0x00
  1939 00000F7A [0B05]                  		dw		interrupt_0x01
  1940 00000F7C [1405]                  		dw		interrupt_0x02
  1941 00000F7E [1D05]                  		dw		interrupt_0x03
  1942 00000F80 [2605]                  		dw		interrupt_0x04
  1943 00000F82 [2F05]                  		dw		interrupt_0x05
  1944 00000F84 [3805]                  		dw		interrupt_0x06
  1945 00000F86 [4105]                  		dw		interrupt_0x07
  1946 00000F88 [4A05]                  		dw		interrupt_0x08
  1947 00000F8A [5105]                  		dw		interrupt_0x09
  1948 00000F8C [5A05]                  		dw		interrupt_0x0A
  1949 00000F8E [6105]                  		dw		interrupt_0x0B
  1950 00000F90 [6805]                  		dw		interrupt_0x0C
  1951 00000F92 [6F05]                  		dw		interrupt_0x0D
  1952 00000F94 [7605]                  		dw		interrupt_0x0E
  1953 00000F96 [7F05]                  		dw		interrupt_0x0F
  1954 00000F98 [8805]                  		dw		interrupt_0x10
  1955 00000F9A [9105]                  		dw		interrupt_0x11
  1956 00000F9C [9A05]                  		dw		interrupt_0x12
  1957 00000F9E [A305]                  		dw		interrupt_0x13
  1958 00000FA0 [AC05]                  		dw		interrupt_0x14
  1959 00000FA2 [B505]                  		dw		interrupt_0x15
  1960 00000FA4 [BE05]                  		dw		interrupt_0x16
  1961 00000FA6 [C705]                  		dw		interrupt_0x17
  1962 00000FA8 [D005]                  		dw		interrupt_0x18
  1963 00000FAA [D905]                  		dw		interrupt_0x19
  1964 00000FAC [E205]                  		dw		interrupt_0x1A
  1965 00000FAE [EB05]                  		dw		interrupt_0x1B
  1966 00000FB0 [F405]                  		dw		interrupt_0x1C
  1967 00000FB2 [FD05]                  		dw		interrupt_0x1D
  1968 00000FB4 [0606]                  		dw		interrupt_0x1E
  1969 00000FB6 [0F06]                  		dw		interrupt_0x1F
  1970                                  
  1971 00000FB8 [1806]                  		dw		interrupt_0x20
  1972 00000FBA [2106]                  		dw		interrupt_0x21
  1973 00000FBC [2A06]                  		dw		interrupt_0x22
  1974 00000FBE [3306]                  		dw		interrupt_0x23
  1975 00000FC0 [3C06]                  		dw		interrupt_0x24
  1976 00000FC2 [4506]                  		dw		interrupt_0x25
  1977 00000FC4 [4E06]                  		dw		interrupt_0x26
  1978 00000FC6 [5706]                  		dw		interrupt_0x27
  1979 00000FC8 [6006]                  		dw		interrupt_0x28
  1980 00000FCA [6906]                  		dw		interrupt_0x29
  1981 00000FCC [7206]                  		dw		interrupt_0x2A
  1982 00000FCE [7B06]                  		dw		interrupt_0x2B
  1983 00000FD0 [8406]                  		dw		interrupt_0x2C
  1984 00000FD2 [8D06]                  		dw		interrupt_0x2D
  1985 00000FD4 [9606]                  		dw		interrupt_0x2E
  1986 00000FD6 [9F06]                  		dw		interrupt_0x2F
  1987 00000FD8 [A806]                  		dw		interrupt_0x30
  1988 00000FDA [B106]                  		dw		interrupt_0x31
  1989 00000FDC [BA06]                  		dw		interrupt_0x32
  1990 00000FDE [C306]                  		dw		interrupt_0x33
  1991 00000FE0 [CC06]                  		dw		interrupt_0x34
  1992 00000FE2 [D506]                  		dw		interrupt_0x35
  1993 00000FE4 [DE06]                  		dw		interrupt_0x36
  1994 00000FE6 [E706]                  		dw		interrupt_0x37
  1995 00000FE8 [F006]                  		dw		interrupt_0x38
  1996 00000FEA [F906]                  		dw		interrupt_0x39
  1997 00000FEC [0207]                  		dw		interrupt_0x3A
  1998 00000FEE [0B07]                  		dw		interrupt_0x3B
  1999 00000FF0 [1407]                  		dw		interrupt_0x3C
  2000 00000FF2 [1D07]                  		dw		interrupt_0x3D
  2001 00000FF4 [2607]                  		dw		interrupt_0x3E
  2002 00000FF6 [2F07]                  		dw		interrupt_0x3F
  2003                                  
  2004 00000FF8 [3807]                  		dw		interrupt_0x40
  2005 00000FFA [4107]                  		dw		interrupt_0x41
  2006 00000FFC [4A07]                  		dw		interrupt_0x42
  2007 00000FFE [5307]                  		dw		interrupt_0x43
  2008 00001000 [5C07]                  		dw		interrupt_0x44
  2009 00001002 [6507]                  		dw		interrupt_0x45
  2010 00001004 [6E07]                  		dw		interrupt_0x46
  2011 00001006 [7707]                  		dw		interrupt_0x47
  2012 00001008 [8007]                  		dw		interrupt_0x48
  2013 0000100A [8907]                  		dw		interrupt_0x49
  2014 0000100C [9207]                  		dw		interrupt_0x4A
  2015 0000100E [9B07]                  		dw		interrupt_0x4B
  2016 00001010 [A407]                  		dw		interrupt_0x4C
  2017 00001012 [AD07]                  		dw		interrupt_0x4D
  2018 00001014 [B607]                  		dw		interrupt_0x4E
  2019 00001016 [BF07]                  		dw		interrupt_0x4F
  2020 00001018 [C807]                  		dw		interrupt_0x50
  2021 0000101A [D107]                  		dw		interrupt_0x51
  2022 0000101C [DA07]                  		dw		interrupt_0x52
  2023 0000101E [E307]                  		dw		interrupt_0x53
  2024 00001020 [EC07]                  		dw		interrupt_0x54
  2025 00001022 [F507]                  		dw		interrupt_0x55
  2026 00001024 [FE07]                  		dw		interrupt_0x56
  2027 00001026 [0708]                  		dw		interrupt_0x57
  2028 00001028 [1008]                  		dw		interrupt_0x58
  2029 0000102A [1908]                  		dw		interrupt_0x59
  2030 0000102C [2208]                  		dw		interrupt_0x5A
  2031 0000102E [2B08]                  		dw		interrupt_0x5B
  2032 00001030 [3408]                  		dw		interrupt_0x5C
  2033 00001032 [3D08]                  		dw		interrupt_0x5D
  2034 00001034 [4608]                  		dw		interrupt_0x5E
  2035 00001036 [4F08]                  		dw		interrupt_0x5F
  2036                                  
  2037 00001038 [5808]                  		dw		interrupt_0x60
  2038 0000103A [6108]                  		dw		interrupt_0x61
  2039 0000103C [6A08]                  		dw		interrupt_0x62
  2040 0000103E [7308]                  		dw		interrupt_0x63
  2041 00001040 [7C08]                  		dw		interrupt_0x64
  2042 00001042 [8508]                  		dw		interrupt_0x65
  2043 00001044 [8E08]                  		dw		interrupt_0x66
  2044 00001046 [9708]                  		dw		interrupt_0x67
  2045 00001048 [A008]                  		dw		interrupt_0x68
  2046 0000104A [A908]                  		dw		interrupt_0x69
  2047 0000104C [B208]                  		dw		interrupt_0x6A
  2048 0000104E [BB08]                  		dw		interrupt_0x6B
  2049 00001050 [C408]                  		dw		interrupt_0x6C
  2050 00001052 [CD08]                  		dw		interrupt_0x6D
  2051 00001054 [D608]                  		dw		interrupt_0x6E
  2052 00001056 [DF08]                  		dw		interrupt_0x6F
  2053 00001058 [E808]                  		dw		interrupt_0x70
  2054 0000105A [F108]                  		dw		interrupt_0x71
  2055 0000105C [FA08]                  		dw		interrupt_0x72
  2056 0000105E [0309]                  		dw		interrupt_0x73
  2057 00001060 [0C09]                  		dw		interrupt_0x74
  2058 00001062 [1509]                  		dw		interrupt_0x75
  2059 00001064 [1E09]                  		dw		interrupt_0x76
  2060 00001066 [2709]                  		dw		interrupt_0x77
  2061 00001068 [3009]                  		dw		interrupt_0x78
  2062 0000106A [3909]                  		dw		interrupt_0x79
  2063 0000106C [4209]                  		dw		interrupt_0x7A
  2064 0000106E [4B09]                  		dw		interrupt_0x7B
  2065 00001070 [5409]                  		dw		interrupt_0x7C
  2066 00001072 [5D09]                  		dw		interrupt_0x7D
  2067 00001074 [6609]                  		dw		interrupt_0x7E
  2068 00001076 [6F09]                  		dw		interrupt_0x7F
  2069                                  
  2070 00001078 [7809]                  		dw		interrupt_0x80
  2071 0000107A [8409]                  		dw		interrupt_0x81
  2072 0000107C [9009]                  		dw		interrupt_0x82
  2073 0000107E [9C09]                  		dw		interrupt_0x83
  2074 00001080 [A809]                  		dw		interrupt_0x84
  2075 00001082 [B409]                  		dw		interrupt_0x85
  2076 00001084 [C009]                  		dw		interrupt_0x86
  2077 00001086 [CC09]                  		dw		interrupt_0x87
  2078 00001088 [D809]                  		dw		interrupt_0x88
  2079 0000108A [E409]                  		dw		interrupt_0x89
  2080 0000108C [F009]                  		dw		interrupt_0x8A
  2081 0000108E [FC09]                  		dw		interrupt_0x8B
  2082 00001090 [080A]                  		dw		interrupt_0x8C
  2083 00001092 [140A]                  		dw		interrupt_0x8D
  2084 00001094 [200A]                  		dw		interrupt_0x8E
  2085 00001096 [2C0A]                  		dw		interrupt_0x8F
  2086 00001098 [380A]                  		dw		interrupt_0x90
  2087 0000109A [440A]                  		dw		interrupt_0x91
  2088 0000109C [500A]                  		dw		interrupt_0x92
  2089 0000109E [5C0A]                  		dw		interrupt_0x93
  2090 000010A0 [680A]                  		dw		interrupt_0x94
  2091 000010A2 [740A]                  		dw		interrupt_0x95
  2092 000010A4 [800A]                  		dw		interrupt_0x96
  2093 000010A6 [8C0A]                  		dw		interrupt_0x97
  2094 000010A8 [980A]                  		dw		interrupt_0x98
  2095 000010AA [A40A]                  		dw		interrupt_0x99
  2096 000010AC [B00A]                  		dw		interrupt_0x9A
  2097 000010AE [BC0A]                  		dw		interrupt_0x9B
  2098 000010B0 [C80A]                  		dw		interrupt_0x9C
  2099 000010B2 [D40A]                  		dw		interrupt_0x9D
  2100 000010B4 [E00A]                  		dw		interrupt_0x9E
  2101 000010B6 [EC0A]                  		dw		interrupt_0x9F
  2102                                  
  2103 000010B8 [F80A]                  		dw		interrupt_0xA0
  2104 000010BA [040B]                  		dw		interrupt_0xA1
  2105 000010BC [100B]                  		dw		interrupt_0xA2
  2106 000010BE [1C0B]                  		dw		interrupt_0xA3
  2107 000010C0 [280B]                  		dw		interrupt_0xA4
  2108 000010C2 [340B]                  		dw		interrupt_0xA5
  2109 000010C4 [400B]                  		dw		interrupt_0xA6
  2110 000010C6 [4C0B]                  		dw		interrupt_0xA7
  2111 000010C8 [580B]                  		dw		interrupt_0xA8
  2112 000010CA [640B]                  		dw		interrupt_0xA9
  2113 000010CC [700B]                  		dw		interrupt_0xAA
  2114 000010CE [7C0B]                  		dw		interrupt_0xAB
  2115 000010D0 [880B]                  		dw		interrupt_0xAC
  2116 000010D2 [940B]                  		dw		interrupt_0xAD
  2117 000010D4 [A00B]                  		dw		interrupt_0xAE
  2118 000010D6 [AC0B]                  		dw		interrupt_0xAF
  2119 000010D8 [B80B]                  		dw		interrupt_0xB0
  2120 000010DA [C40B]                  		dw		interrupt_0xB1
  2121 000010DC [D00B]                  		dw		interrupt_0xB2
  2122 000010DE [DC0B]                  		dw		interrupt_0xB3
  2123 000010E0 [E80B]                  		dw		interrupt_0xB4
  2124 000010E2 [F40B]                  		dw		interrupt_0xB5
  2125 000010E4 [000C]                  		dw		interrupt_0xB6
  2126 000010E6 [0C0C]                  		dw		interrupt_0xB7
  2127 000010E8 [180C]                  		dw		interrupt_0xB8
  2128 000010EA [240C]                  		dw		interrupt_0xB9
  2129 000010EC [300C]                  		dw		interrupt_0xBA
  2130 000010EE [3C0C]                  		dw		interrupt_0xBB
  2131 000010F0 [480C]                  		dw		interrupt_0xBC
  2132 000010F2 [540C]                  		dw		interrupt_0xBD
  2133 000010F4 [600C]                  		dw		interrupt_0xBE
  2134 000010F6 [6C0C]                  		dw		interrupt_0xBF
  2135                                  
  2136 000010F8 [780C]                  		dw		interrupt_0xC0
  2137 000010FA [840C]                  		dw		interrupt_0xC1
  2138 000010FC [900C]                  		dw		interrupt_0xC2
  2139 000010FE [9C0C]                  		dw		interrupt_0xC3
  2140 00001100 [A80C]                  		dw		interrupt_0xC4
  2141 00001102 [B40C]                  		dw		interrupt_0xC5
  2142 00001104 [C00C]                  		dw		interrupt_0xC6
  2143 00001106 [CC0C]                  		dw		interrupt_0xC7
  2144 00001108 [D80C]                  		dw		interrupt_0xC8
  2145 0000110A [E40C]                  		dw		interrupt_0xC9
  2146 0000110C [F00C]                  		dw		interrupt_0xCA
  2147 0000110E [FC0C]                  		dw		interrupt_0xCB
  2148 00001110 [080D]                  		dw		interrupt_0xCC
  2149 00001112 [140D]                  		dw		interrupt_0xCD
  2150 00001114 [200D]                  		dw		interrupt_0xCE
  2151 00001116 [2C0D]                  		dw		interrupt_0xCF
  2152 00001118 [380D]                  		dw		interrupt_0xD0
  2153 0000111A [440D]                  		dw		interrupt_0xD1
  2154 0000111C [500D]                  		dw		interrupt_0xD2
  2155 0000111E [5C0D]                  		dw		interrupt_0xD3
  2156 00001120 [680D]                  		dw		interrupt_0xD4
  2157 00001122 [740D]                  		dw		interrupt_0xD5
  2158 00001124 [800D]                  		dw		interrupt_0xD6
  2159 00001126 [8C0D]                  		dw		interrupt_0xD7
  2160 00001128 [980D]                  		dw		interrupt_0xD8
  2161 0000112A [A40D]                  		dw		interrupt_0xD9
  2162 0000112C [B00D]                  		dw		interrupt_0xDA
  2163 0000112E [BC0D]                  		dw		interrupt_0xDB
  2164 00001130 [C80D]                  		dw		interrupt_0xDC
  2165 00001132 [D40D]                  		dw		interrupt_0xDD
  2166 00001134 [E00D]                  		dw		interrupt_0xDE
  2167 00001136 [EC0D]                  		dw		interrupt_0xDF
  2168                                  
  2169 00001138 [F80D]                  		dw		interrupt_0xE0
  2170 0000113A [040E]                  		dw		interrupt_0xE1
  2171 0000113C [100E]                  		dw		interrupt_0xE2
  2172 0000113E [1C0E]                  		dw		interrupt_0xE3
  2173 00001140 [280E]                  		dw		interrupt_0xE4
  2174 00001142 [340E]                  		dw		interrupt_0xE5
  2175 00001144 [400E]                  		dw		interrupt_0xE6
  2176 00001146 [4C0E]                  		dw		interrupt_0xE7
  2177 00001148 [580E]                  		dw		interrupt_0xE8
  2178 0000114A [640E]                  		dw		interrupt_0xE9
  2179 0000114C [700E]                  		dw		interrupt_0xEA
  2180 0000114E [7C0E]                  		dw		interrupt_0xEB
  2181 00001150 [880E]                  		dw		interrupt_0xEC
  2182 00001152 [940E]                  		dw		interrupt_0xED
  2183 00001154 [A00E]                  		dw		interrupt_0xEE
  2184 00001156 [AC0E]                  		dw		interrupt_0xEF
  2185 00001158 [B80E]                  		dw		interrupt_0xF0
  2186 0000115A [C40E]                  		dw		interrupt_0xF1
  2187 0000115C [D00E]                  		dw		interrupt_0xF2
  2188 0000115E [DC0E]                  		dw		interrupt_0xF3
  2189 00001160 [E80E]                  		dw		interrupt_0xF4
  2190 00001162 [F40E]                  		dw		interrupt_0xF5
  2191 00001164 [000F]                  		dw		interrupt_0xF6
  2192 00001166 [0C0F]                  		dw		interrupt_0xF7
  2193 00001168 [180F]                  		dw		interrupt_0xF8
  2194 0000116A [240F]                  		dw		interrupt_0xF9
  2195 0000116C [300F]                  		dw		interrupt_0xFA
  2196 0000116E [3C0F]                  		dw		interrupt_0xFB
  2197 00001170 [480F]                  		dw		interrupt_0xFC
  2198 00001172 [540F]                  		dw		interrupt_0xFD
  2199 00001174 [600F]                  		dw		interrupt_0xFE
  2200 00001176 [6C0F]                  		dw		interrupt_0xFF
  2201                                  
  2202                                  interrupt_0x00_strs:
  2203 00001178 [7703]                  		dw		str_fault_0x00
  2204 0000117A [8603]                  		dw		str_fault_0x01
  2205 0000117C [8C03]                  		dw		str_fault_0x02
  2206 0000117E [9003]                  		dw		str_fault_0x03
  2207 00001180 [9B03]                  		dw		str_fault_0x04
  2208 00001182 [A403]                  		dw		str_fault_0x05
  2209 00001184 [B303]                  		dw		str_fault_0x06
  2210 00001186 [C203]                  		dw		str_fault_0x07
  2211 00001188 [D203]                  		dw		str_fault_0x08
  2212 0000118A [DF03]                  		dw		str_fault_0x09
  2213 0000118C [FB03]                  		dw		str_fault_0x0A
  2214 0000118E [0704]                  		dw		str_fault_0x0B
  2215 00001190 [1B04]                  		dw		str_fault_0x0C
  2216 00001192 [2704]                  		dw		str_fault_0x0D
  2217 00001194 [4004]                  		dw		str_fault_0x0E
  2218 00001196 [4B04]                  		dw		str_fault_0x0F
  2219 00001198 [5704]                  		dw		str_fault_0x10
  2220 0000119A [6104]                  		dw		str_fault_0x11
  2221 0000119C [7104]                  		dw		str_fault_0x12
  2222 0000119E [7F04]                  		dw		str_fault_0x13
  2223                                  
  2224                                  ; VCPI PM entry
  2225                                  %macro pm_int_entry 0
  2226                                  		pusha
  2227                                  		push		ds
  2228                                  		push		es
  2229                                  		mov		ax,DATA32_SEL
  2230                                  		mov		ds,ax
  2231                                  		mov		es,ax
  2232                                  		lea		eax,[esp+4+4+32+4+4+12]	; ESP + DS + ES + PUSHA + INTNUM + ERRCODE + IRET
  2233                                  		; TODO: MOVE EAX over ESP image on stack
  2234                                  		lea		ebp,[esp]
  2235                                  %endmacro
  2236                                  %macro pm_int_exit 0
  2237                                  		pop		es
  2238                                  		pop		ds
  2239                                  		popa
  2240                                  		retf
  2241                                  %endmacro
  2242                                  
  2243                                  ; this must reside here. Any further down the jmps in the table will be out of range.
  2244                                  ; Check:
  2245                                  ;           (EFLAGS & VM) = Happend in v86 mode?
  2246                                  %macro int_entry 0
  2247                                  		pusha
  2248                                  		push		ds
  2249                                  		push		es
  2250                                  		mov		ax,DATA32_SEL
  2251                                  		mov		ds,ax
  2252                                  		mov		es,ax
  2253                                  		lea		eax,[esp+4+4+32+4+4+12]	; ESP + DS + ES + PUSHA + INTNUM + ERRCODE + IRET
  2254                                  		; TODO: MOVE EAX over ESP image on stack
  2255                                  		lea		ebp,[esp]
  2256                                  %endmacro
  2257                                  %macro int_exit 0
  2258                                  		pop		es
  2259                                  		pop		ds
  2260                                  		popa
  2261                                  		add		esp,8		; drop error code + interrupt num
  2262                                  		iret
  2263                                  %endmacro
  2264                                  %define		int_ES		word [ebp+0]
  2265                                  %define		int_DS		word [ebp+4]
  2266                                  %define		int_EDI		dword [ebp+8]
  2267                                  %define		int_ESI		dword [ebp+12]
  2268                                  %define		int_EBP		dword [ebp+16]
  2269                                  %define		int_ESP		dword [ebp+20]
  2270                                  %define		int_EBX		dword [ebp+24]
  2271                                  %define		int_EDX		dword [ebp+28]
  2272                                  %define		int_ECX		dword [ebp+32]
  2273                                  %define		int_EAX		dword [ebp+36]
  2274                                  %define		int_AX		word [ebp+36]
  2275                                  %define		int_AL		byte [ebp+36]
  2276                                  %define		int_INTNUM	dword [ebp+40]
  2277                                  %define		int_INTNUM_b	byte [ebp+40]
  2278                                  %define		int_ERRCODE	dword [ebp+44]
  2279                                  %define		int_EIP		dword [ebp+48]
  2280                                  %define		int_EIP_w	word [ebp+48]
  2281                                  %define		int_CS		word [ebp+52]
  2282                                  %define		int_EFLAGS	dword [ebp+56]
  2283                                  %define		int_FLAGS	word [ebp+56]
  2284                                  ; the following also exist if coming out of v86 mode
  2285                                  %define		int_v86_ESP	dword [ebp+60]
  2286                                  %define		int_v86_SS	word [ebp+64]
  2287                                  %define		int_v86_ES	word [ebp+68]
  2288                                  %define		int_v86_DS	word [ebp+72]
  2289                                  %define		int_v86_FS	word [ebp+76]
  2290                                  %define		int_v86_GS	word [ebp+80]
  2291                                  
  2292 000011A0 08090A0B0C0D0E0F        irq_rm_map:	db		0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F
  2293 000011A8 7071727374757677        		db		0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77
  2294                                  
  2295                                  ; return: EAX = physical memory address of vm86 SS:SP pointer
  2296                                  vm86_ss_esp_to_phys:
  2297 000011B0 31C0                    		xor		eax,eax
  2298 000011B2 668B4540                		mov		ax,int_v86_SS
  2299 000011B6 C1E004                  		shl		eax,4
  2300 000011B9 8B5D3C                  		mov		ebx,int_v86_ESP
  2301 000011BC 81E3FFFF0000            		and		ebx,0xFFFF
  2302 000011C2 01D8                    		add		eax,ebx
  2303 000011C4 C3                      		ret
  2304                                  
  2305                                  ; return: EAX = physical memory address of vm86 CS:IP pointer
  2306                                  vm86_cs_eip_to_phys:
  2307 000011C5 31C0                    		xor		eax,eax
  2308 000011C7 668B4534                		mov		ax,int_CS
  2309 000011CB C1E004                  		shl		eax,4
  2310 000011CE 8B5D30                  		mov		ebx,int_EIP
  2311 000011D1 81E3FFFF0000            		and		ebx,0xFFFF
  2312 000011D7 01D8                    		add		eax,ebx
  2313 000011D9 C3                      		ret
  2314                                  
  2315                                  ; EAX = interrupt to direct v86 mode to.
  2316                                  ; the caller must be on a stack frame formed from v86 mode to protected mode transition, or this won't work
  2317                                  vm86_push_interrupt:
  2318 000011DA 06                      		push		es
  2319 000011DB 66BB3000                		mov		bx,FLAT32_SEL
  2320 000011DF 8EC3                    		mov		es,bx
  2321 000011E1 268B0C8500000000        		mov		ecx,[es:eax*4]
  2322 000011E9 836D3C06                		sub		int_v86_ESP,6			; IRET stack frame
  2323 000011ED 722A                    		jc		.stack_overflow
  2324 000011EF E8BCFFFFFF              		call		vm86_ss_esp_to_phys
  2325 000011F4 8B5D30                  		mov		ebx,int_EIP			; save IP,CS,FLAGS to stack
  2326 000011F7 26668918                		mov		word [es:eax+0],bx
  2327 000011FB 668B5D34                		mov		bx,int_CS
  2328 000011FF 2666895802              		mov		word [es:eax+2],bx
  2329 00001204 8B5D38                  		mov		ebx,int_EFLAGS
  2330 00001207 2666895804              		mov		word [es:eax+4],bx
  2331                                  
  2332 0000120C 66894D30                		mov		int_EIP_w,cx			; load new CS:IP from interrupt vector
  2333 00001210 C1E910                  		shr		ecx,16
  2334 00001213 66894D34                		mov		int_CS,cx
  2335                                  
  2336 00001217 07                      		pop		es
  2337 00001218 C3                      		ret
  2338                                  .stack_overflow:
  2339 00001219 E854050000              		call		interrupt_routine_halt_prepare
  2340 0000121E 8B5528                  		mov		edx,int_INTNUM
  2341 00001221 BE[54050000]            		mov		esi,str_stack_overflow
  2342 00001226 E95E0A0000              		jmp		fault_jmp_unhandled
  2343                                  
  2344                                  interrupt_routine_tf: ; INT 0x01 Trap Interrupt
  2345                                  		int_entry
  2346 0000122B 60                  <1>  pusha
  2347 0000122C 1E                  <1>  push ds
  2348 0000122D 06                  <1>  push es
  2349 0000122E 66B82000            <1>  mov ax,DATA32_SEL
  2350 00001232 8ED8                <1>  mov ds,ax
  2351 00001234 8EC0                <1>  mov es,ax
  2352 00001236 8D44243C            <1>  lea eax,[esp+4+4+32+4+4+12]
  2353                              <1> 
  2354 0000123A 8D2C24              <1>  lea ebp,[esp]
  2355 0000123D F7453800000200          		test		int_EFLAGS,0x20000		; did this happen from v86 mode?
  2356 00001244 7418                    		jz		.not_vm86
  2357 00001246 B801000000              		mov		eax,1				; reflect INT 0x01 to vm86
  2358 0000124B E88AFFFFFF              		call		vm86_push_interrupt
  2359 00001250 816538FFFEFFFF          		and		int_EFLAGS,~0x100		; clear the trap flag
  2360                                  		int_exit
  2361 00001257 07                  <1>  pop es
  2362 00001258 1F                  <1>  pop ds
  2363 00001259 61                  <1>  popa
  2364 0000125A 83C408              <1>  add esp,8
  2365 0000125D CF                  <1>  iret
  2366 0000125E E80F050000              .not_vm86:	call		interrupt_routine_halt_prepare
  2367 00001263 8B5528                  		mov		edx,int_INTNUM
  2368 00001266 BE[7E050000]            		mov		esi,str_unexpected_int_not_v86
  2369 0000126B E9190A0000              		jmp		fault_jmp_unhandled
  2370                                  
  2371                                  interrupt_routine_irq:
  2372                                  		int_entry
  2373 00001270 60                  <1>  pusha
  2374 00001271 1E                  <1>  push ds
  2375 00001272 06                  <1>  push es
  2376 00001273 66B82000            <1>  mov ax,DATA32_SEL
  2377 00001277 8ED8                <1>  mov ds,ax
  2378 00001279 8EC0                <1>  mov es,ax
  2379 0000127B 8D44243C            <1>  lea eax,[esp+4+4+32+4+4+12]
  2380                              <1> 
  2381 0000127F 8D2C24              <1>  lea ebp,[esp]
  2382 00001282 F7453800000200          		test		int_EFLAGS,0x20000		; did this happen from v86 mode?
  2383 00001289 741B                    		jz		.not_vm86
  2384 0000128B 8B4528                  		mov		eax,int_INTNUM
  2385 0000128E 2DF0000000              		sub		eax,IRQ_BASE_INT
  2386 00001293 0FB680[A0110000]        		movzx		eax,byte [eax+irq_rm_map]
  2387 0000129A E83BFFFFFF              		call		vm86_push_interrupt
  2388                                  		int_exit
  2389 0000129F 07                  <1>  pop es
  2390 000012A0 1F                  <1>  pop ds
  2391 000012A1 61                  <1>  popa
  2392 000012A2 83C408              <1>  add esp,8
  2393 000012A5 CF                  <1>  iret
  2394 000012A6 E8C7040000              .not_vm86:	call		interrupt_routine_halt_prepare
  2395 000012AB 8B5528                  		mov		edx,int_INTNUM
  2396 000012AE BE[7E050000]            		mov		esi,str_unexpected_int_not_v86
  2397 000012B3 E9D1090000              		jmp		fault_jmp_unhandled
  2398                                  
  2399                                  vm86_stack_overflow:
  2400 000012B8 E8B5040000              		call		interrupt_routine_halt_prepare
  2401 000012BD 8B5528                  		mov		edx,int_INTNUM
  2402 000012C0 BE[54050000]            		mov		esi,str_stack_overflow
  2403 000012C5 E9BF090000              		jmp		fault_jmp_unhandled
  2404                                  
  2405                                  ; General Protection Fault
  2406                                  interrupt_routine_gpf:
  2407                                  		int_entry
  2408 000012CA 60                  <1>  pusha
  2409 000012CB 1E                  <1>  push ds
  2410 000012CC 06                  <1>  push es
  2411 000012CD 66B82000            <1>  mov ax,DATA32_SEL
  2412 000012D1 8ED8                <1>  mov ds,ax
  2413 000012D3 8EC0                <1>  mov es,ax
  2414 000012D5 8D44243C            <1>  lea eax,[esp+4+4+32+4+4+12]
  2415                              <1> 
  2416 000012D9 8D2C24              <1>  lea ebp,[esp]
  2417 000012DC 66B83000                		mov		ax,FLAT32_SEL
  2418 000012E0 8EC0                    		mov		es,ax
  2419 000012E2 F7453800000200          		test		int_EFLAGS,0x20000		; did this happen from v86 mode?
  2420 000012E9 0F84CE020000            		jz		.not_vm86
  2421                                  
  2422 000012EF E8D1FEFFFF              		call		vm86_cs_eip_to_phys		; else, read the opcode at CS:IP to tell between exceptions and explicit INT xxh instructions
  2423 000012F4 268B00                  		mov		eax,[es:eax]			; EAX = first 4 bytes of the opcode
  2424                                  
  2425                                  ; INT 3?
  2426 000012F7 3CCC                    		cmp		al,0xCC
  2427 000012F9 0F8497020000            		jz		.vm86_int3
  2428                                  ; INT N?
  2429 000012FF 3CCD                    		cmp		al,0xCD
  2430 00001301 0F84A3020000            		jz		.vm86_int_n
  2431                                  ; IN AL,<imm>
  2432 00001307 3CE4                    		cmp		al,0xE4
  2433 00001309 0F8488000000            		jz		.vm86_in_al_imm
  2434                                  ; IN AX,<imm>
  2435 0000130F 3CE5                    		cmp		al,0xE5
  2436 00001311 0F849B000000            		jz		.vm86_in_ax_imm
  2437                                  ; OUT <imm>,AL
  2438 00001317 3CE6                    		cmp		al,0xE6
  2439 00001319 0F84F0000000            		jz		.vm86_out_imm_al
  2440                                  ; OUT <imm>,AX
  2441 0000131F 3CE7                    		cmp		al,0xE7
  2442 00001321 0F8404010000            		jz		.vm86_out_imm_ax
  2443                                  ; IN AL,DX
  2444 00001327 3CEC                    		cmp		al,0xEC
  2445 00001329 0F849F000000            		jz		.vm86_in_al_dx
  2446                                  ; IN AX,DX
  2447 0000132F 3CED                    		cmp		al,0xED
  2448 00001331 0F84B7000000            		jz		.vm86_in_ax_dx
  2449                                  ; OUT DX,AL
  2450 00001337 3CEE                    		cmp		al,0xEE
  2451 00001339 0F840C010000            		jz		.vm86_out_dx_al
  2452                                  ; OUT DX,AX
  2453 0000133F 3CEF                    		cmp		al,0xEF
  2454 00001341 0F8425010000            		jz		.vm86_out_dx_ax
  2455                                  ; CLI?
  2456 00001347 3CFA                    		cmp		al,0xFA
  2457 00001349 0F8425020000            		jz		.vm86_cli
  2458                                  ; STI?
  2459 0000134F 3CFB                    		cmp		al,0xFB
  2460 00001351 0F842E020000            		jz		.vm86_sti
  2461                                  ; PUSHF?
  2462 00001357 3C9C                    		cmp		al,0x9C
  2463 00001359 0F8488010000            		jz		.vm86_pushf
  2464                                  ; POPF?
  2465 0000135F 3C9D                    		cmp		al,0x9D
  2466 00001361 0F84AA010000            		jz		.vm86_popf
  2467                                  ; PUSHFD?
  2468 00001367 663D669C                		cmp		ax,0x9C66
  2469 0000136B 0F8420010000            		jz		.vm86_pushfd
  2470                                  ; POPFD?
  2471 00001371 663D669D                		cmp		ax,0x9D66
  2472 00001375 0F843E010000            		jz		.vm86_popfd
  2473                                  ; IRET?
  2474 0000137B 3CCF                    		cmp		al,0xCF
  2475 0000137D 0F84B8010000            		jz		.vm86_iret
  2476                                  ; well then I don't know
  2477 00001383 E8EA030000              		call		interrupt_routine_halt_prepare
  2478 00001388 BA0D000000              		mov		edx,0xD
  2479 0000138D BE[A4040000]            		mov		esi,str_v86_unknown
  2480 00001392 E9F2080000              		jmp		fault_jmp_unhandled
  2481                                  
  2482 00001397 83453002                .vm86_in_al_imm:add		int_EIP,2			; EIP += 2
  2483 0000139B 0FB6D4                  		movzx		edx,ah				; I/O port number in second byte
  2484 0000139E B901000000              		mov		ecx,1				; ecx = size of I/O
  2485 000013A3 E8E0050000              		call		on_vm86_io_read
  2486 000013A8 884524                  		mov		int_AL,al			; eax = byte value
  2487                                  		int_exit
  2488 000013AB 07                  <1>  pop es
  2489 000013AC 1F                  <1>  pop ds
  2490 000013AD 61                  <1>  popa
  2491 000013AE 83C408              <1>  add esp,8
  2492 000013B1 CF                  <1>  iret
  2493                                  
  2494 000013B2 83453002                .vm86_in_ax_imm:add		int_EIP,2			; EIP += 2
  2495 000013B6 0FB6D4                  		movzx		edx,ah				; I/O port number in second byte
  2496 000013B9 B902000000              		mov		ecx,2				; ecx = size of I/O
  2497 000013BE E8C5050000              		call		on_vm86_io_read
  2498 000013C3 66894524                		mov		int_AX,ax			; eax = byte value
  2499                                  		int_exit
  2500 000013C7 07                  <1>  pop es
  2501 000013C8 1F                  <1>  pop ds
  2502 000013C9 61                  <1>  popa
  2503 000013CA 83C408              <1>  add esp,8
  2504 000013CD CF                  <1>  iret
  2505                                  
  2506 000013CE FF4530                  .vm86_in_al_dx:	inc		int_EIP				; EIP += 1
  2507 000013D1 8B551C                  		mov		edx,int_EDX			; edx = port number
  2508 000013D4 81E2FFFF0000            		and		edx,0xFFFF
  2509 000013DA B901000000              		mov		ecx,1				; ecx = size of I/O
  2510 000013DF E8A4050000              		call		on_vm86_io_read
  2511 000013E4 884524                  		mov		int_AL,al			; eax = byte value
  2512                                  		int_exit
  2513 000013E7 07                  <1>  pop es
  2514 000013E8 1F                  <1>  pop ds
  2515 000013E9 61                  <1>  popa
  2516 000013EA 83C408              <1>  add esp,8
  2517 000013ED CF                  <1>  iret
  2518                                  
  2519 000013EE FF4530                  .vm86_in_ax_dx:	inc		int_EIP				; EIP += 1
  2520 000013F1 8B551C                  		mov		edx,int_EDX			; edx = port number
  2521 000013F4 81E2FFFF0000            		and		edx,0xFFFF
  2522 000013FA B902000000              		mov		ecx,2				; ecx = size of I/O
  2523 000013FF E884050000              		call		on_vm86_io_read
  2524 00001404 66894524                		mov		int_AX,ax			; eax = byte value
  2525                                  		int_exit
  2526 00001408 07                  <1>  pop es
  2527 00001409 1F                  <1>  pop ds
  2528 0000140A 61                  <1>  popa
  2529 0000140B 83C408              <1>  add esp,8
  2530 0000140E CF                  <1>  iret
  2531                                  
  2532 0000140F 83453002                .vm86_out_imm_al:add		int_EIP,2			; EIP += 2
  2533 00001413 0FB6D4                  		movzx		edx,ah				; I/O port number in second byte
  2534 00001416 0FB64524                		movzx		eax,int_AL			; eax = byte value
  2535 0000141A B901000000              		mov		ecx,1				; ecx = size of I/O
  2536 0000141F E821050000              		call		on_vm86_io_write
  2537                                  		int_exit
  2538 00001424 07                  <1>  pop es
  2539 00001425 1F                  <1>  pop ds
  2540 00001426 61                  <1>  popa
  2541 00001427 83C408              <1>  add esp,8
  2542 0000142A CF                  <1>  iret
  2543                                  
  2544 0000142B 83453002                .vm86_out_imm_ax:add		int_EIP,2			; EIP += 2
  2545 0000142F 0FB6D4                  		movzx		edx,ah				; I/O port number in second byte
  2546 00001432 8B4524                  		mov		eax,int_EAX
  2547 00001435 25FFFF0000              		and		eax,0xFFFF
  2548 0000143A B902000000              		mov		ecx,2				; ecx = size of I/O
  2549 0000143F E801050000              		call		on_vm86_io_write
  2550                                  		int_exit
  2551 00001444 07                  <1>  pop es
  2552 00001445 1F                  <1>  pop ds
  2553 00001446 61                  <1>  popa
  2554 00001447 83C408              <1>  add esp,8
  2555 0000144A CF                  <1>  iret
  2556                                  
  2557 0000144B FF4530                  .vm86_out_dx_al:inc		int_EIP				; EIP += 1
  2558 0000144E 8B551C                  		mov		edx,int_EDX			; edx = port number
  2559 00001451 81E2FFFF0000            		and		edx,0xFFFF
  2560 00001457 0FB64524                		movzx		eax,int_AL			; eax = byte value
  2561 0000145B B901000000              		mov		ecx,1				; ecx = size of I/O
  2562 00001460 E8E0040000              		call		on_vm86_io_write
  2563                                  		int_exit
  2564 00001465 07                  <1>  pop es
  2565 00001466 1F                  <1>  pop ds
  2566 00001467 61                  <1>  popa
  2567 00001468 83C408              <1>  add esp,8
  2568 0000146B CF                  <1>  iret
  2569                                  
  2570 0000146C FF4530                  .vm86_out_dx_ax:inc		int_EIP				; EIP += 1
  2571 0000146F 8B551C                  		mov		edx,int_EDX			; edx = port number
  2572 00001472 81E2FFFF0000            		and		edx,0xFFFF
  2573 00001478 8B4524                  		mov		eax,int_EAX
  2574 0000147B 25FFFF0000              		and		eax,0xFFFF
  2575 00001480 B902000000              		mov		ecx,2				; ecx = size of I/O
  2576 00001485 E8BB040000              		call		on_vm86_io_write
  2577                                  		int_exit
  2578 0000148A 07                  <1>  pop es
  2579 0000148B 1F                  <1>  pop ds
  2580 0000148C 61                  <1>  popa
  2581 0000148D 83C408              <1>  add esp,8
  2582 00001490 CF                  <1>  iret
  2583                                  
  2584 00001491 06                      .vm86_pushfd:	push		es
  2585 00001492 66BB3000                		mov		bx,FLAT32_SEL
  2586 00001496 8EC3                    		mov		es,bx
  2587 00001498 836D3C04                		sub		int_v86_ESP,4			; push DWORD
  2588 0000149C 0F8216FEFFFF            		jc		vm86_stack_overflow
  2589 000014A2 E809FDFFFF              		call		vm86_ss_esp_to_phys		; EAX = SS:SP physical mem location
  2590 000014A7 8B5D38                  		mov		ebx,int_EFLAGS			; retrieve FLAGS
  2591 000014AA 268918                  		mov		[es:eax],ebx			; store on stack
  2592 000014AD 07                      		pop		es
  2593 000014AE 83453002                		add		int_EIP,2
  2594                                  		int_exit
  2595 000014B2 07                  <1>  pop es
  2596 000014B3 1F                  <1>  pop ds
  2597 000014B4 61                  <1>  popa
  2598 000014B5 83C408              <1>  add esp,8
  2599 000014B8 CF                  <1>  iret
  2600                                  
  2601 000014B9 06                      .vm86_popfd:	push		es
  2602 000014BA 66BB3000                		mov		bx,FLAT32_SEL
  2603 000014BE 8EC3                    		mov		es,bx
  2604 000014C0 E8EBFCFFFF              		call		vm86_ss_esp_to_phys		; EAX = SS:SP physical mem location
  2605 000014C5 83453C04                		add		int_v86_ESP,4			; pop DWORD
  2606 000014C9 0F82E9FDFFFF            		jc		vm86_stack_overflow
  2607 000014CF 268B18                  		mov		ebx,[es:eax]			; retrieve from stack
  2608 000014D2 81CB00000200            		or		ebx,0x20000			; don't let the guest disable virtual 8086 mode
  2609 000014D8 895D38                  		mov		int_EFLAGS,ebx			; place in FLAGS
  2610 000014DB 07                      		pop		es
  2611 000014DC 83453002                		add		int_EIP,2
  2612                                  		int_exit
  2613 000014E0 07                  <1>  pop es
  2614 000014E1 1F                  <1>  pop ds
  2615 000014E2 61                  <1>  popa
  2616 000014E3 83C408              <1>  add esp,8
  2617 000014E6 CF                  <1>  iret
  2618                                  
  2619 000014E7 06                      .vm86_pushf:	push		es
  2620 000014E8 66BB3000                		mov		bx,FLAT32_SEL
  2621 000014EC 8EC3                    		mov		es,bx
  2622 000014EE 836D3C02                		sub		int_v86_ESP,2			; push WORD
  2623 000014F2 0F82C0FDFFFF            		jc		vm86_stack_overflow
  2624 000014F8 E8B3FCFFFF              		call		vm86_ss_esp_to_phys		; EAX = SS:SP physical mem location
  2625 000014FD 668B5D38                		mov		bx,int_FLAGS			; retrieve FLAGS
  2626 00001501 26668918                		mov		[es:eax],bx			; store on stack
  2627 00001505 07                      		pop		es
  2628 00001506 83453001                		add		int_EIP,1
  2629                                  		int_exit
  2630 0000150A 07                  <1>  pop es
  2631 0000150B 1F                  <1>  pop ds
  2632 0000150C 61                  <1>  popa
  2633 0000150D 83C408              <1>  add esp,8
  2634 00001510 CF                  <1>  iret
  2635                                  
  2636 00001511 06                      .vm86_popf:	push		es
  2637 00001512 66BB3000                		mov		bx,FLAT32_SEL
  2638 00001516 8EC3                    		mov		es,bx
  2639 00001518 E893FCFFFF              		call		vm86_ss_esp_to_phys		; EAX = SS:SP physical mem location
  2640 0000151D 83453C02                		add		int_v86_ESP,2			; pop WORD
  2641 00001521 0F8291FDFFFF            		jc		vm86_stack_overflow
  2642 00001527 26668B18                		mov		bx,[es:eax]			; retrieve from stack
  2643 0000152B 66895D38                		mov		int_FLAGS,bx			; place in FLAGS
  2644 0000152F 07                      		pop		es
  2645 00001530 83453001                		add		int_EIP,1
  2646                                  		int_exit
  2647 00001534 07                  <1>  pop es
  2648 00001535 1F                  <1>  pop ds
  2649 00001536 61                  <1>  popa
  2650 00001537 83C408              <1>  add esp,8
  2651 0000153A CF                  <1>  iret
  2652                                  
  2653 0000153B 06                      .vm86_iret:	push		es
  2654 0000153C 66BB3000                		mov		bx,FLAT32_SEL
  2655 00001540 8EC3                    		mov		es,bx
  2656 00001542 E869FCFFFF              		call		vm86_ss_esp_to_phys		; EAX = SS:SP physical mem location
  2657 00001547 83453C06                		add		int_v86_ESP,6			; pop interrupt stack frame
  2658 0000154B 0F8267FDFFFF            		jc		vm86_stack_overflow
  2659 00001551 31DB                    		xor		ebx,ebx
  2660 00001553 26668B18                		mov		bx,[es:eax+0]			; EBX = IP
  2661 00001557 895D30                  		mov		int_EIP,ebx
  2662 0000155A 26668B5802              		mov		bx,[es:eax+2]			; EBX = CS
  2663 0000155F 66895D34                		mov		int_CS,bx
  2664 00001563 26668B5804              		mov		bx,[es:eax+4]			; EBX = FLAGS
  2665 00001568 66895D38                		mov		int_FLAGS,bx
  2666 0000156C 07                      		pop		es
  2667                                  		int_exit
  2668 0000156D 07                  <1>  pop es
  2669 0000156E 1F                  <1>  pop ds
  2670 0000156F 61                  <1>  popa
  2671 00001570 83C408              <1>  add esp,8
  2672 00001573 CF                  <1>  iret
  2673                                  
  2674 00001574 816538FFFDFFFF          .vm86_cli:	and		int_EFLAGS,~0x200		; IF=0
  2675 0000157B FF4530                  		inc		int_EIP
  2676                                  		int_exit
  2677 0000157E 07                  <1>  pop es
  2678 0000157F 1F                  <1>  pop ds
  2679 00001580 61                  <1>  popa
  2680 00001581 83C408              <1>  add esp,8
  2681 00001584 CF                  <1>  iret
  2682                                  
  2683 00001585 814D3800020000          .vm86_sti:	or		int_EFLAGS,0x200		; IF=1
  2684 0000158C FF4530                  		inc		int_EIP
  2685                                  		int_exit
  2686 0000158F 07                  <1>  pop es
  2687 00001590 1F                  <1>  pop ds
  2688 00001591 61                  <1>  popa
  2689 00001592 83C408              <1>  add esp,8
  2690 00001595 CF                  <1>  iret
  2691                                  
  2692 00001596 FF4530                  .vm86_int3:	inc		int_EIP				; EIP++
  2693 00001599 B803000000              		mov		eax,3
  2694 0000159E E837FCFFFF              		call		vm86_push_interrupt
  2695                                  		int_exit
  2696 000015A3 07                  <1>  pop es
  2697 000015A4 1F                  <1>  pop ds
  2698 000015A5 61                  <1>  popa
  2699 000015A6 83C408              <1>  add esp,8
  2700 000015A9 CF                  <1>  iret
  2701                                  
  2702 000015AA 0FB6C4                  .vm86_int_n:	movzx		eax,ah				; AL=CD AH=intnum
  2703 000015AD 83453002                		add		int_EIP,2			; EIP += 2
  2704 000015B1 E824FCFFFF              		call		vm86_push_interrupt
  2705                                  		int_exit
  2706 000015B6 07                  <1>  pop es
  2707 000015B7 1F                  <1>  pop ds
  2708 000015B8 61                  <1>  popa
  2709 000015B9 83C408              <1>  add esp,8
  2710 000015BC CF                  <1>  iret
  2711                                  
  2712 000015BD E8B0010000              .not_vm86:	call		interrupt_routine_halt_prepare
  2713 000015C2 E890010000              		call		edx_esi_default_int_str
  2714 000015C7 E9BD060000              		jmp		fault_jmp_unhandled
  2715                                  
  2716                                  interrupt_routine:
  2717                                  		int_entry
  2718 000015CC 60                  <1>  pusha
  2719 000015CD 1E                  <1>  push ds
  2720 000015CE 06                  <1>  push es
  2721 000015CF 66B82000            <1>  mov ax,DATA32_SEL
  2722 000015D3 8ED8                <1>  mov ds,ax
  2723 000015D5 8EC0                <1>  mov es,ax
  2724 000015D7 8D44243C            <1>  lea eax,[esp+4+4+32+4+4+12]
  2725                              <1> 
  2726 000015DB 8D2C24              <1>  lea ebp,[esp]
  2727 000015DE 66B83000                		mov		ax,FLAT32_SEL
  2728 000015E2 8EC0                    		mov		es,ax
  2729 000015E4 817D28EF000000          		cmp		int_INTNUM,RM_INT_API		; interrupts sent to our RM_INT_API are handled directly
  2730 000015EB 0F84F7000000            		jz		.rm_int_api
  2731 000015F1 F7453800000200          		test		int_EFLAGS,0x20000		; did this happen from v86 mode?
  2732 000015F8 0F84DB000000            		jz		.not_vm86
  2733                                  
  2734                                  ; okay then, there are several reasons such interrupts fire.
  2735 000015FE 8A4528                  		mov		al,int_INTNUM_b
  2736                                  ; INT 15H interception
  2737 00001601 3C15                    		cmp		al,0x15
  2738 00001603 7460                    		jz		.vm86_int15
  2739                                  ; Anything int >= 0x14 on
  2740 00001605 3C14                    		cmp		al,0x14
  2741 00001607 734D                    		jae		.vm86_intN
  2742                                  ; INT 0x03 debug interrupt FIXME is this needed?
  2743 00001609 3C03                    		cmp		al,0x03
  2744 0000160B 7438                    		jz		.vm86_int3
  2745                                  ; INT 0x01 debug trap FIXME is this needed?
  2746 0000160D 3C01                    		cmp		al,0x01
  2747 0000160F 741C                    		jz		.vm86_int1
  2748                                  ; INT 0x07 COPROCESSOR NOT PRESENT (vm86 task used a floating point instruction)
  2749 00001611 3C07                    		cmp		al,0x07
  2750 00001613 740F                    		jz		.fpu_7
  2751                                  
  2752 00001615 E858010000              		call		interrupt_routine_halt_prepare
  2753 0000161A E838010000              		call		edx_esi_default_int_str
  2754 0000161F E965060000              		jmp		fault_jmp_unhandled
  2755                                  
  2756                                  ; COPROCESSOR NOT PRESENT. USUALLY SIGNALLED AFTER TASK SWITCH ON FIRST FPU INSTRUCTION.
  2757 00001624 0F06                    .fpu_7:		clts
  2758                                  		int_exit
  2759 00001626 07                  <1>  pop es
  2760 00001627 1F                  <1>  pop ds
  2761 00001628 61                  <1>  popa
  2762 00001629 83C408              <1>  add esp,8
  2763 0000162C CF                  <1>  iret
  2764                                  
  2765 0000162D B801000000              .vm86_int1:	mov		eax,1
  2766 00001632 E8A3FBFFFF              		call		vm86_push_interrupt
  2767 00001637 816538FFFEFFFF          		and		int_EFLAGS,~0x100		; clear trap flag
  2768                                  		int_exit
  2769 0000163E 07                  <1>  pop es
  2770 0000163F 1F                  <1>  pop ds
  2771 00001640 61                  <1>  popa
  2772 00001641 83C408              <1>  add esp,8
  2773 00001644 CF                  <1>  iret
  2774                                  
  2775 00001645 B803000000              .vm86_int3:	mov		eax,3
  2776 0000164A E88BFBFFFF              		call		vm86_push_interrupt
  2777                                  		int_exit
  2778 0000164F 07                  <1>  pop es
  2779 00001650 1F                  <1>  pop ds
  2780 00001651 61                  <1>  popa
  2781 00001652 83C408              <1>  add esp,8
  2782 00001655 CF                  <1>  iret
  2783                                  
  2784 00001656 8B4528                  .vm86_intN:	mov		eax,int_INTNUM
  2785 00001659 E87CFBFFFF              		call		vm86_push_interrupt
  2786                                  		int_exit
  2787 0000165E 07                  <1>  pop es
  2788 0000165F 1F                  <1>  pop ds
  2789 00001660 61                  <1>  popa
  2790 00001661 83C408              <1>  add esp,8
  2791 00001664 CF                  <1>  iret
  2792                                  
  2793                                  ; INT 15h; we must intercept AH=87h for extended memory programs to work properly within our VM86 environment
  2794 00001665 8B5D24                  .vm86_int15:	mov		ebx,int_EAX
  2795 00001668 80FF87                  		cmp		bh,0x87
  2796 0000166B 740F                    		jz		.vm86_int15_87
  2797                                  ; carry it forward to the BIOS
  2798 0000166D 8B4528                  		mov		eax,int_INTNUM
  2799 00001670 E865FBFFFF              		call		vm86_push_interrupt
  2800                                  		int_exit
  2801 00001675 07                  <1>  pop es
  2802 00001676 1F                  <1>  pop ds
  2803 00001677 61                  <1>  popa
  2804 00001678 83C408              <1>  add esp,8
  2805 0000167B CF                  <1>  iret
  2806                                  
  2807                                  ; INT 15H AH=87h
  2808 0000167C 31C0                    .vm86_int15_87:	xor		eax,eax
  2809 0000167E 668B4544                		mov		ax,int_v86_ES
  2810 00001682 C1E004                  		shl		eax,4
  2811 00001685 81650CFFFF0000          		and		int_ESI,0xFFFF
  2812 0000168C 03450C                  		add		eax,int_ESI
  2813 0000168F 8B4D20                  		mov		ecx,int_ECX
  2814 00001692 81E1FFFF0000            		and		ecx,0xFFFF
  2815                                  ; ECX = count of WORDs, EAX = physical memory addr of GDT
  2816 00001698 268B7012                		mov		esi,[es:eax+0x10+2]
  2817 0000169C 81E6FFFFFF00            		and		esi,0xFFFFFF
  2818 000016A2 268B781A                		mov		edi,[es:eax+0x18+2]
  2819 000016A6 81E7FFFFFF00            		and		edi,0xFFFFFF
  2820                                  ; ESI = physical memory addr (src), EDI = physical memory addr (dst)
  2821 000016AC 260FB65817              		movzx		ebx,byte [es:eax+0x10+7]
  2822 000016B1 C1E318                  		shl		ebx,24
  2823 000016B4 09DE                    		or		esi,ebx
  2824 000016B6 260FB6581F              		movzx		ebx,byte [es:eax+0x18+7]
  2825 000016BB C1E318                  		shl		ebx,24
  2826 000016BE 09DF                    		or		edi,ebx
  2827                                  ; carry out the actual copy
  2828 000016C0 1E                      		push		ds
  2829 000016C1 668CC0                  		mov		ax,es
  2830 000016C4 8ED8                    		mov		ds,ax
  2831 000016C6 FC                      		cld
  2832 000016C7 F366A5                  		rep		movsw
  2833 000016CA 1F                      		pop		ds
  2834                                  ; signal success
  2835 000016CB C7452400000000          		mov		int_EAX,0
  2836                                  		int_exit
  2837 000016D2 07                  <1>  pop es
  2838 000016D3 1F                  <1>  pop ds
  2839 000016D4 61                  <1>  popa
  2840 000016D5 83C408              <1>  add esp,8
  2841 000016D8 CF                  <1>  iret
  2842                                  
  2843 000016D9 E894000000              .not_vm86:	call		interrupt_routine_halt_prepare
  2844 000016DE E874000000              		call		edx_esi_default_int_str
  2845 000016E3 E9A1050000              		jmp		fault_jmp_unhandled
  2846 000016E8 8B4524                  .rm_int_api:	mov		eax,int_EAX
  2847 000016EB 3DBBAABBAA              		cmp		eax,0xAABBAABB			; command to unload
  2848 000016F0 7419                    		jz		.rm_int_api_unload
  2849 000016F2 3D55AABBAA              		cmp		eax,0xAABBAA55			; detection
  2850 000016F7 7450                    		jz		.rm_int_api_detect
  2851                                  ; unknown command
  2852 000016F9 894524                  		mov		int_EAX,eax
  2853 000016FC E871000000              		call		interrupt_routine_halt_prepare
  2854 00001701 E851000000              		call		edx_esi_default_int_str
  2855 00001706 E97E050000              		jmp		fault_jmp_unhandled
  2856                                  .rm_int_api_unload:
  2857 0000170B 8B453C                  		mov		eax,int_v86_ESP
  2858 0000170E 66A3[E6280000]          		mov		[unload_int_stk+0],ax
  2859 00001714 668B4540                		mov		ax,int_v86_SS
  2860 00001718 66A3[E8280000]          		mov		[unload_int_stk+2],ax
  2861                                  
  2862 0000171E 8B4530                  		mov		eax,int_EIP
  2863 00001721 66A3[E2280000]          		mov		[unload_int_ret+0],ax
  2864 00001727 668B4534                		mov		ax,int_CS
  2865 0000172B 66A3[E4280000]          		mov		[unload_int_ret+2],ax
  2866                                  
  2867 00001731 66B82000                		mov		ax,DATA32_SEL
  2868 00001735 8ED8                    		mov		ds,ax
  2869 00001737 8EC0                    		mov		es,ax
  2870 00001739 8EE0                    		mov		fs,ax
  2871 0000173B 8EE8                    		mov		gs,ax
  2872 0000173D BC[00100000]            		mov		esp,stack_init
  2873 00001742 EA[9F1C0000]1800        		jmp		CODE32_SEL:_exit_from_prot32
  2874                                  .rm_int_api_detect:
  2875 00001749 C7452433BBAABB          		mov		int_EAX,0xBBAABB33
  2876                                  		int_exit
  2877 00001750 07                  <1>  pop es
  2878 00001751 1F                  <1>  pop ds
  2879 00001752 61                  <1>  popa
  2880 00001753 83C408              <1>  add esp,8
  2881 00001756 CF                  <1>  iret
  2882                                  edx_esi_default_int_str:
  2883 00001757 8B5528                  		mov		edx,int_INTNUM
  2884 0000175A 83FA13                  		cmp		edx,0x13
  2885 0000175D 7E05                    		jle		.l1
  2886 0000175F BA13000000              		mov		edx,0x13
  2887 00001764 31F6                    .l1:		xor		esi,esi
  2888 00001766 668BB412[78110000]      		mov		si,word [(edx*2)+interrupt_0x00_strs]
  2889 0000176E 8B5528                  		mov		edx,int_INTNUM
  2890 00001771 C3                      		ret
  2891                                  interrupt_routine_halt_prepare: ; <====== SET ESI = address of string to print. Trashes EAX.
  2892 00001772 31C0                    		xor		eax,eax
  2893 00001774 A3[3A290000]            		mov		dword [unhandled_fault_var_opcode],eax
  2894 00001779 8B4524                  		mov		eax,int_EAX
  2895 0000177C A3[FA280000]            		mov		dword [unhandled_fault_var_eax],eax
  2896 00001781 8B4518                  		mov		eax,int_EBX
  2897 00001784 A3[FE280000]            		mov		dword [unhandled_fault_var_ebx],eax
  2898 00001789 8B4520                  		mov		eax,int_ECX
  2899 0000178C A3[02290000]            		mov		dword [unhandled_fault_var_ecx],eax
  2900 00001791 8B451C                  		mov		eax,int_EDX
  2901 00001794 A3[06290000]            		mov		dword [unhandled_fault_var_edx],eax
  2902 00001799 8B450C                  		mov		eax,int_ESI
  2903 0000179C A3[0A290000]            		mov		dword [unhandled_fault_var_esi],eax
  2904 000017A1 8B4508                  		mov		eax,int_EDI
  2905 000017A4 A3[0E290000]            		mov		dword [unhandled_fault_var_edi],eax
  2906 000017A9 8B4510                  		mov		eax,int_EBP
  2907 000017AC A3[12290000]            		mov		dword [unhandled_fault_var_ebp],eax
  2908 000017B1 8B4514                  		mov		eax,int_ESP
  2909 000017B4 A3[16290000]            		mov		dword [unhandled_fault_var_esp],eax
  2910 000017B9 8B4530                  		mov		eax,int_EIP
  2911 000017BC A3[1A290000]            		mov		dword [unhandled_fault_var_eip],eax
  2912 000017C1 8B452C                  		mov		eax,int_ERRCODE
  2913 000017C4 A3[F6280000]            		mov		dword [unhandled_fault_var_errcode],eax
  2914 000017C9 31C0                    		xor		eax,eax
  2915 000017CB 668B4500                		mov		ax,int_ES
  2916 000017CF 66A3[32290000]          		mov		word [unhandled_fault_var_es],ax
  2917 000017D5 668B4504                		mov		ax,int_DS
  2918 000017D9 66A3[30290000]          		mov		word [unhandled_fault_var_ds],ax
  2919 000017DF 668B4534                		mov		ax,int_CS
  2920 000017E3 66A3[2E290000]          		mov		word [unhandled_fault_var_cs],ax
  2921 000017E9 668CE0                  		mov		ax,fs
  2922 000017EC 66A3[34290000]          		mov		word [unhandled_fault_var_fs],ax
  2923 000017F2 668CE8                  		mov		ax,gs
  2924 000017F5 66A3[36290000]          		mov		word [unhandled_fault_var_gs],ax
  2925 000017FB 668CD0                  		mov		ax,ss
  2926 000017FE 66A3[38290000]          		mov		word [unhandled_fault_var_ss],ax
  2927 00001804 0F20C0                  		mov		eax,cr0
  2928 00001807 A3[22290000]            		mov		dword [unhandled_fault_var_cr0],eax
  2929 0000180C 0F20D8                  		mov		eax,cr3
  2930 0000180F A3[26290000]            		mov		dword [unhandled_fault_var_cr3],eax
  2931 00001814 0F20E0                  		mov		eax,cr4
  2932 00001817 A3[2A290000]            		mov		dword [unhandled_fault_var_cr4],eax
  2933 0000181C 8B4538                  		mov		eax,int_EFLAGS
  2934 0000181F A3[1E290000]            		mov		dword [unhandled_fault_var_eflags],eax
  2935 00001824 A900000200              		test		eax,0x20000		; was the VM flag set in EFLAGS when it happened?
  2936 00001829 7511                    		jnz		.v86_mode
  2937 0000182B 66F745340300            		test		int_CS,3		; did we come from ring 1/2/3?
  2938 00001831 7408                    		jz		.no_escalation
  2939                                  ; ESP needs to reflect it's contents prior to jumping to ring 0
  2940 00001833 8B453C                  		mov		eax,int_v86_ESP
  2941 00001836 A3[16290000]            		mov		dword [unhandled_fault_var_esp],eax
  2942 0000183B C3                      .no_escalation:	ret
  2943                                  ; the segment registers need to reflect what they were in vm86 mode
  2944 0000183C 31C0                    .v86_mode:	xor		eax,eax
  2945 0000183E 668B4544                		mov		ax,int_v86_ES
  2946 00001842 66A3[32290000]          		mov		word [unhandled_fault_var_es],ax
  2947 00001848 668B4548                		mov		ax,int_v86_DS
  2948 0000184C 66A3[30290000]          		mov		word [unhandled_fault_var_ds],ax
  2949 00001852 668B454C                		mov		ax,int_v86_FS
  2950 00001856 66A3[34290000]          		mov		word [unhandled_fault_var_fs],ax
  2951 0000185C 668B4550                		mov		ax,int_v86_GS
  2952 00001860 66A3[36290000]          		mov		word [unhandled_fault_var_gs],ax
  2953 00001866 668B4540                		mov		ax,int_v86_SS
  2954 0000186A 66A3[38290000]          		mov		word [unhandled_fault_var_ss],ax
  2955 00001870 8B453C                  		mov		eax,int_v86_ESP
  2956 00001873 A3[16290000]            		mov		dword [unhandled_fault_var_esp],eax
  2957                                  ; we also might want to know what opcodes were involved
  2958 00001878 06                      		push		es
  2959 00001879 66B83000                		mov		ax,FLAT32_SEL
  2960 0000187D E843F9FFFF              		call		vm86_cs_eip_to_phys
  2961 00001882 268B18                  		mov		ebx,[es:eax]
  2962 00001885 891D[3A290000]          		mov		dword [unhandled_fault_var_opcode],ebx
  2963 0000188B 07                      		pop		es
  2964 0000188C C3                      		ret
  2965                                  
  2966                                  ; ================ INT 67h EMM/VCPI entry point
  2967                                  ; TODO: At some point this code needs to be written to a) reflect the INT 67H call back to v86 mode if it's not EMM/VCPI functions
  2968                                  ;       and b) chain to v86 mode if the return address CS:IP is not the real-mode INT 67H handler we installed (so that other
  2969                                  ;       programs can hook the interrupt on top of us)
  2970                                  interrupt_routine_emm:
  2971                                  		int_entry
  2972 0000188D 60                  <1>  pusha
  2973 0000188E 1E                  <1>  push ds
  2974 0000188F 06                  <1>  push es
  2975 00001890 66B82000            <1>  mov ax,DATA32_SEL
  2976 00001894 8ED8                <1>  mov ds,ax
  2977 00001896 8EC0                <1>  mov es,ax
  2978 00001898 8D44243C            <1>  lea eax,[esp+4+4+32+4+4+12]
  2979                              <1> 
  2980 0000189C 8D2C24              <1>  lea ebp,[esp]
  2981 0000189F 8B4524                  		mov		eax,int_EAX
  2982 000018A2 80FCDE                  		cmp		ah,0DEh
  2983 000018A5 7415                    		jz		.vcpi
  2984 000018A7 80FC40                  		cmp		ah,040h
  2985 000018AA 7C0E                    		jl		.pass
  2986 000018AC 80FC5E                  		cmp		ah,05Eh
  2987 000018AF 7309                    		jae		.pass
  2988 000018B1 EB18                    		jmp		.emm
  2989                                  		int_exit
  2990 000018B3 07                  <1>  pop es
  2991 000018B4 1F                  <1>  pop ds
  2992 000018B5 61                  <1>  popa
  2993 000018B6 83C408              <1>  add esp,8
  2994 000018B9 CF                  <1>  iret
  2995 000018BA EB1D                    .pass:		jmp		emm_unhandled
  2996                                  ; VCPI processing (AH=0xDE)
  2997 000018BC 3C0C                    .vcpi:		cmp		al,0x0C
  2998 000018BE 7719                    		ja		emm_unhandled
  2999 000018C0 0FB6C0                  		movzx		eax,al
  3000 000018C3 66FFA400[ED180000]      		jmp		word [vcpi_functions+(eax*2)]
  3001                                  ; EMM processing (AH=0x40...0x5D)
  3002 000018CB 80EC40                  .emm:		sub		ah,0x40
  3003 000018CE 0FB6C4                  		movzx		eax,ah
  3004 000018D1 66FFA400[07190000]      		jmp		word [emm_functions+(eax*2)]
  3005                                  
  3006                                  emm_unhandled:
  3007                                  vcpi_unhandled:
  3008 000018D9 E894FEFFFF              		call		interrupt_routine_halt_prepare
  3009 000018DE BA67000000              		mov		edx,67h
  3010 000018E3 BE[A2050000]            		mov		esi,str_unknown_emm_vcpi_call
  3011 000018E8 E99C030000              		jmp		fault_jmp_unhandled
  3012                                  
  3013                                  ; VCPI call table
  3014 000018ED [D119]                  vcpi_functions:	dw		vcpi00_detect			; 0x00
  3015 000018EF [E619]                  		dw		vcpi01_get_pm_if		; 0x01
  3016 000018F1 [D918]                  		dw		vcpi_unhandled			; 0x02
  3017 000018F3 [531A]                  		dw		vcpi03_free_pages		; 0x03
  3018 000018F5 [681A]                  		dw		vcpi04_alloc_page		; 0x04
  3019 000018F7 [E71A]                  		dw		vcpi05_free_page		; 0x05
  3020 000018F9 [3A1B]                  		dw		vcpi06_get_phys_addr		; 0x06
  3021 000018FB [D918]                  		dw		vcpi_unhandled			; 0x07
  3022 000018FD [D918]                  		dw		vcpi_unhandled			; 0x08
  3023 000018FF [D918]                  		dw		vcpi_unhandled			; 0x09
  3024 00001901 [561B]                  		dw		vcpi0A_8259A_mapping		; 0x0A
  3025 00001903 [D918]                  		dw		vcpi_unhandled			; 0x0B
  3026 00001905 [721B]                  		dw		vcpi0C_enter_pm			; 0x0C
  3027                                  
  3028                                  ; emm call table
  3029 00001907 [861B]                  emm_functions:	dw		emm40_get_status		; 0x40
  3030 00001909 [941B]                  		dw		emm41_get_pfa			; 0x41
  3031 0000190B [A91B]                  		dw		emm42_get_unalloc_page_count	; 0x42
  3032 0000190D [C51B]                  		dw		emm43_alloc_pages		; 0x43
  3033 0000190F [DA1B]                  		dw		emm44_map_handle_page		; 0x44
  3034 00001911 [E81B]                  		dw		emm45_dealloc_pages		; 0x45
  3035 00001913 [F61B]                  		dw		emm46_get_version		; 0x46
  3036 00001915 [041C]                  		dw		emm47_save_page_map		; 0x47
  3037 00001917 [091C]                  		dw		emm48_restore_page_map		; 0x48
  3038 00001919 [D918]                  		dw		emm_unhandled			; 0x49
  3039 0000191B [D918]                  		dw		emm_unhandled			; 0x4A
  3040 0000191D [0E1C]                  		dw		emm4B_get_handle_count		; 0x4B
  3041 0000191F [131C]                  		dw		emm4C_get_handle_pages		; 0x4C
  3042 00001921 [181C]                  		dw		emm4D_get_all_handle_pages	; 0x4D
  3043 00001923 [1D1C]                  		dw		emm4E_combo			; 0x4E
  3044 00001925 [221C]                  		dw		emm4F_combo			; 0x4F
  3045 00001927 [271C]                  		dw		emm50_combo			; 0x50
  3046 00001929 [2C1C]                  		dw		emm51_realloc_pages		; 0x51
  3047 0000192B [311C]                  		dw		emm52_combo			; 0x52
  3048 0000192D [361C]                  		dw		emm53_combo			; 0x53
  3049 0000192F [3B1C]                  		dw		emm54_combo			; 0x54
  3050 00001931 [401C]                  		dw		emm55_combo			; 0x55
  3051 00001933 [451C]                  		dw		emm56_combo			; 0x56
  3052 00001935 [4A1C]                  		dw		emm57_combo			; 0x57
  3053 00001937 [4F1C]                  		dw		emm58_combo			; 0x58
  3054 00001939 [701C]                  		dw		emm59_combo			; 0x59
  3055 0000193B [751C]                  		dw		emm5A_combo			; 0x5A
  3056 0000193D [7A1C]                  		dw		emm5B_combo			; 0x5B
  3057 0000193F [7F1C]                  		dw		emm5C_prepare_warmboot		; 0x5C
  3058 00001941 [841C]                  		dw		emm5D_combo			; 0x5D
  3059                                  
  3060                                  ; 8042 trapping state
  3061 00001943 00                      trap_8042_mode			db		0x00
  3062                                  ; port 92 trapping
  3063 00001944 02                      fake_port_92			db		0x02		; the reason we save this is some programs insist on
  3064                                  								; reading back to check. if we forced bits the program
  3065                                  								; will get stuck in a loop.
  3066                                  
  3067                                  ; VCPI I/O write
  3068                                  ; in: EDX=port number EAX/AX/AL=byte value to write  ECX=I/O size
  3069                                  ; out: EAX/AX/AL=byte value to return
  3070 00001945 83FA64                  on_vm86_io_write:		cmp		edx,0x64
  3071 00001948 7409                    				jz		.write_8042_controller
  3072 0000194A 81FA92000000            				cmp		edx,0x92
  3073 00001950 742A                    				jz		.write_port_A_92h
  3074 00001952 C3                      .unknown_port:			ret		; IGNORE
  3075 00001953 803D[43190000]D1        .write_8042_controller:		cmp		byte [trap_8042_mode],0xD1		; trap Write Output Port bitfield
  3076 0000195A 740B                    				jz		.write_8042_controller_out
  3077                                  ; now match the command directly
  3078 0000195C 3CF0                    				cmp		al,0xF0					; trap attempts to pulse output bits
  3079 0000195E 7313                    				jae		.write_8042_controller_outpulse
  3080 00001960 3CD1                    				cmp		al,0xD1					; trap Write Output Port
  3081 00001962 7410                    				jz		.write_8042_controller_out_and_latch
  3082                                  ; command is OK, pass it through
  3083 00001964 E664                    				out		0x64,al
  3084 00001966 C3                      				ret
  3085                                  ; the previous byte was the Write Output command, so the next byte is the actual bits to write. We must ensure A20 is on.
  3086 00001967 0C02                    .write_8042_controller_out:	or		al,0x02		; ensure bit 1 (A20 gate) is always on
  3087 00001969 E664                    				out		0x64,al
  3088 0000196B C605[43190000]00        				mov		byte [trap_8042_mode],0x00
  3089 00001972 C3                      				ret
  3090                                  ; the program attempted to pulse output bits. silently ignore.
  3091 00001973 C3                      .write_8042_controller_outpulse:ret
  3092                                  ; the program sent us a command that we pass through, but we must modify the data byte as it passes
  3093                                  .write_8042_controller_out_and_latch:
  3094 00001974 A2[43190000]            				mov		byte [trap_8042_mode],al
  3095 00001979 E664                    				out		0x64,al		; then pass the command through
  3096 0000197B C3                      				ret
  3097                                  ; the program is writing port 0x92 to try and fiddle with A20
  3098 0000197C A2[44190000]            .write_port_A_92h:		mov		byte [fake_port_92],al ; store what the program wrote
  3099 00001981 0C02                    				or		al,2		; make sure A20 gate is on
  3100 00001983 24FE                    				and		al,0xFE		; don't let them reset CPU
  3101 00001985 E692                    				out		0x92,al		; then let it through
  3102 00001987 C3                      				ret
  3103                                  
  3104                                  ; VCPI I/O read
  3105                                  ; in: EDX=port number ECX=I/O size
  3106                                  ; out: EAX/AX/AL=byte value to return
  3107 00001988 83FA64                  on_vm86_io_read:		cmp		edx,0x64
  3108 0000198B 740C                    				jz		.read_8042_controller
  3109 0000198D 81FA92000000            				cmp		edx,0x92
  3110 00001993 740A                    				jz		.read_port_A_92h
  3111 00001995 31C0                    .unknown_port:			xor		eax,eax		; return 0xFF
  3112 00001997 48                      				dec		eax
  3113 00001998 C3                      				ret
  3114 00001999 E464                    .read_8042_controller:		in		al,0x64		; let it through
  3115 0000199B 0FB6C0                  				movzx		eax,al
  3116 0000199E C3                      				ret
  3117 0000199F 0FB605[44190000]        .read_port_A_92h:		movzx		eax,byte [fake_port_92]	; return last written value
  3118 000019A6 C3                      				ret
  3119                                  
  3120                                  ; VCPI protected mode entry (32-bit)
  3121                                  vcpi_pm_entry:			pm_int_entry
  3122                              <1> vcpi_pm_entry: 
  3123 000019A7 60                  <1>  pusha
  3124 000019A8 1E                  <1>  push ds
  3125 000019A9 06                  <1>  push es
  3126 000019AA 66B82000            <1>  mov ax,DATA32_SEL
  3127 000019AE 8ED8                <1>  mov ds,ax
  3128 000019B0 8EC0                <1>  mov es,ax
  3129 000019B2 8D44243C            <1>  lea eax,[esp+4+4+32+4+4+12]
  3130                              <1> 
  3131 000019B6 8D2C24              <1>  lea ebp,[esp]
  3132 000019B9 E8B4FDFFFF              				call		interrupt_routine_halt_prepare
  3133 000019BE BA67000000              				mov		edx,67h
  3134 000019C3 BE[B8050000]            				mov		esi,str_unknown_emm_vcpi_pm_call
  3135 000019C8 E9BC020000              				jmp		fault_jmp_unhandled			
  3136                                  				pm_int_exit
  3137 000019CD 07                  <1>  pop es
  3138 000019CE 1F                  <1>  pop ds
  3139 000019CF 61                  <1>  popa
  3140 000019D0 CB                  <1>  retf
  3141                                  
  3142                                  ; AX=0xDE00 VCPI detect
  3143 000019D1 C7452400000000          vcpi00_detect:			mov		int_EAX,0	; present
  3144 000019D8 C7451800010000          				mov		int_EBX,0x0100	; version v1.0
  3145                                  				int_exit
  3146 000019DF 07                  <1>  pop es
  3147 000019E0 1F                  <1>  pop ds
  3148 000019E1 61                  <1>  popa
  3149 000019E2 83C408              <1>  add esp,8
  3150 000019E5 CF                  <1>  iret
  3151                                  
  3152                                  ; AX=0xDE01 VCPI get protected mode interface
  3153 000019E6 66B83000                vcpi01_get_pm_if:		mov		ax,FLAT32_SEL
  3154 000019EA 8EC0                    				mov		es,ax
  3155                                  ; fill page table ES:DI and advance DI += 4096 on return to client
  3156 000019EC 31FF                    				xor		edi,edi
  3157 000019EE 668B7D44                				mov		di,int_v86_ES
  3158 000019F2 C1E704                  				shl		edi,4
  3159 000019F5 037D08                  				add		edi,int_EDI			; EDI = (ES<<4)+DI
  3160 000019F8 81450800100000          				add		int_EDI,4096			; client (E)DI += 4
  3161                                  ; make fake page table for first 4MB that is 1:1 identity mapping
  3162 000019FF B900040000              				mov		ecx,4096>>2
  3163 00001A04 31DB                    				xor		ebx,ebx
  3164 00001A06 FC                      				cld
  3165 00001A07 8D4307                  .pmfill:			lea		eax,[ebx+0x007]			; EAX = PTE: base address + present + read/write, user
  3166 00001A0A 81C300100000            				add		ebx,0x1000
  3167 00001A10 AB                      				stosd
  3168 00001A11 E2F4                    				loop		.pmfill
  3169                                  
  3170                                  ; then fill in the GDT table given by the client
  3171 00001A13 FC                      				cld
  3172 00001A14 31FF                    				xor		edi,edi
  3173 00001A16 668B7D48                				mov		di,int_v86_DS
  3174 00001A1A C1E704                  				shl		edi,4
  3175 00001A1D 037D0C                  				add		edi,int_ESI			; EDI = (DS<<4)+SI
  3176                                  				; CODE
  3177 00001A20 8D35[A8200000]          				lea		esi,[gdt+(CODE32_SEL&0xFFF8)]	; ESI = our code32 GDT
  3178 00001A26 AD                      				lodsd						; ****COPY****
  3179 00001A27 AB                      				stosd
  3180 00001A28 AD                      				lodsd
  3181 00001A29 AB                      				stosd
  3182                                  				; DATA (not that it matters)
  3183 00001A2A 8D35[B0200000]          				lea		esi,[gdt+(DATA32_SEL&0xFFF8)]	; ESI = our data32 GDT
  3184 00001A30 AD                      				lodsd						; ****COPY****
  3185 00001A31 AB                      				stosd
  3186 00001A32 AD                      				lodsd
  3187 00001A33 AB                      				stosd
  3188                                  				; DATA (not that it matters)
  3189 00001A34 8D35[C0200000]          				lea		esi,[gdt+(FLAT32_SEL&0xFFF8)]	; ESI = our data32 GDT
  3190 00001A3A AD                      				lodsd						; ****COPY****
  3191 00001A3B AB                      				stosd
  3192 00001A3C AD                      				lodsd
  3193 00001A3D AB                      				stosd
  3194                                  
  3195 00001A3E C7452400000000          				mov		int_EAX,0			; OK, no error
  3196 00001A45 C74518[A7190000]        				mov		int_EBX,vcpi_pm_entry		; our VCPI entry point
  3197                                  				int_exit
  3198 00001A4C 07                  <1>  pop es
  3199 00001A4D 1F                  <1>  pop ds
  3200 00001A4E 61                  <1>  popa
  3201 00001A4F 83C408              <1>  add esp,8
  3202 00001A52 CF                  <1>  iret
  3203                                  
  3204                                  ; AX=0xDE03 VCPI get free pages:
  3205 00001A53 C7452400000000          vcpi03_free_pages:		mov		int_EAX,0	; OK
  3206 00001A5A C7451C00040000          				mov		int_EDX,(4*1024*1024)/4096	; just report 4MB and be done with it
  3207                                  				int_exit
  3208 00001A61 07                  <1>  pop es
  3209 00001A62 1F                  <1>  pop ds
  3210 00001A63 61                  <1>  popa
  3211 00001A64 83C408              <1>  add esp,8
  3212 00001A67 CF                  <1>  iret
  3213                                  
  3214                                  ; AX=0xDE04 VCPI alloc page:
  3215 00001A68 66B83000                vcpi04_alloc_page:		mov		ax,FLAT32_SEL
  3216 00001A6C 8EC0                    				mov		es,ax
  3217 00001A6E 8B35[EA280000]          				mov		esi,[vcpi_alloc_bitmap_phys]
  3218 00001A74 8B0D[EE280000]          				mov		ecx,[vcpi_alloc_bitmap_size]
  3219 00001A7A FC                      				cld
  3220 00001A7B 268A06                  .scan:				mov		al,byte [es:esi]
  3221 00001A7E 3CFF                    				cmp		al,0xFF
  3222 00001A80 7519                    				jnz		.found
  3223 00001A82 46                      				inc		esi
  3224 00001A83 49                      				dec		ecx
  3225 00001A84 75F5                    				jnz		.scan
  3226 00001A86 C7452400880000          .not_found:			mov		int_EAX,0x8800			; not found
  3227 00001A8D C7451C00000000          				mov		int_EDX,0
  3228                                  				int_exit
  3229 00001A94 07                  <1>  pop es
  3230 00001A95 1F                  <1>  pop ds
  3231 00001A96 61                  <1>  popa
  3232 00001A97 83C408              <1>  add esp,8
  3233 00001A9A CF                  <1>  iret
  3234 00001A9B F6D0                    .found:				not		al
  3235 00001A9D 30E4                    				xor		ah,ah
  3236 00001A9F 31DB                    				xor		ebx,ebx
  3237 00001AA1 660FBCD8                				bsf		bx,ax				; BX=# of bit that is zero
  3238 00001AA5 742C                    				jz		.bmp_error			; ZF=0 or else
  3239 00001AA7 88D9                    				mov		cl,bl
  3240 00001AA9 B001                    				mov		al,1
  3241 00001AAB D2E0                    				shl		al,cl
  3242 00001AAD 260806                  				or		byte [es:esi],al
  3243 00001AB0 2B35[EA280000]          				sub		esi,[vcpi_alloc_bitmap_phys]
  3244 00001AB6 8D04F3                  				lea		eax,[esi*8+ebx]			; EAX = page number
  3245 00001AB9 C1E00C                  				shl		eax,12				; EAX = page address
  3246 00001ABC 0305[F2280000]          				add		eax,[vcpi_alloc_pages_phys]
  3247 00001AC2 89451C                  				mov		int_EDX,eax			; EDX = physical page #
  3248 00001AC5 C7452400000000          				mov		int_EAX,0
  3249                                  				int_exit
  3250 00001ACC 07                  <1>  pop es
  3251 00001ACD 1F                  <1>  pop ds
  3252 00001ACE 61                  <1>  popa
  3253 00001ACF 83C408              <1>  add esp,8
  3254 00001AD2 CF                  <1>  iret
  3255 00001AD3 E89AFCFFFF              .bmp_error:			call		interrupt_routine_halt_prepare
  3256 00001AD8 BA67000000              				mov		edx,67h
  3257 00001ADD BE[D6050000]            				mov		esi,str_vcpi_alloc_page_bug
  3258 00001AE2 E9A2010000              				jmp		fault_jmp_unhandled			
  3259                                  
  3260                                  ; AX=0xDE05 VCPI alloc page:
  3261 00001AE7 66B83000                vcpi05_free_page:		mov		ax,FLAT32_SEL
  3262 00001AEB 8EC0                    				mov		es,ax
  3263                                  
  3264 00001AED 8B551C                  				mov		edx,int_EDX
  3265 00001AF0 2B15[F2280000]          				sub		edx,[vcpi_alloc_pages_phys]
  3266 00001AF6 722D                    				jc		.not_found
  3267 00001AF8 C1EA0C                  				shr		edx,12
  3268 00001AFB 89D6                    				mov		esi,edx
  3269 00001AFD C1EE03                  				shr		esi,3
  3270 00001B00 3B35[EE280000]          				cmp		esi,[vcpi_alloc_bitmap_size]
  3271 00001B06 731D                    				jae		.not_found
  3272 00001B08 89D1                    				mov		ecx,edx
  3273 00001B0A 83E107                  				and		ecx,7
  3274 00001B0D B001                    				mov		al,1
  3275 00001B0F D2E0                    				shl		al,cl
  3276 00001B11 F6D0                    				not		al
  3277 00001B13 0335[EA280000]          				add		esi,[vcpi_alloc_bitmap_phys]
  3278 00001B19 CD03                    				int		3				; <- FIXME: Remove debug b.p. when you verify this works
  3279 00001B1B 262006                  				and		[es:esi],al
  3280                                  				int_exit
  3281 00001B1E 07                  <1>  pop es
  3282 00001B1F 1F                  <1>  pop ds
  3283 00001B20 61                  <1>  popa
  3284 00001B21 83C408              <1>  add esp,8
  3285 00001B24 CF                  <1>  iret
  3286 00001B25 C74524008A0000          .not_found:			mov		int_EAX,0x8A00
  3287 00001B2C B83412CDAB              				mov		eax,0xABCD1234			; <- DEBUG: remove when you verify this works
  3288 00001B31 CD03                    				int		3
  3289                                  				int_exit
  3290 00001B33 07                  <1>  pop es
  3291 00001B34 1F                  <1>  pop ds
  3292 00001B35 61                  <1>  popa
  3293 00001B36 83C408              <1>  add esp,8
  3294 00001B39 CF                  <1>  iret
  3295                                  
  3296                                  ; AX=0xDE06 VCPI get physical address of 4K page
  3297 00001B3A 8B4520                  vcpi06_get_phys_addr:		mov		eax,int_ECX
  3298 00001B3D 25FFFF0000              				and		eax,0xFFFF
  3299 00001B42 C1E00C                  				shl		eax,12
  3300 00001B45 89451C                  				mov		int_EDX,eax
  3301 00001B48 C7452400000000          				mov		int_EAX,0
  3302                                  				int_exit
  3303 00001B4F 07                  <1>  pop es
  3304 00001B50 1F                  <1>  pop ds
  3305 00001B51 61                  <1>  popa
  3306 00001B52 83C408              <1>  add esp,8
  3307 00001B55 CF                  <1>  iret
  3308                                  
  3309                                  ; AX=0xDE0A VCPI get Interrupt Vector Mappings
  3310 00001B56 C7452400000000          vcpi0A_8259A_mapping:		mov		int_EAX,0
  3311 00001B5D C74518F0000000          				mov		int_EBX,IRQ_BASE_INT	; 1st vector for master PIC
  3312 00001B64 C74520F8000000          				mov		int_ECX,IRQ_BASE_INT+8	; 1st vector for slave PIC
  3313                                  				int_exit
  3314 00001B6B 07                  <1>  pop es
  3315 00001B6C 1F                  <1>  pop ds
  3316 00001B6D 61                  <1>  popa
  3317 00001B6E 83C408              <1>  add esp,8
  3318 00001B71 CF                  <1>  iret
  3319                                  
  3320                                  ; AX=0xDE0C VCPI enter protected mode
  3321 00001B72 E8FBFBFFFF              vcpi0C_enter_pm:		call		interrupt_routine_halt_prepare
  3322 00001B77 BA67000000              				mov		edx,67h
  3323 00001B7C BE[F5050000]            				mov		esi,str_vcpi_pm_not_supported
  3324 00001B81 E903010000              				jmp		fault_jmp_unhandled
  3325                                  
  3326                                  ; AH=0x40 Get Status
  3327 00001B86 C7452400000000          emm40_get_status:		mov		int_EAX,0	; we're OK
  3328                                  				int_exit
  3329 00001B8D 07                  <1>  pop es
  3330 00001B8E 1F                  <1>  pop ds
  3331 00001B8F 61                  <1>  popa
  3332 00001B90 83C408              <1>  add esp,8
  3333 00001B93 CF                  <1>  iret
  3334                                  
  3335 00001B94 C7452400000000          emm41_get_pfa:			mov		int_EAX,0	; OK
  3336 00001B9B C7451800C00000          				mov		int_EBX,0xC000	; FIXME: We don't provide ANY pages, just make the VGA BISO the "page frame"
  3337                                  				int_exit
  3338 00001BA2 07                  <1>  pop es
  3339 00001BA3 1F                  <1>  pop ds
  3340 00001BA4 61                  <1>  popa
  3341 00001BA5 83C408              <1>  add esp,8
  3342 00001BA8 CF                  <1>  iret
  3343                                  
  3344 00001BA9 C7452400000000          emm42_get_unalloc_page_count:	mov		int_EAX,0	; OK
  3345 00001BB0 C7451800000000          				mov		int_EBX,0	; no pages free
  3346 00001BB7 C7451C00000000          				mov		int_EDX,0	; no pages at all
  3347                                  				int_exit
  3348 00001BBE 07                  <1>  pop es
  3349 00001BBF 1F                  <1>  pop ds
  3350 00001BC0 61                  <1>  popa
  3351 00001BC1 83C408              <1>  add esp,8
  3352 00001BC4 CF                  <1>  iret
  3353                                  
  3354 00001BC5 C7452400870000          emm43_alloc_pages:		mov		int_EAX,0x8700	; not enough memory
  3355 00001BCC C7451C00000000          				mov		int_EDX,0	; handle=0
  3356                                  				int_exit
  3357 00001BD3 07                  <1>  pop es
  3358 00001BD4 1F                  <1>  pop ds
  3359 00001BD5 61                  <1>  popa
  3360 00001BD6 83C408              <1>  add esp,8
  3361 00001BD9 CF                  <1>  iret
  3362                                  
  3363 00001BDA C74524008A0000          emm44_map_handle_page:		mov		int_EAX,0x8A00	; out of range
  3364                                  				int_exit
  3365 00001BE1 07                  <1>  pop es
  3366 00001BE2 1F                  <1>  pop ds
  3367 00001BE3 61                  <1>  popa
  3368 00001BE4 83C408              <1>  add esp,8
  3369 00001BE7 CF                  <1>  iret
  3370                                  
  3371 00001BE8 C7452400000000          emm45_dealloc_pages:		mov		int_EAX,0	; uhhhh... OK
  3372                                  				int_exit
  3373 00001BEF 07                  <1>  pop es
  3374 00001BF0 1F                  <1>  pop ds
  3375 00001BF1 61                  <1>  popa
  3376 00001BF2 83C408              <1>  add esp,8
  3377 00001BF5 CF                  <1>  iret
  3378                                  
  3379 00001BF6 C7452440000000          emm46_get_version:		mov		int_EAX,0x40	; version 4.0
  3380                                  				int_exit
  3381 00001BFD 07                  <1>  pop es
  3382 00001BFE 1F                  <1>  pop ds
  3383 00001BFF 61                  <1>  popa
  3384 00001C00 83C408              <1>  add esp,8
  3385 00001C03 CF                  <1>  iret
  3386                                  
  3387 00001C04 E9D0FCFFFF              emm47_save_page_map:		jmp	emm_unhandled
  3388 00001C09 E9CBFCFFFF              emm48_restore_page_map:		jmp	emm_unhandled
  3389 00001C0E E9C6FCFFFF              emm4B_get_handle_count:		jmp	emm_unhandled
  3390 00001C13 E9C1FCFFFF              emm4C_get_handle_pages:		jmp	emm_unhandled
  3391 00001C18 E9BCFCFFFF              emm4D_get_all_handle_pages:	jmp	emm_unhandled
  3392 00001C1D E9B7FCFFFF              emm4E_combo:			jmp	emm_unhandled
  3393 00001C22 E9B2FCFFFF              emm4F_combo:			jmp	emm_unhandled
  3394 00001C27 E9ADFCFFFF              emm50_combo:			jmp	emm_unhandled
  3395 00001C2C E9A8FCFFFF              emm51_realloc_pages:		jmp	emm_unhandled
  3396 00001C31 E9A3FCFFFF              emm52_combo:			jmp	emm_unhandled
  3397 00001C36 E99EFCFFFF              emm53_combo:			jmp	emm_unhandled
  3398 00001C3B E999FCFFFF              emm54_combo:			jmp	emm_unhandled
  3399 00001C40 E994FCFFFF              emm55_combo:			jmp	emm_unhandled
  3400 00001C45 E98FFCFFFF              emm56_combo:			jmp	emm_unhandled
  3401 00001C4A E98AFCFFFF              emm57_combo:			jmp	emm_unhandled
  3402                                  
  3403 00001C4F 8B4524                  emm58_combo:			mov	eax,int_EAX
  3404 00001C52 3C00                    				cmp	al,0	
  3405 00001C54 7405                    				jz	.func_5800
  3406 00001C56 E97EFCFFFF              				jmp	emm_unhandled
  3407                                  .func_5800: ; ========================== INT 67h AX=5800h
  3408 00001C5B C7452400000000          				mov	int_EAX,0		; OK
  3409 00001C62 C7452000000000          				mov	int_ECX,0		; the returned array is zero entries in length
  3410                                  				int_exit
  3411 00001C69 07                  <1>  pop es
  3412 00001C6A 1F                  <1>  pop ds
  3413 00001C6B 61                  <1>  popa
  3414 00001C6C 83C408              <1>  add esp,8
  3415 00001C6F CF                  <1>  iret
  3416                                  
  3417 00001C70 E964FCFFFF              emm59_combo:			jmp	emm_unhandled
  3418 00001C75 E95FFCFFFF              emm5A_combo:			jmp	emm_unhandled
  3419 00001C7A E95AFCFFFF              emm5B_combo:			jmp	emm_unhandled
  3420 00001C7F E955FCFFFF              emm5C_prepare_warmboot:		jmp	emm_unhandled
  3421 00001C84 E950FCFFFF              emm5D_combo:			jmp	emm_unhandled
  3422                                  
  3423                                  
  3424                                  %unmacro int_entry 0
  3425                                  %unmacro int_exit 0
  3426                                  %undef		int_ES
  3427                                  %undef		int_DS
  3428                                  %undef		int_EDI
  3429                                  %undef		int_ESI
  3430                                  %undef		int_EBP
  3431                                  %undef		int_ESP
  3432                                  %undef		int_EBX
  3433                                  %undef		int_EDX
  3434                                  %undef		int_ECX
  3435                                  %undef		int_EAX
  3436                                  %undef		int_INTNUM
  3437                                  %undef		int_INTNUM_b
  3438                                  %undef		int_ERRCODE
  3439                                  %undef		int_EIP_w
  3440                                  %undef		int_EIP
  3441                                  %undef		int_CS
  3442                                  %undef		int_EFLAGS
  3443                                  %undef		int_v86_SS
  3444                                  %undef		int_v86_ES
  3445                                  %undef		int_v86_DS
  3446                                  %undef		int_v86_FS
  3447                                  %undef		int_v86_GS
  3448                                  
  3449                                  ; ========== FAULT COLLECTION ROUTINE. SS:ESP should point to fault. If the exception does not push an error code,
  3450                                  ;    then the caller must push a dummy error code
  3451                                  ; if privilege escalation was involved (stack switching) then retrieve SS:ESP at fault from the stack frame.
  3452                                  ; else retrieve from actual SS:ESP registers
  3453                                  fault_jmp_unhandled:
  3454 00001C89 EA[901C0000]0800        		jmp		CODE16_SEL:.thunk16
  3455                                  		bits		16
  3456 00001C90 B81000                  .thunk16:	mov		ax,DATA16_SEL
  3457 00001C93 8ED8                    		mov		ds,ax
  3458 00001C95 8EC0                    		mov		es,ax
  3459 00001C97 8ED0                    		mov		ss,ax
  3460 00001C99 BC[0010]                		mov		sp,stack_init
  3461 00001C9C E91C01                  		jmp		unhandled_fault_errcode
  3462                                  		bits		32
  3463                                  
  3464                                  ; ============= cleanup, exit to DOS (from 32-bit protected mode)
  3465                                  _exit_from_prot32:
  3466 00001C9F EA[A61C0000]0800        		jmp		CODE16_SEL:.entry16
  3467                                  		bits		16
  3468 00001CA6 B81000                  .entry16:	mov		ax,DATA16_SEL
  3469 00001CA9 8ED8                    		mov		ds,ax
  3470 00001CAB 8EC0                    		mov		es,ax
  3471 00001CAD 8EE0                    		mov		fs,ax
  3472 00001CAF 8EE8                    		mov		gs,ax
  3473 00001CB1 8ED0                    		mov		ss,ax
  3474 00001CB3 66BC[00100000]          		mov		esp,stack_init
  3475                                  		
  3476                                  ; ============= cleanup, exit to DOS (from 16-bit protected mode)
  3477                                  _exit_from_prot16:
  3478 00001CB9 B81000                  		mov		ax,DATA16_SEL
  3479 00001CBC 8ED8                    		mov		ds,ax
  3480 00001CBE 8EC0                    		mov		es,ax
  3481 00001CC0 8EE0                    		mov		fs,ax
  3482 00001CC2 8EE8                    		mov		gs,ax
  3483 00001CC4 8ED0                    		mov		ss,ax
  3484                                  
  3485                                  		; overwrite the far jmp's segment value
  3486 00001CC6 A1[5620]                		mov		ax,[my_realmode_seg]
  3487 00001CC9 A3[E81C]                		mov		word [.real_hackme+3],ax
  3488 00001CCC 66BC[00100000]          		mov		esp,stack_init
  3489                                  
  3490 00001CD2 66B810000000            		mov		eax,0x00000010
  3491 00001CD8 0F22C0                  		mov		cr0,eax
  3492                                  
  3493 00001CDB 0F011E[8020]            		lidt		[idtr_real]
  3494 00001CE0 0F0116[7020]            		lgdt		[gdtr_real]
  3495                                  
  3496 00001CE5 EA[EA1C]0000            .real_hackme:	jmp		0:.real_entry
  3497 00001CEA 2EA1[5620]              .real_entry:	mov		ax,[cs:my_realmode_seg]
  3498 00001CEE 8ED8                    		mov		ds,ax
  3499 00001CF0 8EC0                    		mov		es,ax
  3500 00001CF2 8EE0                    		mov		fs,ax
  3501 00001CF4 8EE8                    		mov		gs,ax
  3502 00001CF6 8ED0                    		mov		ss,ax
  3503 00001CF8 BC[0010]                		mov		sp,stack_init
  3504                                  
  3505                                  ; reprogram the PIC back to what normal DOS expects: IRQ 0-7 => INT 8-15
  3506 00001CFB B010                    		mov		al,0x10			; ICW1 A0=0
  3507 00001CFD E620                    		out		20h,al
  3508 00001CFF B008                    		mov		al,0x08			; ICW2 A0=1
  3509 00001D01 E621                    		out		21h,al
  3510 00001D03 B004                    		mov		al,0x04			; ICW3 A0=1 slave on IRQ 2
  3511 00001D05 E621                    		out		21h,al
  3512                                  
  3513 00001D07 B010                    		mov		al,0x10			; ICW1 A0=0
  3514 00001D09 E6A0                    		out		0xA0,al
  3515 00001D0B B070                    		mov		al,0x70			; ICW2 A0=1
  3516 00001D0D E6A1                    		out		0xA1,al
  3517 00001D0F B002                    		mov		al,0x02			; ICW3 A0=1
  3518 00001D11 E6A1                    		out		0xA1,al
  3519                                  
  3520                                  ; remove our INT 66h API
  3521 00001D13 31C0                    		xor		ax,ax
  3522 00001D15 8EC0                    		mov		es,ax
  3523 00001D17 26A3BC03                		mov		word [es:(RM_INT_API*4)],ax
  3524 00001D1B 26A3BE03                		mov		word [es:(RM_INT_API*4)+2],ax
  3525                                  
  3526                                  ; free HIMEM.SYS blocks
  3527 00001D1F F706[5420]0000          		test		word [himem_sys_buffer_handle],0
  3528 00001D25 7414                    		jz		.no_himem_sys
  3529 00001D27 B40D                    		mov		ah,0Dh			; HIMEM.SYS function 0Dh unlock memory block
  3530 00001D29 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
  3531 00001D2D FF1E[4C20]              		call far	word [himem_sys_entry]
  3532 00001D31 B40A                    		mov		ah,0Ah			; HIMEM.SYS function 0Ah free memory block
  3533 00001D33 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
  3534 00001D37 FF1E[4C20]              		call far	word [himem_sys_entry]
  3535                                  .no_himem_sys:
  3536                                  
  3537                                  ; if we already exited as a TSR...
  3538 00001D3B F606[E128]01            		test		byte [i_am_tsr],1
  3539 00001D40 7506                    		jnz		.tsr_exit
  3540                                  
  3541                                  ; time to exit to DOS
  3542 00001D42 BA[1005]                		mov		dx,str_exit_to_dos
  3543 00001D45 E922E3                  		jmp		_exit_with_msg
  3544                                  
  3545                                  ; ============= ALTERNATE EXIT IF WE ALREADY EXITED AS TSR
  3546                                  .tsr_exit:	
  3547 00001D48 8CC8                    		mov		ax,cs
  3548 00001D4A 8EC0                    		mov		es,ax			; ES = our code segment which is also our PSP segment
  3549 00001D4C B449                    		mov		ah,0x49			; function 49h free memory block
  3550 00001D4E F8                      		clc
  3551 00001D4F CD21                    		int		21h
  3552 00001D51 7306                    		jnc		.tsr_exit_free_ok
  3553 00001D53 BA[9200]                		mov		dx,str_cannot_free_self
  3554 00001D56 E82504                  		call		dos_puts
  3555                                  .tsr_exit_free_ok:
  3556 00001D59 FA                      		cli
  3557 00001D5A 2EA1[E628]              		mov		ax,[cs:unload_int_stk+0]	; offset
  3558 00001D5E 83C006                  		add		ax,6				; discard prior frame
  3559 00001D61 89C4                    		mov		sp,ax
  3560 00001D63 2EA1[E828]              		mov		ax,[cs:unload_int_stk+2]	; segment
  3561 00001D67 8ED0                    		mov		ss,ax
  3562                                  
  3563 00001D69 BA[1005]                		mov		dx,str_exit_to_dos
  3564 00001D6C E80F04                  		call		dos_puts
  3565                                  
  3566 00001D6F 833E[5420]00            		cmp		word [himem_sys_buffer_handle],0 ; if there is a handle to free, then do it
  3567 00001D74 7414                    		jz		.no_handle
  3568 00001D76 B40D                    		mov		ah,0Dh			; HIMEM.SYS function 0Dh unlock memory block
  3569 00001D78 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
  3570 00001D7C FF1E[4C20]              		call far	word [himem_sys_entry]
  3571 00001D80 B40A                    		mov		ah,0Ah			; HIMEM.SYS function 0Ah free memory block
  3572 00001D82 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
  3573 00001D86 FF1E[4C20]              		call far	word [himem_sys_entry]
  3574                                  .no_handle:
  3575                                  
  3576 00001D8A FA                      		cli
  3577                                  
  3578 00001D8B B020                    		mov		al,020h
  3579                                  
  3580 00001D8D E6A0                    		out		0A0h,al
  3581 00001D8F E6A0                    		out		0A0h,al
  3582 00001D91 E6A0                    		out		0A0h,al
  3583 00001D93 E6A0                    		out		0A0h,al
  3584 00001D95 E6A0                    		out		0A0h,al
  3585 00001D97 E6A0                    		out		0A0h,al
  3586 00001D99 E6A0                    		out		0A0h,al
  3587 00001D9B E6A0                    		out		0A0h,al
  3588                                  
  3589 00001D9D E620                    		out		20h,al
  3590 00001D9F E620                    		out		20h,al
  3591 00001DA1 E620                    		out		20h,al
  3592 00001DA3 E620                    		out		20h,al
  3593 00001DA5 E620                    		out		20h,al
  3594 00001DA7 E620                    		out		20h,al
  3595 00001DA9 E620                    		out		20h,al
  3596 00001DAB E620                    		out		20h,al
  3597                                  
  3598 00001DAD E461                    		in		al,61h
  3599 00001DAF E461                    		in		al,61h
  3600 00001DB1 E461                    		in		al,61h
  3601 00001DB3 E461                    		in		al,61h
  3602                                  
  3603 00001DB5 FB                      		sti
  3604                                  
  3605 00001DB6 2EFF2E[E228]            		jmp far		word [cs:unload_int_ret]
  3606                                  
  3607                                  ; ============= UNHANDLED FAULT HANDLER (16-bit code)
  3608                                  ;   input: EDX = Number of interrupt
  3609                                  ;          SI = Textual string of fault
  3610                                  ;                  
  3611                                  unhandled_fault_errcode:
  3612 00001DBB FA                      		cli
  3613 00001DBC B81000                  		mov		ax,DATA16_SEL
  3614 00001DBF 8ED8                    		mov		ds,ax
  3615                                  
  3616 00001DC1 2EA1[5620]              		mov		ax,[cs:my_realmode_seg]
  3617 00001DC5 A3[E91D]                		mov		word [.real16jmp+3],ax
  3618                                  
  3619 00001DC8 B82800                  		mov		ax,FLAT16_SEL
  3620 00001DCB 8ED8                    		mov		ds,ax
  3621 00001DCD 8EC0                    		mov		es,ax
  3622 00001DCF 8ED0                    		mov		ss,ax
  3623                                  
  3624 00001DD1 2E0F0116[7020]          		lgdt		[cs:gdtr_real]
  3625 00001DD7 2E0F011E[8020]          		lidt		[cs:idtr_real]
  3626                                  
  3627                                  		; crash-thunk to real mode
  3628 00001DDD 66B810000000            		mov		eax,0x00000010
  3629 00001DE3 0F22C0                  		mov		cr0,eax
  3630 00001DE6 EA[EB1D]0000            .real16jmp:	jmp		0:.real16
  3631 00001DEB 2EA1[5620]              .real16:	mov		ax,[cs:my_realmode_seg]
  3632 00001DEF 8ED8                    		mov		ds,ax
  3633 00001DF1 8ED0                    		mov		ss,ax
  3634 00001DF3 31C0                    		xor		ax,ax
  3635 00001DF5 8EC0                    		mov		es,ax
  3636                                  
  3637 00001DF7 B80300                  		mov		ax,3
  3638 00001DFA CD10                    		int		10h
  3639                                  
  3640 00001DFC FC                      		cld
  3641 00001DFD B8204E                  		mov		ax,0x4E20
  3642 00001E00 66B9D0070000            		mov		ecx,80*25
  3643 00001E06 66BF00800B00            		mov		edi,0xB8000
  3644 00001E0C F367AB                  		a32 rep		stosw
  3645                                  
  3646                                  		; print exception name on screen
  3647 00001E0F 66BF00800B00            		mov		edi,0xB8000
  3648 00001E15 E8F800                  		call		.unhandled_print
  3649 00001E18 B020                    		mov		al,' '		; +space plus AH still contains upper byte from .unhandled_print
  3650 00001E1A 67AB                    		a32 stosw
  3651                                  
  3652                                  		; then the number (in EDX) write to DS:DI
  3653 00001E1C 6689D0                  		mov		eax,edx
  3654 00001E1F 6657                    		push		edi
  3655 00001E21 66BF[04100000]          		mov		edi,scratch_str
  3656 00001E27 E8CA03                  		call		eax_to_hex_16_dos
  3657 00001E2A 8D7506                  		lea		si,[di+6]	; only the last two hex digits
  3658 00001E2D 665F                    		pop		edi
  3659 00001E2F E8DE00                  		call		.unhandled_print
  3660                                  
  3661                                  		; print the registers.
  3662                                  		; during this loop: SI = print list  EDI = location on screen to draw   [ESP] = location on screen of row start
  3663 00001E32 66BF40810B00            		mov		edi,0xB8000+(160*2)	; two lines down
  3664 00001E38 6657                    		push		edi
  3665 00001E3A BE[0E21]                		mov		si,printlist_32
  3666 00001E3D AD                      .regprint32:	lodsw
  3667 00001E3E 09C0                    		or		ax,ax
  3668 00001E40 743F                    		jz		.regprint32e		; AX=0 STOP
  3669 00001E42 48                      		dec		ax
  3670 00001E43 742F                    		jz		.regprint32nl		; AX=1 GO TO NEW LINE
  3671 00001E45 56                      		push		si
  3672 00001E46 89C6                    		mov		si,ax			; SI=AX=address of variable name
  3673 00001E48 46                      		inc		si
  3674 00001E49 E8C400                  		call		.unhandled_print
  3675 00001E4C 5E                      		pop		si
  3676 00001E4D B83A4E                  		mov		ax,0x4E00 | (':')
  3677 00001E50 67AB                    		a32 stosw
  3678 00001E52 AD                      		lodsw					; SI=address of variable
  3679 00001E53 56                      		push		si
  3680 00001E54 89C6                    		mov		si,ax
  3681 00001E56 668B04                  		mov		eax,[si]
  3682 00001E59 6657                    		push		edi
  3683 00001E5B 66BF[04100000]          		mov		edi,scratch_str
  3684 00001E61 E89003                  		call		eax_to_hex_16_dos
  3685 00001E64 6689FE                  		mov		esi,edi
  3686 00001E67 665F                    		pop		edi
  3687 00001E69 E8A400                  		call		.unhandled_print
  3688 00001E6C 5E                      		pop		si
  3689 00001E6D B8204E                  		mov		ax,0x4E00 | (' ')
  3690 00001E70 67AB                    		a32 stosw
  3691 00001E72 EBC9                    		jmp		.regprint32
  3692 00001E74 665F                    .regprint32nl:	pop		edi
  3693 00001E76 6681C7A0000000          		add		edi,160			; move to next line, save back to [ESP]
  3694 00001E7D 6657                    		push		edi
  3695 00001E7F EBBC                    		jmp		.regprint32
  3696 00001E81 665F                    .regprint32e:	pop		edi
  3697                                  
  3698 00001E83 6681C7A0000000          		add		edi,160			; next line...
  3699                                  
  3700 00001E8A BE[5021]                		mov		si,printlist_16
  3701 00001E8D AD                      .regprint16:	lodsw
  3702 00001E8E 09C0                    		or		ax,ax
  3703 00001E90 7443                    		jz		.regprint16e		; AX=0 STOP
  3704 00001E92 48                      		dec		ax
  3705 00001E93 7433                    		jz		.regprint16nl		; AX=1 GO TO NEW LINE
  3706 00001E95 56                      		push		si
  3707 00001E96 89C6                    		mov		si,ax			; SI=AX=address of variable name
  3708 00001E98 46                      		inc		si
  3709 00001E99 E87400                  		call		.unhandled_print
  3710 00001E9C 5E                      		pop		si
  3711 00001E9D B83A4E                  		mov		ax,0x4E00 | (':')
  3712 00001EA0 67AB                    		a32 stosw
  3713 00001EA2 AD                      		lodsw					; SI=address of variable
  3714 00001EA3 56                      		push		si
  3715 00001EA4 89C6                    		mov		si,ax
  3716 00001EA6 6631C0                  		xor		eax,eax
  3717 00001EA9 8B04                    		mov		ax,[si]
  3718 00001EAB 6657                    		push		edi
  3719 00001EAD 66BF[04100000]          		mov		edi,scratch_str
  3720 00001EB3 E83E03                  		call		eax_to_hex_16_dos
  3721 00001EB6 66678D7704              		lea		esi,[edi+4]
  3722 00001EBB 665F                    		pop		edi
  3723 00001EBD E85000                  		call		.unhandled_print
  3724 00001EC0 5E                      		pop		si
  3725 00001EC1 B8204E                  		mov		ax,0x4E00 | (' ')
  3726 00001EC4 67AB                    		a32 stosw
  3727 00001EC6 EBC5                    		jmp		.regprint16
  3728 00001EC8 665F                    .regprint16nl:	pop		edi
  3729 00001ECA 6681C7A0000000          		add		edi,160			; move to next line, save back to [ESP]
  3730 00001ED1 6657                    		push		edi
  3731 00001ED3 EBB8                    		jmp		.regprint16
  3732 00001ED5 BE[0B03]                .regprint16e:	mov		si,str_mode_prot	; CPU mode
  3733 00001ED8 66F706[1E29]000002-     		test		dword [unhandled_fault_var_eflags],0x20000
  3734 00001EE0 00                 
  3735 00001EE1 7403                    		jz		.regprint_cpu_mode_not_v86
  3736 00001EE3 BE[1A03]                		mov		si,str_mode_v86
  3737                                  .regprint_cpu_mode_not_v86:
  3738 00001EE6 E82700                  		call		.unhandled_print
  3739 00001EE9 665F                    		pop		edi
  3740                                  
  3741 00001EEB B020                    		mov		al,020h
  3742                                  
  3743 00001EED E6A0                    		out		0A0h,al
  3744 00001EEF E6A0                    		out		0A0h,al
  3745 00001EF1 E6A0                    		out		0A0h,al
  3746 00001EF3 E6A0                    		out		0A0h,al
  3747 00001EF5 E6A0                    		out		0A0h,al
  3748 00001EF7 E6A0                    		out		0A0h,al
  3749 00001EF9 E6A0                    		out		0A0h,al
  3750 00001EFB E6A0                    		out		0A0h,al
  3751                                  
  3752 00001EFD E620                    		out		20h,al
  3753 00001EFF E620                    		out		20h,al
  3754 00001F01 E620                    		out		20h,al
  3755 00001F03 E620                    		out		20h,al
  3756 00001F05 E620                    		out		20h,al
  3757 00001F07 E620                    		out		20h,al
  3758 00001F09 E620                    		out		20h,al
  3759 00001F0B E620                    		out		20h,al
  3760                                  
  3761 00001F0D FB                      		sti
  3762 00001F0E EBFE                    		jmp		short $
  3763                                  ; ===== print on screen from DS:SI to ES:EDI
  3764                                  .unhandled_print:
  3765 00001F10 AC                      		lodsb
  3766 00001F11 3C24                    		cmp		al,'$'
  3767 00001F13 7406                    		jz		.unhandled_printe
  3768 00001F15 B44E                    		mov		ah,0x4E
  3769 00001F17 67AB                    		a32 stosw
  3770 00001F19 EBF5                    		jmp		.unhandled_print
  3771                                  .unhandled_printe:
  3772 00001F1B C3                      		ret
  3773                                  
  3774                                  ; ============= Entry point (virtual 8086 mode)
  3775 00001F1C 8CD8                    vm86_entry:	mov		ax,ds		; *DEBUG*
  3776 00001F1E 8ED0                    		mov		ss,ax
  3777                                  
  3778 00001F20 FA                      		cli				; make sure the v86 monitor handles CLI
  3779 00001F21 FB                      		sti				; ...and STI
  3780 00001F22 9C                      		pushf				; ...and PUSHF
  3781 00001F23 9D                      		popf				; ...and POPF
  3782 00001F24 669C                    		pushfd				; ...32-bit PUSHF
  3783 00001F26 669D                    		popfd				; ...32-bit POPF
  3784 00001F28 E421                    		in		al,21h		; ...IN?
  3785 00001F2A E621                    		out		21h,al		; ...OUT?
  3786                                  
  3787                                  		; can I clear vm86 mode by clearing the VM bit?
  3788 00001F2C 669C                    		pushfd
  3789 00001F2E 6658                    		pop		eax
  3790 00001F30 6625FFFFFDFF            		and		eax,~0x20000
  3791 00001F36 6650                    		push		eax
  3792 00001F38 669D                    		popfd
  3793                                  
  3794                                  		; NOW MAKE SURE PUSHF/POPF STORE THE VALUE ON-STACK LIKE THEY'RE SUPPOSED TO
  3795 00001F3A 89E3                    		mov		bx,sp
  3796 00001F3C 36C747FE5A5A            		mov		word [ss:bx-2],0x5A5A
  3797 00001F42 9C                      		pushf
  3798 00001F43 89E3                    		mov		bx,sp
  3799 00001F45 36813F5A5A              		cmp		word [ss:bx],0x5A5A
  3800 00001F4A 7506                    		jnz		.pushf_ok	; if the value DIDN'T CHANGE then the monitor failed to write FLAGS to stack
  3801 00001F4C B80000                  		mov		ax,0
  3802 00001F4F E9D900                  		jmp		vm86_errcode
  3803                                  .pushf_ok:
  3804                                  
  3805                                  		; DOES POPF WORK?
  3806 00001F52 B89204                  		mov		ax,0x492
  3807 00001F55 50                      		push		ax
  3808 00001F56 9D                      		popf
  3809 00001F57 9C                      		pushf
  3810 00001F58 58                      		pop		ax
  3811 00001F59 25D60F                  		and		ax,0xFD6
  3812 00001F5C 3D9204                  		cmp		ax,0x492
  3813 00001F5F 7406                    		jz		.popf_ok
  3814 00001F61 B80100                  		mov		ax,1
  3815 00001F64 E9C400                  		jmp		vm86_errcode
  3816                                  .popf_ok:
  3817                                  
  3818                                  		; TEST 32-bit PUSHF
  3819 00001F67 89E3                    		mov		bx,sp
  3820 00001F69 3666C747FC5A5A5A5A      		mov		dword [ss:bx-4],0x5A5A5A5A
  3821 00001F72 669C                    		pushfd
  3822 00001F74 89E3                    		mov		bx,sp
  3823 00001F76 3666813F5A5A5A5A        		cmp		dword [ss:bx],0x5A5A5A5A
  3824 00001F7E 7506                    		jnz		.pushfd_ok	; if the value DIDN'T CHANGE then the monitor failed to write FLAGS to stack
  3825 00001F80 B80200                  		mov		ax,2
  3826 00001F83 E9A500                  		jmp		vm86_errcode
  3827                                  .pushfd_ok:
  3828                                  
  3829                                  		; DOES POPFD WORK?
  3830 00001F86 66B892040000            		mov		eax,0x492
  3831 00001F8C 6650                    		push		eax
  3832 00001F8E 669D                    		popfd
  3833 00001F90 669C                    		pushfd
  3834 00001F92 6658                    		pop		eax
  3835 00001F94 6625D60F0000            		and		eax,0xFD6
  3836 00001F9A 663D92040000            		cmp		eax,0x492
  3837 00001FA0 7406                    		jz		.popfd_ok
  3838 00001FA2 B80300                  		mov		ax,3
  3839 00001FA5 E98300                  		jmp		vm86_errcode
  3840                                  .popfd_ok:
  3841                                  
  3842                                  		; IF I CLEAR INTERRUPT (CLI) AND THEN EXECUTE AN INTERRUPT, DOES IT COME BACK ENABLED?
  3843 00001FA8 FA                      		cli
  3844 00001FA9 B40F                    		mov		ah,0x0F			; INT 10 AH=0x0F which has no visisible effect
  3845 00001FAB CD10                    		int		10h
  3846 00001FAD 9C                      		pushf
  3847 00001FAE 58                      		pop		ax
  3848 00001FAF A90002                  		test		ax,0x200
  3849 00001FB2 7405                    		jz		.int_doesnt_enable
  3850 00001FB4 B80400                  		mov		ax,4
  3851 00001FB7 EB72                    		jmp		vm86_errcode
  3852                                  .int_doesnt_enable:
  3853                                  
  3854                                  		; HELLO WORLD!
  3855 00001FB9 BE[2C03]                		mov		si,str_vm86_hello
  3856 00001FBC E8AB01                  		call		bios_puts
  3857                                  
  3858                                  		; TEST DEFERRED IRQ MECHANISM BY DELIBERATLEY HALTING FOR AWHILE
  3859 00001FBF FA                      		cli
  3860 00001FC0 66B900000001            		mov		ecx,0x1000000		; delibrate slow countdown loop
  3861 00001FC6 6649                    .l1:		dec		ecx
  3862 00001FC8 75FC                    		jnz		.l1
  3863 00001FCA FB                      		sti
  3864                                  
  3865                                  		; for my next trick, I will exit to DOS as a TSR
  3866                                  		; and allow the user to run the whole DOS kernel this way :)
  3867 00001FCB 2E8E062C00              		mov		es,[cs:0x2C]		; locate our environment block and free it
  3868 00001FD0 B449                    		mov		ah,0x49			; function 49h free memory block
  3869 00001FD2 CD21                    		int		21h
  3870 00001FD4 7305                    		jnc		.env_free_ok
  3871 00001FD6 B80400                  		mov		ax,4
  3872 00001FD9 EB50                    		jmp		vm86_errcode
  3873 00001FDB 2EC7062C000000          .env_free_ok:	mov		word [cs:0x2C],0	; rub out the ENV block
  3874                                  
  3875                                  		; setup our INT 66h API
  3876 00001FE2 31C0                    		xor		ax,ax
  3877 00001FE4 8EC0                    		mov		es,ax
  3878 00001FE6 26C706BC03[3C20]        		mov		word [es:(RM_INT_API*4)],realmode_api_entry
  3879 00001FED 8CC8                    		mov		ax,cs
  3880 00001FEF 26A3BE03                		mov		word [es:(RM_INT_API*4)+2],ax
  3881                                  
  3882                                  		; setup our INT 67h vector
  3883                                  		; REMINDER: On exit you need to restore this vector
  3884 00001FF3 8CC8                    		mov		ax,cs
  3885 00001FF5 BB[2006]                		mov		bx,rm_int_67_entry
  3886 00001FF8 C1EB04                  		shr		bx,4
  3887 00001FFB 01D8                    		add		ax,bx
  3888 00001FFD 26A39E01                		mov		word [es:(0x67*4)+2],ax
  3889 00002001 31C0                    		xor		ax,ax
  3890 00002003 26A39C01                		mov		word [es:(0x67*4)+0],ax
  3891                                  
  3892                                  		; finally, terminate and stay resident
  3893 00002007 C606[E128]01            		mov		byte [i_am_tsr],1
  3894 0000200C 66BA[4E4A0000]          		mov		edx,the_end		; DX = memory in paragraphs to save
  3895 00002012 6683C20F                		add		edx,15
  3896 00002016 66C1EA04                		shr		edx,4
  3897 0000201A 6683C211                		add		edx,0x11		; <-- FIXME: IS THIS NECESSARY?
  3898 0000201E B431                    		mov		ah,0x31			; function 31h terminate and stay resident
  3899 00002020 CD21                    		int		21h
  3900                                  
  3901                                  ; ============= "Secret Handshake" to exit back into the v86 monitor and shutdown the program (virtual 8086 mode)
  3902                                  ; TODO: Remove this, call into RM_INT_API instead
  3903 00002022 66B8BBAABBAA            vm86_exit:	mov		eax,0xAABBAABB
  3904 00002028 CDEF                    		int		RM_INT_API
  3905 0000202A F4                      		hlt
  3906                                  
  3907                                  ; ============= If any of our self-test fails, we draw DIRECTLY ON VGA RAM and hike back into the vm86 monitor ASAP.
  3908                                  ;   if self-tests fail chances are calling the BIOS/DOS will cause major problems. AX=CODE
  3909 0000202B BB00B8                  vm86_errcode:	mov		bx,0xB800
  3910 0000202E 8EC3                    		mov		es,bx
  3911 00002030 83E00F                  		and		ax,0xF
  3912 00002033 0D304E                  		or		ax,0x4E30	; AX = VGA alphanumeric code for that number
  3913 00002036 26A3A000                		mov		[es:160],ax
  3914 0000203A EBE6                    		jmp		vm86_exit
  3915                                  
  3916                                  ; ============= Real-mode API entry (reflect to v86 monitor by executing an INT)
  3917                                  ;    this would allow the trick to work even for programs that direct-call instead
  3918                                  realmode_api_entry:
  3919 0000203C CDEF                    		int		RM_INT_API
  3920 0000203E CF                      		iret
  3921                                  
  3922                                  ; ============= Parse command line (from PSP segment)
  3923 0000203F FC                      parse_argv:	cld
  3924 00002040 BE8100                  		mov		si,81h
  3925 00002043 AC                      .scan:		lodsb
  3926 00002044 08C0                    		or		al,al
  3927 00002046 7410                    		jz		.done
  3928 00002048 3C0D                    		cmp		al,0Dh
  3929 0000204A 740C                    		jz		.done
  3930 0000204C 3C20                    		cmp		al,20h
  3931 0000204E 74F3                    		jz		.scan
  3932 00002050 3C2D                    		cmp		al,'-'
  3933 00002052 7405                    		jz		.switch
  3934 00002054 3C2F                    		cmp		al,'/'
  3935 00002056 7401                    		jz		.switch
  3936                                  		; FALL THROUGH WITH ZF=0 to return
  3937 00002058 C3                      .done:		ret
  3938                                  		; AT THIS POINT: SI = just after the / or - in the switch
  3939 00002059 AC                      .switch:	lodsb
  3940 0000205A 3C3F                    		cmp		al,'?'
  3941 0000205C 7416                    		jz		.help
  3942 0000205E 3C41                    		cmp		al,'A'
  3943 00002060 7215                    		jb		.unknown_switch
  3944 00002062 3C5A                    		cmp		al,'Z'
  3945 00002064 7711                    		ja		.unknown_switch
  3946                                  		; the A-Z switches are allowed to have "=NNNN" after them where N is some integer in hex or decimal
  3947 00002066 2C41                    		sub		al,'A'
  3948 00002068 88C3                    		mov		bl,al
  3949 0000206A 30FF                    		xor		bh,bh		; BX = index into lookup table
  3950 0000206C 01DB                    		add		bx,bx
  3951 0000206E FFA7[DA20]              		jmp		word [bx+.switch_az]
  3952 00002072 B001                    .fail:		mov		al,1
  3953 00002074 08C0                    .help:		or		al,al		; AL != 0 => ZF=0
  3954 00002076 C3                      		ret
  3955 00002077 BA[9902]                .unknown_switch:mov		dx,str_unknown_switch
  3956 0000207A E80101                  		call		dos_puts
  3957 0000207D 8D54FE                  		lea		dx,[si-2]	; step back two chars
  3958 00002080 C60424                  		mov		byte [si],'$'
  3959 00002083 E8F800                  		call		dos_puts
  3960 00002086 BA[5E01]                		mov		dx,str_crlf
  3961 00002089 E8F200                  		call		dos_puts
  3962 0000208C EBE4                    		jmp		.fail
  3963                                  ; ========== Switches CALL here if they need a numeric value to follow.
  3964                                  ; returns to caller if so, parsing as 16-bit integer returned in EAX. Else,
  3965                                  ; it discards the return address and jumps to the 'needs param' error message.
  3966                                  .switch_needs_equ_check:
  3967 0000208E 803C3D                  		cmp		byte [si],'='
  3968 00002091 7509                    		jnz		.switch_needs_equ_check_fail
  3969 00002093 46                      		inc		si
  3970 00002094 FA                      		cli
  3971 00002095 6631C0                  		xor		eax,eax
  3972 00002098 E8FB00                  		call		ax_strtol_16
  3973 0000209B C3                      		ret
  3974                                  .switch_needs_equ_check_fail:
  3975 0000209C 83C402                  		add		sp,2		; fall through
  3976                                  .switch_needs_equ:
  3977 0000209F BA[A902]                		mov		dx,str_needs_equals
  3978 000020A2 E8D900                  		call		dos_puts
  3979 000020A5 EBCB                    		jmp		.fail
  3980                                  ; ========== /B=<number>
  3981                                  .switch_buffer_size:
  3982 000020A7 E8E4FF                  		call		.switch_needs_equ_check
  3983 000020AA 66C1E00A                		shl		eax,10
  3984 000020AE 66A3[0000]              		mov		[himem_sys_buffer_size],eax
  3985 000020B2 EB8F                    		jmp		.scan
  3986                                  ; ========== /U
  3987 000020B4 C606[8A20]01            .switch_unload:	mov		byte [user_req_unload],1
  3988 000020B9 EB88                    		jmp		.scan
  3989                                  ; ========== /I
  3990 000020BB C606[E028]00            .switch_iopl:	mov		byte [user_req_iopl],0
  3991 000020C0 EB81                    		jmp		.scan
  3992                                  ; ========== /C
  3993                                  .switch_cache_disable:
  3994 000020C2 66810E[0400]000000-     		or		dword [cr0_more],0x40000000
  3995 000020CA 40                 
  3996 000020CB E975FF                  		jmp		.scan
  3997                                  ; ========== /W
  3998                                  .switch_writeback_disable:
  3999 000020CE 66810E[0400]000000-     		or		dword [cr0_more],0x20000000
  4000 000020D6 20                 
  4001 000020D7 E969FF                  		jmp		.scan
  4002                                  ; switch A-Z jump table
  4003 000020DA [7720]                  .switch_az:	dw		.unknown_switch			; /A
  4004 000020DC [A720]                  		dw		.switch_buffer_size		; /B=<number>
  4005 000020DE [C220]                  		dw		.switch_cache_disable		; /C
  4006 000020E0 [7720]                  		dw		.unknown_switch			; /D
  4007 000020E2 [7720]                  		dw		.unknown_switch			; /E
  4008 000020E4 [7720]                  		dw		.unknown_switch			; /F
  4009 000020E6 [7720]                  		dw		.unknown_switch			; /G
  4010 000020E8 [7720]                  		dw		.unknown_switch			; /H
  4011 000020EA [BB20]                  		dw		.switch_iopl			; /I
  4012 000020EC [7720]                  		dw		.unknown_switch			; /J
  4013 000020EE [7720]                  		dw		.unknown_switch			; /K
  4014 000020F0 [7720]                  		dw		.unknown_switch			; /L
  4015 000020F2 [7720]                  		dw		.unknown_switch			; /M
  4016 000020F4 [7720]                  		dw		.unknown_switch			; /N
  4017 000020F6 [7720]                  		dw		.unknown_switch			; /O
  4018 000020F8 [7720]                  		dw		.unknown_switch			; /P
  4019 000020FA [7720]                  		dw		.unknown_switch			; /Q
  4020 000020FC [7720]                  		dw		.unknown_switch			; /R
  4021 000020FE [7720]                  		dw		.unknown_switch			; /S
  4022 00002100 [7720]                  		dw		.unknown_switch			; /T
  4023 00002102 [B420]                  		dw		.switch_unload			; /U
  4024 00002104 [7720]                  		dw		.unknown_switch			; /V
  4025 00002106 [CE20]                  		dw		.switch_writeback_disable	; /W
  4026 00002108 [7720]                  		dw		.unknown_switch			; /X
  4027 0000210A [7720]                  		dw		.unknown_switch			; /Y
  4028 0000210C [7720]                  		dw		.unknown_switch			; /Z
  4029                                  
  4030                                  ; register print list
  4031 0000210E [BD02][FA28]            printlist_32:	dw		str_eax,	unhandled_fault_var_eax
  4032 00002112 [C102][FE28]            		dw		str_ebx,	unhandled_fault_var_ebx
  4033 00002116 [C502][0229]            		dw		str_ecx,	unhandled_fault_var_ecx
  4034 0000211A [C902][0629]            		dw		str_edx,	unhandled_fault_var_edx
  4035 0000211E [CD02][0A29]            		dw		str_esi,	unhandled_fault_var_esi
  4036 00002122 [D102][0E29]            		dw		str_edi,	unhandled_fault_var_edi
  4037 00002126 0100                    		dw		1
  4038 00002128 [D502][1229]            		dw		str_ebp,	unhandled_fault_var_ebp
  4039 0000212C [D902][1629]            		dw		str_esp,	unhandled_fault_var_esp
  4040 00002130 [DD02][1A29]            		dw		str_eip,	unhandled_fault_var_eip
  4041 00002134 [E502][1E29]            		dw		str_eflags,	unhandled_fault_var_eflags
  4042 00002138 [E102][F628]            		dw		str_errcode,	unhandled_fault_var_errcode
  4043 0000213C [E902][2229]            		dw		str_cr0,	unhandled_fault_var_cr0
  4044 00002140 0100                    		dw		1
  4045 00002142 [ED02][2629]            		dw		str_cr3,	unhandled_fault_var_cr3
  4046 00002146 [F102][2A29]            		dw		str_cr4,	unhandled_fault_var_cr4
  4047 0000214A [F502][3A29]            		dw		str_opcode,	unhandled_fault_var_opcode
  4048 0000214E 0000                    		dw		0
  4049 00002150 [F902][2E29]            printlist_16:	dw		str_cs,		unhandled_fault_var_cs
  4050 00002154 [FC02][3029]            		dw		str_ds,		unhandled_fault_var_ds
  4051 00002158 [FF02][3229]            		dw		str_es,		unhandled_fault_var_es
  4052 0000215C [0203][3429]            		dw		str_fs,		unhandled_fault_var_fs
  4053 00002160 [0503][3629]            		dw		str_gs,		unhandled_fault_var_gs
  4054 00002164 [0803][3829]            		dw		str_ss,		unhandled_fault_var_ss
  4055 00002168 0000                    		dw		0
  4056                                  
  4057                                  ; ============= bios_puts (print $-terminated string at DS:SI)
  4058 0000216A FA                      bios_puts:	cli
  4059 0000216B FC                      		cld
  4060 0000216C 50                      		push		ax
  4061 0000216D 53                      		push		bx
  4062 0000216E AC                      .putsloop:	lodsb
  4063 0000216F 3C24                    		cmp		al,'$'
  4064 00002171 7408                    		jz		.putsend
  4065 00002173 B40E                    		mov		ah,0x0E
  4066 00002175 31DB                    		xor		bx,bx
  4067 00002177 CD10                    		int		10h
  4068 00002179 EBF3                    		jmp		.putsloop
  4069 0000217B 5B                      .putsend:	pop		bx
  4070 0000217C 58                      		pop		ax
  4071 0000217D C3                      		ret
  4072                                  
  4073                                  ; ============= dos_puts (print $-terminated string at DS:DX)
  4074 0000217E B409                    dos_puts:	mov		ah,09h
  4075 00002180 CD21                    		int		21h
  4076 00002182 C3                      		ret
  4077                                  
  4078                                  ; ============= read one digit from DS:SI return in AX (16-bit code)
  4079 00002183 8A04                    ax_strtol_16_single:mov		al,[si]
  4080 00002185 3C30                    		cmp		al,'0'
  4081 00002187 720B                    		jb		.no
  4082 00002189 3C39                    		cmp		al,'9'
  4083 0000218B 7707                    		ja		.no
  4084 0000218D 2C30                    		sub		al,'0'
  4085 0000218F 30E4                    		xor		ah,ah
  4086 00002191 46                      		inc		si
  4087 00002192 F8                      		clc
  4088 00002193 C3                      		ret
  4089 00002194 F9                      .no:		stc
  4090 00002195 C3                      		ret
  4091                                  
  4092                                  ; ============= read from DS:SI and convert numerical string to integer value return in AX (16-bit code)
  4093 00002196 31C9                    ax_strtol_16:	xor		cx,cx
  4094 00002198 51                      .loop:		push		cx
  4095 00002199 E8E7FF                  		call		ax_strtol_16_single
  4096 0000219C 59                      		pop		cx
  4097 0000219D 720D                    		jc		.done
  4098 0000219F 89CB                    		mov		bx,cx
  4099 000021A1 01DB                    		add		bx,bx
  4100 000021A3 C1E103                  		shl		cx,3		; BX = CX * 2,  CX *= 8
  4101 000021A6 01D9                    		add		cx,bx		; CX = (CX * 8) + (CX * 2) = CX * 10
  4102 000021A8 01C1                    		add		cx,ax		; CX += new digit
  4103 000021AA EBEC                    		jmp		.loop
  4104 000021AC 89C8                    .done:		mov		ax,cx
  4105 000021AE C3                      		ret
  4106                                  
  4107                                  ; ============= take AX and write to buffer (DS:SI) as hexadecimal string (16-bit code)
  4108 000021AF C6450224                al_to_hex_16_dos:mov		byte [di+2],'$'
  4109 000021B3 EB04                    		jmp		al_to_hex_16
  4110 000021B5 C6450200                al_to_hex_16_nul:mov		byte [di+2],0
  4111 000021B9 57                      al_to_hex_16:	push		di
  4112 000021BA 53                      		push		bx
  4113 000021BB 50                      		push		ax
  4114 000021BC 30FF                    		xor		bh,bh
  4115 000021BE 88C4                    		mov		ah,al
  4116 000021C0 240F                    		and		al,0xF
  4117 000021C2 88C3                    		mov		bl,al
  4118 000021C4 8A87[6101]              		mov		al,[bx+str_hex]		; AL' = str_hex[al]
  4119 000021C8 C0EC04                  		shr		ah,4
  4120 000021CB 88E3                    		mov		bl,ah
  4121 000021CD 8AA7[6101]              		mov		ah,[bx+str_hex]		; AH' = str_hex[ah]
  4122 000021D1 8825                    		mov		[di+0],ah
  4123 000021D3 884501                  		mov		[di+1],al
  4124 000021D6 58                      		pop		ax
  4125 000021D7 5B                      		pop		bx
  4126 000021D8 5F                      		pop		di
  4127 000021D9 C3                      		ret
  4128                                  
  4129                                  ; ============= take AX and write to buffer (DS:SI) as hexadecimal string (16-bit code)
  4130 000021DA C6450424                ax_to_hex_16_dos:mov		byte [di+4],'$'
  4131 000021DE EB04                    		jmp		ax_to_hex_16
  4132 000021E0 C6450400                ax_to_hex_16_nul:mov		byte [di+4],0
  4133 000021E4 57                      ax_to_hex_16:	push		di
  4134 000021E5 50                      		push		ax
  4135 000021E6 88E0                    		mov		al,ah
  4136 000021E8 E8CEFF                  		call		al_to_hex_16
  4137 000021EB 58                      		pop		ax
  4138 000021EC 83C702                  		add		di,2
  4139 000021EF E8C7FF                  		call		al_to_hex_16
  4140 000021F2 5F                      		pop		di
  4141 000021F3 C3                      		ret
  4142                                  
  4143                                  ; ============= take EAX and write to buffer (DS:DI) as hexadecimal string (16-bit code)
  4144 000021F4 C6450824                eax_to_hex_16_dos:mov		byte [di+8],'$'
  4145 000021F8 EB04                    		jmp		eax_to_hex_16
  4146 000021FA C6450800                eax_to_hex_16_nul:mov		byte [di+8],0
  4147 000021FE 57                      eax_to_hex_16:	push		di
  4148 000021FF 6650                    		push		eax
  4149 00002201 66C1E810                		shr		eax,16
  4150 00002205 E8DCFF                  		call		ax_to_hex_16
  4151 00002208 6658                    		pop		eax
  4152 0000220A 83C704                  		add		di,4
  4153 0000220D E8D4FF                  		call		ax_to_hex_16
  4154 00002210 5F                      		pop		di
  4155 00002211 C3                      		ret
  4156                                  
  4157                                  ; ============= /U Unloading the resident copy of this program
  4158                                  unload_this_program:
  4159 00002212 0F01E0                  		smsw		ax
  4160 00002215 A801                    		test		al,1
  4161 00002217 7506                    		jnz		.v86_active
  4162 00002219 BA[7B00]                		mov		dx,str_not_loaded
  4163 0000221C E94BDE                  		jmp		_exit_with_msg
  4164                                  .v86_active:
  4165 0000221F 31C0                    		xor		ax,ax
  4166 00002221 8EC0                    		mov		es,ax
  4167 00002223 268B1EBC03              		mov		bx,[es:(RM_INT_API*4)]
  4168 00002228 260B0EBE03              		or		cx,[es:(RM_INT_API*4)+2]
  4169 0000222D 83F900                  		cmp		cx,0		; if pointer is 0000:0000
  4170 00002230 7434                    		jz		.v86_not_me
  4171 00002232 66B855AABBAA            		mov		eax,0xAABBAA55
  4172 00002238 CDEF                    		int		RM_INT_API
  4173 0000223A 663D33BBAABB            		cmp		eax,0xBBAABB33
  4174 00002240 7524                    		jnz		.v86_not_me
  4175 00002242 8CC8                    .v86_is_me:	mov		ax,cs
  4176 00002244 8ED8                    		mov		ds,ax
  4177 00002246 8EC0                    		mov		es,ax
  4178 00002248 8EE0                    		mov		fs,ax
  4179 0000224A 8EE8                    		mov		gs,ax
  4180 0000224C BA[1F00]                		mov		dx,str_removing_self
  4181 0000224F E82CFF                  		call		dos_puts
  4182                                  ; instruct it to remove itself
  4183 00002252 66B8BBAABBAA            		mov		eax,0xAABBAABB
  4184 00002258 CDEF                    		int		RM_INT_API
  4185                                  ; exit, having done our job
  4186 0000225A BA[5E01]                		mov		dx,str_crlf
  4187 0000225D E81EFF                  		call		dos_puts
  4188 00002260 BA[4701]                		mov		dx,str_unloaded
  4189 00002263 E904DE                  		jmp		_exit_with_msg
  4190 00002266 BA[5700]                .v86_not_me:	mov		dx,str_v86_but_not_me
  4191 00002269 E9FEDD                  		jmp		_exit_with_msg
  4192                                  
  4193                                  ; ============= DATA: THESE EXIST IN THE .COM BINARY IMAGE
  4194                                  		section		.data align=2
  4195 00000000 00000400                himem_sys_buffer_size:dd	(256*1024)	; DWORD [amount of extended memory to allocate]
  4196 00000004 00000000                cr0_more:	dd		0x00000000	; cache disable, not write through
  4197 00000008 333836206F72206869-     str_require_386:db		'386 or higher required$'
  4198 00000011 676865722072657175-
  4199 0000001A 6972656424         
  4200 0000001F 52656D6F76696E6720-     str_removing_self:db		'Removing from memory',13,10,'$'
  4201 00000028 66726F6D206D656D6F-
  4202 00000031 72790D0A24         
  4203 00000036 5669727475616C2038-     str_v86_detected:db		'Virtual 8086 mode already active$'
  4204 0000003F 303836206D6F646520-
  4205 00000048 616C72656164792061-
  4206 00000051 637469766524       
  4207 00000057 5669727475616C2038-     str_v86_but_not_me:db		'Virtual 8086 active, and its not me$'
  4208 00000060 303836206163746976-
  4209 00000069 652C20616E64206974-
  4210 00000072 73206E6F74206D6524 
  4211 0000007B 4E6F74207265736964-     str_not_loaded:	db		'Not resident in memory$'
  4212 00000084 656E7420696E206D65-
  4213 0000008D 6D6F727924         
  4214 00000092 43616E6E6F74206672-     str_cannot_free_self:db		'Cannot free self from memory$'
  4215 0000009B 65652073656C662066-
  4216 000000A4 726F6D206D656D6F72-
  4217 000000AD 7924               
  4218 000000AF 48494D454D2E535953-     str_need_himem_sys:db		'HIMEM.SYS not installed$'
  4219 000000B8 206E6F7420696E7374-
  4220 000000C1 616C6C656424       
  4221 000000C7 48494D454D2E535953-     str_himem_a20_error:db		'HIMEM.SYS failed to enable A20$'
  4222 000000D0 206661696C65642074-
  4223 000000D9 6F20656E61626C6520-
  4224 000000E2 41323024           
  4225 000000E6 556E61626C6520746F-     str_himem_alloc_err:db		'Unable to alloc extended memory$'
  4226 000000EF 20616C6C6F63206578-
  4227 000000F8 74656E646564206D65-
  4228 00000101 6D6F727924         
  4229 00000106 556E61626C6520746F-     str_himem_lock_err:db		'Unable to lock extended memory$'
  4230 0000010F 206C6F636B20657874-
  4231 00000118 656E646564206D656D-
  4232 00000121 6F727924           
  4233 00000125 42756666657220746F-     str_buffer_too_small:db		'Buffer too small$'
  4234 0000012E 6F20736D616C6C24   
  4235 00000136 42756666657220746F-     str_buffer_too_large:db		'Buffer too large$'
  4236 0000013F 6F206C6172676524   
  4237 00000147 556E6C6F616465640D-     str_unloaded:	db		'Unloaded',13,10,'$'
  4238 00000150 0A24               
  4239 00000152 427566666572206174-     str_buffer_at:	db		'Buffer at: $'
  4240 0000015B 3A2024             
  4241 0000015E 0D0A24                  str_crlf:	db		13,10,'$'
  4242 00000161 303132333435363738-     str_hex:	db		'0123456789ABCDEF'
  4243 0000016A 39414243444546     
  4244 00000171 5638364B45524E205B-     str_help:	db		'V86KERN [options]',13,10
  4245 0000017A 6F7074696F6E735D0D-
  4246 00000183 0A                 
  4247 00000184 44656D6F6E73747261-     		db		'Demonstration Virtual 8086 kernel/monitor',13,10
  4248 0000018D 74696F6E2056697274-
  4249 00000196 75616C203830383620-
  4250 0000019F 6B65726E656C2F6D6F-
  4251 000001A8 6E69746F720D0A     
  4252 000001AF 0D0A                    		db		13,10
  4253 000001B1 4F7074696F6E732073-     		db		'Options start with - or /',13,10
  4254 000001BA 746172742077697468-
  4255 000001C3 202D206F72202F0D0A 
  4256 000001CC 20202F3F2020202020-     		db		'  /?      Show this help',13,10
  4257 000001D5 2053686F7720746869-
  4258 000001DE 732068656C700D0A   
  4259 000001E6 20202F423D2E2E2E20-     		db		'  /B=...  Set buffer size (in KB)',13,10
  4260 000001EF 205365742062756666-
  4261 000001F8 65722073697A652028-
  4262 00000201 696E204B42290D0A   
  4263 00000209 20202F552020202020-     		db		'  /U      Unload the kernel',13,10
  4264 00000212 20556E6C6F61642074-
  4265 0000021B 6865206B65726E656C-
  4266 00000224 0D0A               
  4267 00000226 20202F492020202020-     		db		'  /I      Run with IOPL=3 (trap CLI/STI/etc)',13,10
  4268 0000022F 2052756E2077697468-
  4269 00000238 20494F504C3D332028-
  4270 00000241 7472617020434C492F-
  4271 0000024A 5354492F657463290D-
  4272 00000253 0A                 
  4273 00000254 20202F432020202020-     		db		'  /C      Disable memory cache',13,10
  4274 0000025D 2044697361626C6520-
  4275 00000266 6D656D6F7279206361-
  4276 0000026F 6368650D0A         
  4277 00000274 20202F572020202020-     		db		'  /W      Disable write-back cache',13,10
  4278 0000027D 2044697361626C6520-
  4279 00000286 77726974652D626163-
  4280 0000028F 6B2063616368650D0A 
  4281 00000298 24                      		db		'$'
  4282 00000299 556E6B6E6F776E2073-     str_unknown_switch:db		'Unknown switch $'
  4283 000002A2 77697463682024     
  4284 000002A9 537769746368206D69-     str_needs_equals:db		'Switch missing =...$'
  4285 000002B2 7373696E67203D2E2E-
  4286 000002BB 2E24               
  4287 000002BD 45415824                str_eax:	db		'EAX$'
  4288 000002C1 45425824                str_ebx:	db		'EBX$'
  4289 000002C5 45435824                str_ecx:	db		'ECX$'
  4290 000002C9 45445824                str_edx:	db		'EDX$'
  4291 000002CD 45534924                str_esi:	db		'ESI$'
  4292 000002D1 45444924                str_edi:	db		'EDI$'
  4293 000002D5 45425024                str_ebp:	db		'EBP$'
  4294 000002D9 45535024                str_esp:	db		'ESP$'
  4295 000002DD 45495024                str_eip:	db		'EIP$'
  4296 000002E1 45525224                str_errcode:	db		'ERR$'
  4297 000002E5 464C4724                str_eflags:	db		'FLG$'
  4298 000002E9 43523024                str_cr0:	db		'CR0$'
  4299 000002ED 43523324                str_cr3:	db		'CR3$'
  4300 000002F1 43523424                str_cr4:	db		'CR4$'
  4301 000002F5 4F504324                str_opcode:	db		'OPC$'
  4302 000002F9 435324                  str_cs:		db		'CS$'
  4303 000002FC 445324                  str_ds:		db		'DS$'
  4304 000002FF 455324                  str_es:		db		'ES$'
  4305 00000302 465324                  str_fs:		db		'FS$'
  4306 00000305 475324                  str_gs:		db		'GS$'
  4307 00000308 535324                  str_ss:		db		'SS$'
  4308 0000030B 50726F746563746564-     str_mode_prot:	db		'Protected mode$'
  4309 00000314 206D6F646524       
  4310 0000031A 5669727475616C2038-     str_mode_v86:	db		'Virtual 8086 mode$'
  4311 00000323 303836206D6F646524 
  4312 0000032C 546869732074657874-     str_vm86_hello:	db		'This text was printed by the Virtual 8086 mode component of this program',13,10,'$'
  4313 00000335 20776173207072696E-
  4314 0000033E 746564206279207468-
  4315 00000347 65205669727475616C-
  4316 00000350 2038303836206D6F64-
  4317 00000359 6520636F6D706F6E65-
  4318 00000362 6E74206F6620746869-
  4319 0000036B 732070726F6772616D-
  4320 00000374 0D0A24             
  4321 00000377 446976696465206279-     str_fault_0x00:	db		'Divide by Zero$'
  4322 00000380 205A65726F24       
  4323 00000386 446562756724            str_fault_0x01:	db		'Debug$'
  4324 0000038C 4E4D4924                str_fault_0x02:	db		'NMI$'
  4325 00000390 427265616B706F696E-     str_fault_0x03:	db		'Breakpoint$'
  4326 00000399 7424               
  4327 0000039B 4F766572666C6F7724      str_fault_0x04:	db		'Overflow$'
  4328 000003A4 426F756E6461727920-     str_fault_0x05:	db		'Boundary Check$'
  4329 000003AD 436865636B24       
  4330 000003B3 496E76616C6964204F-     str_fault_0x06:	db		'Invalid Opcode$'
  4331 000003BC 70636F646524       
  4332 000003C2 436F70726F63657373-     str_fault_0x07:	db		'Coprocessor N/A$'
  4333 000003CB 6F72204E2F4124     
  4334 000003D2 446F75626C65204661-     str_fault_0x08:	db		'Double Fault$'
  4335 000003DB 756C7424           
  4336 000003DF 436F70726F63657373-     str_fault_0x09:	db		'Coprocessor Segment Overrun$'
  4337 000003E8 6F72205365676D656E-
  4338 000003F1 74204F76657272756E-
  4339 000003FA 24                 
  4340 000003FB 496E76616C69642054-     str_fault_0x0A:	db		'Invalid TSS$'
  4341 00000404 535324             
  4342 00000407 5365676D656E74204E-     str_fault_0x0B:	db		'Segment Not Present$'
  4343 00000410 6F742050726573656E-
  4344 00000419 7424               
  4345 0000041B 537461636B20466175-     str_fault_0x0C:	db		'Stack Fault$'
  4346 00000424 6C7424             
  4347 00000427 47656E6572616C2050-     str_fault_0x0D:	db		'General Protection Fault$'
  4348 00000430 726F74656374696F6E-
  4349 00000439 204661756C7424     
  4350 00000440 50616765204661756C-     str_fault_0x0E:	db		'Page Fault$'
  4351 00000449 7424               
  4352 0000044B 457863657074696F6E-     str_fault_0x0F:	db		'Exception F$'
  4353 00000454 204624             
  4354 00000457 465055204572726F72-     str_fault_0x10:	db		'FPU Error$'
  4355 00000460 24                 
  4356 00000461 416C69676E6D656E74-     str_fault_0x11:	db		'Alignment Check$'
  4357 0000046A 20436865636B24     
  4358 00000471 4D616368696E652043-     str_fault_0x12:	db		'Machine Check$'
  4359 0000047A 6865636B24         
  4360 0000047F 53494D442F53534520-     str_fault_0x13:	db		'SIMD/SSE Exception$'
  4361 00000488 457863657074696F6E-
  4362 00000491 24                 
  4363 00000492 556E6B6E6F776E2065-     str_fault_unknown:db		'Unknown exception$'
  4364 0000049B 7863657074696F6E24 
  4365 000004A4 556E6B6E6F776E2069-     str_v86_unknown:db		'Unknown instruction in v86 mode$'
  4366 000004AD 6E737472756374696F-
  4367 000004B6 6E20696E2076383620-
  4368 000004BF 6D6F646524         
  4369 000004C4 7638362068616C7420-     str_v86_hlt_cli:db		'v86 halt with interrupts disabled$'
  4370 000004CD 7769746820696E7465-
  4371 000004D6 727275707473206469-
  4372 000004DF 7361626C656424     
  4373 000004E6 496E617070726F7072-     str_v86_secret:	db		'Inappropriate use of v86 secret handshake$'
  4374 000004EF 696174652075736520-
  4375 000004F8 6F6620763836207365-
  4376 00000501 637265742068616E64-
  4377 0000050A 7368616B6524       
  4378 00000510 53687574646F776E20-     str_exit_to_dos:db		'Shutdown successful, exiting to DOS$'
  4379 00000519 737563636573736675-
  4380 00000522 6C2C2065786974696E-
  4381 0000052B 6720746F20444F5324 
  4382 00000534 556E6B6E6F776E2049-     str_unknown_irq:db		'Unknown IRQ$'
  4383 0000053D 525124             
  4384 00000540 446566657272656420-     str_irq_deferred:db		'Deferred IRQ$'
  4385 00000549 49525124           
  4386 0000054D 49525120233124          str_irq_1:	db		'IRQ #1$'
  4387 00000554 537461636B206F7665-     str_stack_overflow:db		'Stack overflow$'
  4388 0000055D 72666C6F7724       
  4389 00000563 457874656E64656420-     str_himem_corruption:db		'Extended memory corruption$'
  4390 0000056C 6D656D6F727920636F-
  4391 00000575 7272757074696F6E24 
  4392 0000057E 556E65787065637465-     str_unexpected_int_not_v86:db	'Unexpected: IRQ not from within v86$'
  4393 00000587 643A20495251206E6F-
  4394 00000590 742066726F6D207769-
  4395 00000599 7468696E2076383624 
  4396 000005A2 556E6B6E6F776E2045-     str_unknown_emm_vcpi_call:db	'Unknown EMM/VCPI call$'
  4397 000005AB 4D4D2F564350492063-
  4398 000005B4 616C6C24           
  4399 000005B8 556E6B6E6F776E2056-     str_unknown_emm_vcpi_pm_call:db	'Unknown VCPI entry point call$'
  4400 000005C1 43504920656E747279-
  4401 000005CA 20706F696E74206361-
  4402 000005D3 6C6C24             
  4403 000005D6 564350492070616765-     str_vcpi_alloc_page_bug:db	'VCPI page allocation bug check$'
  4404 000005DF 20616C6C6F63617469-
  4405 000005E8 6F6E20627567206368-
  4406 000005F1 65636B24           
  4407 000005F5 564350492070726F74-     str_vcpi_pm_not_supported:db	'VCPI protected mode not implemented$'
  4408 000005FE 6563746564206D6F64-
  4409 00000607 65206E6F7420696D70-
  4410 00000610 6C656D656E74656424 
  4411                                  
  4412                                  ; ============= EMM/VCPI entry point redirection and "signature"
  4413 00000619 90<rept>                		align		16
  4414 00000620 B484                    rm_int_67_entry:mov		ah,0x84		; AH=0x84 means "not defined"
  4415 00000622 CF                      		iret
  4416 00000623 90                      		nop
  4417 00000624 90                      		nop
  4418 00000625 90                      		nop
  4419 00000626 90                      		nop
  4420 00000627 90                      		nop
  4421 00000628 90                      		nop
  4422 00000629 90                      		nop
  4423 0000062A 454D4D585858583000      rm_int_67_sig:	db		'EMMXXXX0',0	; DOS programs look for this signature relative to INT 67h segment
  4424                                  
  4425                                  ; ============= VARIABLES: THESE DO NOT EXIST IN THE .COM FILE THEY EXIST IN MEMORY FOLLOWING THE BINARY IMAGE
  4426                                  		section		.bss align=2
  4427                                  		align		8
  4428                                  ; ---------------------- STACK
  4429 00000000 <res 00001000>          stack_base:	resb		4096		; char[4096+4]
  4430 00001000 <res 00000004>          stack_init:	resd		1		; DWORD
  4431                                  stack_top:
  4432 00001004 <res 00000040>          scratch_str:	resb		64		; char[64]
  4433                                  ; ---------------------- STACK
  4434 00001044 <res 00001000>          stack_base_vm86:resb		4096		; char[4096+4]
  4435 00002044 <res 00000008>          stack_init_vm86:resd		2		; DWORD
  4436                                  stack_top_vm86:
  4437                                  ; ---------------------- HIMEM.SYS state
  4438 0000204C <res 00000004>          himem_sys_entry:resd		1		; FAR POINTER
  4439 00002050 <res 00000004>          himem_sys_buffer_phys:resd	1		; DWORD [physical memory address]
  4440 00002054 <res 00000002>          himem_sys_buffer_handle:resw	1		; WORD [HIMEM.SYS handle]
  4441                                  ; ---------------------- my real mode segment
  4442 00002056 <res 00000002>          my_realmode_seg:resw		1		; WORD
  4443 00002058 <res 00000004>          my_phys_base:	resd		1		; DWORD
  4444 0000205C <res 00000004>          tss_phys_base:	resd		1		; DWORD base logical address of TSS
  4445 00002060 <res 00000004>          tss_vm86_phys_base:resd		1		; DWORD base logical address of TSS
  4446 00002064 <res 00000004>          v86_raw_opcode:	resd		1		; DWORD
  4447                                  ; ---------------------- GDTR/IDTR
  4448 00002068 <res 00000008>          gdtr_pmode:	resq		1		; LIMIT. BASE
  4449 00002070 <res 00000008>          gdtr_real:	resq		1		; LIMIT, BASE
  4450 00002078 <res 00000008>          idtr_pmode:	resq		1		; LIMIT, BASE
  4451 00002080 <res 00000008>          idtr_real:	resq		1		; LIMIT, BASE
  4452                                  ; ---------------------- STATE
  4453 00002088 <res 00000002>          irq_pending:	resw		1
  4454 0000208A <res 00000001>          user_req_unload:resb		1
  4455 0000208B <res 00000001>          v86_if:		resb		1
  4456                                  ; ---------------------- GLOBAL DESCRIPTOR TABLE
  4457 0000208C <res 00000004>          		resd		1
  4458                                  		align		8
  4459 00002090 <res 00000050>          gdt:		resq		(MAX_SEL/8)	; 16 GDT entries
  4460                                  ; ---------------------- INTERRUPT DESCRIPTOR TABLE
  4461                                  		align		8
  4462 000020E0 <res 00000800>          idt:		resq		256		; all 256
  4463                                  ; ---------------------- STATE
  4464 000028E0 <res 00000001>          user_req_iopl:	resb		1
  4465 000028E1 <res 00000001>          i_am_tsr:	resb		1
  4466 000028E2 <res 00000004>          unload_int_ret:	resd		1
  4467 000028E6 <res 00000004>          unload_int_stk:	resd		1
  4468                                  ; ---------------------- VCPI allocation map and pages
  4469 000028EA <res 00000004>          vcpi_alloc_bitmap_phys:resd		1
  4470 000028EE <res 00000004>          vcpi_alloc_bitmap_size:resd		1
  4471 000028F2 <res 00000004>          vcpi_alloc_pages_phys:resd		1
  4472                                  ; ---------------------- WHEN DISPLAYING THE UNHANDLED FAULT DIALOG
  4473 000028F6 <res 00000004>          unhandled_fault_var_errcode:resd	1
  4474 000028FA <res 00000004>          unhandled_fault_var_eax:resd		1
  4475 000028FE <res 00000004>          unhandled_fault_var_ebx:resd		1
  4476 00002902 <res 00000004>          unhandled_fault_var_ecx:resd		1
  4477 00002906 <res 00000004>          unhandled_fault_var_edx:resd		1
  4478 0000290A <res 00000004>          unhandled_fault_var_esi:resd		1
  4479 0000290E <res 00000004>          unhandled_fault_var_edi:resd		1
  4480 00002912 <res 00000004>          unhandled_fault_var_ebp:resd		1
  4481 00002916 <res 00000004>          unhandled_fault_var_esp:resd		1
  4482 0000291A <res 00000004>          unhandled_fault_var_eip:resd		1
  4483 0000291E <res 00000004>          unhandled_fault_var_eflags:resd		1
  4484 00002922 <res 00000004>          unhandled_fault_var_cr0:resd		1
  4485 00002926 <res 00000004>          unhandled_fault_var_cr3:resd		1
  4486 0000292A <res 00000004>          unhandled_fault_var_cr4:resd		1
  4487 0000292E <res 00000002>          unhandled_fault_var_cs:resw		1
  4488 00002930 <res 00000002>          unhandled_fault_var_ds:resw		1
  4489 00002932 <res 00000002>          unhandled_fault_var_es:resw		1
  4490 00002934 <res 00000002>          unhandled_fault_var_fs:resw		1
  4491 00002936 <res 00000002>          unhandled_fault_var_gs:resw		1
  4492 00002938 <res 00000002>          unhandled_fault_var_ss:resw		1
  4493 0000293A <res 00000004>          unhandled_fault_var_opcode:resd		1
  4494                                  ; ---------------------- TSS
  4495 0000293E <res 00000080>          tss_main:	resb		128
  4496                                  ; ---------------------- VM86 TSS
  4497 000029BE <res 00002080>          tss_vm86:	resb		8192+128
  4498                                  ; ---------------------------------------------------------------------
  4499                                  ;                       END POINTER
  4500                                  ; ---------------------------------------------------------------------
  4501 00004A3E <res 00000010>          padding:	resq		2		; SAFETY PADDING
  4502                                  the_end:
