     1                                  ; v86kern.asm
     2                                  ;
     3                                  ; Test program: Proof-of-concept minimalist virtual 8086 "monitor"
     4                                  ; (C) 2010-2012 Jonathan Campbell.
     5                                  ; Hackipedia DOS library.
     6                                  ;
     7                                  ; This code is licensed under the LGPL.
     8                                  ; <insert LGPL legal text here>
     9                                  ;
    10                                  ; MODE: 16-bit real mode MS-DOS .COM executable
    11                                  ; *THIS CODE IS OBSOLETE*
    12                                  ;       Assumes DS == ES == SS
    13                                  
    14                                  ; NOTES:
    15                                  ;   - This works... for the most part.
    16                                  ;   - Somehow this works even with DOSBox's funky ROM-based interrupt emulation
    17                                  ;   - The emulation provided is sufficient for real-mode exceptions including INT 3h debug and
    18                                  ;     INT 1h trace. It also handles the correct exception to permit v86 programs to use the
    19                                  ;     FPU if present.
    20                                  ; FIXME:
    21                                  ;   - Privileged instructions like mov cr0,<reg> trigger an exception and this program makes no
    22                                  ;     attempt to emulate those instructions.
    23                                  ;   - This code makes no attempt to emulate the LDT manipulation that most BIOS implementations
    24                                  ;     apparently like to do when handling INT 15H extended memory copy. Programs that use extended
    25                                  ;     memory via HIMEM.SYS or via INT 15H will crash.
    26                                  ;   - For reasons unknown to me, running this under Windows 95 pure DOS mode is crashy. It will run
    27                                  ;     for awhile but eventually, things will hang. Under QEMU, running another program or a 3rd
    28                                  ;     will trigger a sudden reset, which mirrors behavior seen on an actual Pentium system. For
    29                                  ;     other unknown reasons, Bochs and DOSBox run this code just fine.
    30                                  ;   - Whatever the BIOS does in response to CTRL+ALT+DEL it doesn't work well when we are active.
    31                                  ;
    32                                  ; This code manages virtual 8086 mode in a suboptimal way. A better implementation is provided in
    33                                  ; v86kern2.asm
    34                                  ;
    35                                  ; FIXME: Okay now this is crashing. Why?
    36                                  
    37                                  ; Standard selectors in protected mode
    38                                  NULL_SEL	equ		(0 << 3)
    39                                  CODE16_SEL	equ		(1 << 3)
    40                                  DATA16_SEL	equ		(2 << 3)
    41                                  CODE32_SEL	equ		(3 << 3)
    42                                  DATA32_SEL	equ		(4 << 3)
    43                                  FLAT16_SEL	equ		(5 << 3)
    44                                  FLAT32_SEL	equ		(6 << 3)
    45                                  LDT_SEL		equ		(7 << 3)
    46                                  TSS_SEL		equ		(8 << 3)
    47                                  TSS_VM86_SEL	equ		(9 << 3)
    48                                  MAX_SEL		equ		(10 << 3)
    49                                  
    50                                  ; We reprogram the PIC to direct IRQ 0-15 to this base interrupt
    51                                  IRQ_BASE_INT	equ		0x68
    52                                  RM_INT_API	equ		0x66
    53                                  
    54                                  ; Extensible virtual 8086 mode kernel for DOS
    55                                  ; (C) 2011 Jonathan Campbell
    56                                  
    57                                  		bits		16
    58                                  		section		.code
    59                                  		[map		v86kern.map]
    60                                  		org		0x100
    61                                  
    62                                  ; ============= ENTRY POINT
    63 00000000 8CC8                    		mov		ax,cs
    64 00000002 A3[5620]                		mov		word [my_realmode_seg],ax
    65 00000005 BD[0000]                		mov		bp,stack_base
    66 00000008 BC[0010]                		mov		sp,stack_init			; SP is normally at 0xFFF0 so move it back down
    67 0000000B C706[5420]0000          		mov		word [himem_sys_buffer_handle],0
    68 00000011 C606[EB28]00            		mov		byte [user_req_unload],0
    69 00000016 C606[EC28]03            		mov		byte [user_req_iopl],3
    70 0000001B C606[E828]00            		mov		byte [irq_pending],0
    71 00000020 C606[ED28]00            		mov		byte [i_am_tsr],0
    72 00000025 C606[EA28]00            		mov		byte [v86_if],0
    73 0000002A EB4E                    		jmp		_entry
    74                                  
    75                                  ; ============= CPU DETECT
    76 0000002C 9C                      cpu_is_386:	pushf
    77 0000002D 58                      		pop		ax
    78 0000002E 25FF0F                  		and		ax,0x0FFF
    79 00000031 50                      		push		ax
    80 00000032 9D                      		popf
    81 00000033 9C                      		pushf
    82 00000034 58                      		pop		ax
    83 00000035 2500F0                  		and		ax,0xF000
    84 00000038 3D00F0                  		cmp		ax,0xF000
    85 0000003B 740F                    		jz		cpu_is_386_not
    86                                  ; 286 test: EFLAGS will always have bits 12-15 clear
    87 0000003D 0D00F0                  		or		ax,0xF000
    88 00000040 50                      		push		ax
    89 00000041 9D                      		popf
    90 00000042 9C                      		pushf
    91 00000043 58                      		pop		ax
    92 00000044 2500F0                  		and		ax,0xF000
    93 00000047 7403                    		jz		cpu_is_386_not
    94                                  ; it's a 386
    95 00000049 31C0                    		xor		ax,ax			; ZF=1
    96 0000004B C3                      		ret
    97 0000004C B80100                  cpu_is_386_not:	mov		ax,1
    98 0000004F 09C0                    		or		ax,ax			; ZF=0
    99 00000051 C3                      		ret
   100                                  
   101                                  ; ============= EXIT WITH MESSAGE ($-terminated string at DS:DX)
   102 00000052 B409                    _exit_with_msg:	mov		ah,9
   103 00000054 CD21                    		int		21h			; fall through to _exit
   104                                  ; ============= EXIT
   105 00000056 8CC8                    _exit:		mov		ax,cs
   106 00000058 8ED8                    		mov		ds,ax
   107 0000005A 833E[5420]00            		cmp		word [himem_sys_buffer_handle],0 ; if there is a handle to free, then do it
   108 0000005F 7414                    		jz		.no_handle
   109 00000061 B40D                    		mov		ah,0Dh			; HIMEM.SYS function 0Dh unlock memory block
   110 00000063 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
   111 00000067 FF1E[4C20]              		call far	word [himem_sys_entry]
   112 0000006B B40A                    		mov		ah,0Ah			; HIMEM.SYS function 0Ah free memory block
   113 0000006D 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
   114 00000071 FF1E[4C20]              		call far	word [himem_sys_entry]
   115 00000075 B8004C                  .no_handle:	mov		ax,4C00h
   116 00000078 CD21                    		int		21h
   117                                  
   118                                  ; ============= PROGRAM STARTS HERE
   119 0000007A E83110                  _entry:		call		parse_argv
   120 0000007D 7406                    		jz		.argv_ok
   121 0000007F BA[6D01]                		mov		dx,str_help
   122 00000082 E8CDFF                  		call		_exit_with_msg
   123 00000085 E8A4FF                  .argv_ok:	call		cpu_is_386		; CHECK: 386 or higher
   124 00000088 7405                    		jz		.is386
   125 0000008A BA[0400]                		mov		dx,str_require_386
   126 0000008D EBC3                    		jmp		_exit_with_msg
   127 0000008F 803E[EB28]00            .is386:		cmp		byte [user_req_unload],0; CHECK: Did user request that we unload?
   128 00000094 7403                    		jz		.not_unload
   129 00000096 E92C12                  		jmp		unload_this_program
   130 00000099 0F01E0                  .not_unload:	smsw		ax			; CHECK: Virtual 8086 mode not already enabled
   131 0000009C A801                    		test		al,1
   132 0000009E 7405                    		jz		.not_v86
   133 000000A0 BA[3200]                		mov		dx,str_v86_detected
   134 000000A3 EBAD                    		jmp		_exit_with_msg
   135 000000A5 66813E[0000]000001-     .not_v86:	cmp		dword [himem_sys_buffer_size],64*1024	; CHECK: buffer size is 64KB or larger
   136 000000AD 00                 
   137 000000AE 7D05                    		jge		.buffer_size_large_enough
   138 000000B0 BA[2101]                		mov		dx,str_buffer_too_small
   139 000000B3 EB9D                    		jmp		_exit_with_msg
   140                                  .buffer_size_large_enough:
   141 000000B5 66813E[0000]000000-     		cmp		dword [himem_sys_buffer_size],16*1024*1024
   142 000000BD 01                 
   143 000000BE 7E05                    		jle		.buffer_size_small_enough
   144 000000C0 BA[3201]                		mov		dx,str_buffer_too_large
   145 000000C3 EB8D                    		jmp		_exit_with_msg
   146                                  .buffer_size_small_enough:
   147 000000C5 B80043                  		mov		ax,4300h		; CHECK: HIMEM.SYS is present
   148 000000C8 CD2F                    		int		2Fh
   149 000000CA 3C80                    		cmp		al,80h
   150 000000CC 7406                    		jz		.yes_himem_sys
   151 000000CE BA[AB00]                		mov		dx,str_need_himem_sys
   152 000000D1 E97EFF                  		jmp		_exit_with_msg
   153 000000D4 B81043                  .yes_himem_sys:	mov		ax,4310h		; Get HIMEM.SYS entry point (cannot fail)
   154 000000D7 CD2F                    		int		2Fh
   155 000000D9 891E[4C20]              		mov		word [himem_sys_entry],bx
   156 000000DD 8C06[4E20]              		mov		word [himem_sys_entry+2],es
   157 000000E1 B405                    		mov		ah,5h			; HIMEM.SYS Local Enable A20
   158 000000E3 FF1E[4C20]              		call far	word [himem_sys_entry]
   159 000000E7 83F801                  		cmp		ax,1
   160 000000EA 7406                    		jz		.yes_himem_a20
   161 000000EC BA[C300]                		mov		dx,str_himem_a20_error
   162 000000EF E960FF                  		jmp		_exit_with_msg
   163 000000F2 B409                    .yes_himem_a20:	mov		ah,09h			; HIMEM.SYS allocate block
   164 000000F4 FA                      		cli					; <- in case BIOS interrupts do not save upper 16 bits
   165 000000F5 668B16[0000]            		mov		edx,[himem_sys_buffer_size]
   166 000000FA 6681C2FF030000          		add		edx,1023
   167 00000101 66C1EA0A                		shr		edx,10			; EDX = (X BYTES+1023)/1024 KB
   168 00000105 FF1E[4C20]              		call far	word [himem_sys_entry]
   169 00000109 83F801                  		cmp		ax,1
   170 0000010C 7406                    		jz		.yes_himem_buf
   171 0000010E BA[E200]                		mov		dx,str_himem_alloc_err
   172 00000111 E93EFF                  		jmp		_exit_with_msg
   173 00000114 8916[5420]              .yes_himem_buf:	mov		word [himem_sys_buffer_handle],dx ; store memory handle
   174 00000118 B40C                    		mov		ah,0Ch			; HIMEM.SYS lock memory block
   175 0000011A FF1E[4C20]              		call far	word [himem_sys_entry]	; NOTE: DX = memory handle (still)
   176 0000011E 83F801                  		cmp		ax,1
   177 00000121 7406                    		jz		.yes_himem_lock
   178 00000123 BA[0201]                		mov		dx,str_himem_lock_err
   179 00000126 E929FF                  		jmp		_exit_with_msg
   180 00000129 891E[5020]              .yes_himem_lock:mov		word [himem_sys_buffer_phys],bx	; store DX:BX physical memory address
   181 0000012D 8916[5220]              		mov		word [himem_sys_buffer_phys+2],dx
   182                                  
   183                                  ; choose where things go within the buffer
   184                                  ;        = 104 bytes for main TSS
   185 00000131 66A1[5020]              		mov		eax,[himem_sys_buffer_phys]
   186 00000135 66A3[5C20]              		mov		[tss_phys_base],eax
   187 00000139 660580000000            		add		eax,128
   188                                  ;        = 8192+104 bytes for VM86 TSS
   189 0000013F 66A3[6020]              		mov		[tss_vm86_phys_base],eax
   190 00000143 660580200000            		add		eax,8192+128
   191                                  ;        = 4096 for kernel 32 stack
   192 00000149 66A3[6820]              		mov		[kern32_stack_base],eax
   193 0000014D 660500100000            		add		eax,4096
   194 00000153 66678D58F8              		lea		ebx,[eax-8]
   195 00000158 66891E[6C20]            		mov		[kern32_stack_top],ebx
   196                                  ;        = store it for future allocation
   197 0000015D 66A3[6420]              		mov		[buffer_alloc],eax
   198                                  
   199                                  ; PRINT "BUFFER AT: " + *((DWORD*)himem_sys_buffer_phys) + "\n"
   200 00000161 BA[4E01]                		mov		dx,str_buffer_at
   201 00000164 E8CA10                  		call		dos_puts
   202 00000167 FA                      		cli
   203 00000168 66A1[5020]              		mov		eax,[himem_sys_buffer_phys]
   204 0000016C BF[0410]                		mov		di,scratch_str
   205 0000016F E83511                  		call		eax_to_hex_16_dos
   206 00000172 89FA                    		mov		dx,di
   207 00000174 E8BA10                  		call		dos_puts
   208                                  
   209 00000177 FA                      		cli
   210 00000178 66A1[5020]              		mov		eax,[himem_sys_buffer_phys]
   211 0000017C 660306[0000]            		add		eax,[himem_sys_buffer_size]
   212 00000181 6648                    		dec		eax
   213 00000183 C606[0410]2D            		mov		byte [scratch_str],'-'
   214 00000188 BF[0510]                		mov		di,scratch_str+1
   215 0000018B E81911                  		call		eax_to_hex_16_dos
   216 0000018E BA[0410]                		mov		dx,scratch_str
   217 00000191 E89D10                  		call		dos_puts
   218                                  
   219 00000194 BA[5A01]                		mov		dx,str_crlf
   220 00000197 E89710                  		call		dos_puts
   221                                  
   222 0000019A 6631C0                  		xor		eax,eax
   223 0000019D 8CC8                    		mov		ax,cs
   224 0000019F 8EC0                    		mov		es,ax
   225 000001A1 66C1E004                		shl		eax,4
   226 000001A5 66A3[5820]              		mov		dword [my_phys_base],eax
   227                                  
   228                                  ; clear the IDT and GDT
   229 000001A9 FC                      		cld
   230 000001AA 31C0                    		xor		ax,ax
   231                                  
   232 000001AC B92800                  		mov		cx,MAX_SEL / 2
   233 000001AF BF[9820]                		mov		di,gdt
   234 000001B2 F3AB                    		rep		stosw
   235                                  
   236                                  ; prepare the IDTR and GDTR.
   237                                  ; real mode versions: limit=0xFFFF base=0
   238 000001B4 6631C0                  		xor		eax,eax
   239 000001B7 48                      		dec		ax			; AX = 0xFFFF
   240 000001B8 A3[9020]                		mov		word [idtr_real],ax
   241 000001BB A3[8020]                		mov		word [gdtr_real],ax
   242 000001BE 40                      		inc		ax
   243 000001BF 66A3[9220]              		mov		dword [idtr_real+2],eax
   244 000001C3 66A3[8220]              		mov		dword [gdtr_real+2],eax
   245                                  ; protected mode GDTR limit=MAX_SEL-1 base=(code segment)+var
   246 000001C7 C706[7820]4F00          		mov		word [gdtr_pmode],MAX_SEL - 1
   247 000001CD C706[8820]FF07          		mov		word [idtr_pmode],(256 << 3) - 1
   248 000001D3 66A1[5820]              		mov		eax,[my_phys_base]
   249 000001D7 6605[98200000]          		add		eax,gdt
   250 000001DD 66A3[7A20]              		mov		dword [gdtr_pmode+2],eax
   251 000001E1 66A1[5820]              		mov		eax,[my_phys_base]
   252 000001E5 6605[E8200000]          		add		eax,idt
   253 000001EB 66A3[8A20]              		mov		dword [idtr_pmode+2],eax
   254                                  
   255                                  ; build the GDT
   256 000001EF FC                      		cld
   257 000001F0 8D3E[A020]              		lea		di,[gdt+CODE16_SEL]
   258                                  ; Code selector (CODE_16SEL)
   259 000001F4 48                      		dec		ax			; 0x0000 - 1 = 0xFFFF
   260 000001F5 AB                      		stosw					; LIMIT
   261 000001F6 A1[5820]                		mov		ax,[my_phys_base]
   262 000001F9 AB                      		stosw					; BASE[15:0]
   263 000001FA A0[5A20]                		mov		al,[my_phys_base+2]
   264 000001FD B49A                    		mov		ah,0x9A
   265 000001FF AB                      		stosw					; BASE[23:16] access byte=executable readable
   266 00000200 B00F                    		mov		al,0x0F
   267 00000202 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   268 00000206 AB                      		stosw
   269                                  ; Data selector (DATA16_SEL)
   270 00000207 31C0                    		xor		ax,ax
   271 00000209 48                      		dec		ax			; 0xFFFF
   272 0000020A AB                      		stosw					; LIMIT
   273 0000020B A1[5820]                		mov		ax,[my_phys_base]
   274 0000020E AB                      		stosw					; BASE[15:0]
   275 0000020F A0[5A20]                		mov		al,[my_phys_base+2]
   276 00000212 B492                    		mov		ah,0x92
   277 00000214 AB                      		stosw					; BASE[23:16] access byte=data writeable
   278 00000215 B00F                    		mov		al,0x0F
   279 00000217 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   280 0000021B AB                      		stosw
   281                                  ; Code selector (CODE_32SEL)
   282 0000021C 48                      		dec		ax			; 0x0000 - 1 = 0xFFFF
   283 0000021D AB                      		stosw					; LIMIT
   284 0000021E A1[5820]                		mov		ax,[my_phys_base]
   285 00000221 AB                      		stosw					; BASE[15:0]
   286 00000222 A0[5A20]                		mov		al,[my_phys_base+2]
   287 00000225 B49A                    		mov		ah,0x9A
   288 00000227 AB                      		stosw					; BASE[23:16] access byte=executable readable
   289 00000228 B0CF                    		mov		al,0xCF
   290 0000022A 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   291 0000022E AB                      		stosw
   292                                  ; Data selector (DATA32_SEL)
   293 0000022F 31C0                    		xor		ax,ax
   294 00000231 48                      		dec		ax			; 0xFFFF
   295 00000232 AB                      		stosw					; LIMIT
   296 00000233 A1[5820]                		mov		ax,[my_phys_base]
   297 00000236 AB                      		stosw					; BASE[15:0]
   298 00000237 A0[5A20]                		mov		al,[my_phys_base+2]
   299 0000023A B492                    		mov		ah,0x92
   300 0000023C AB                      		stosw					; BASE[23:16] access byte=data writeable
   301 0000023D B0CF                    		mov		al,0xCF
   302 0000023F 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   303 00000243 AB                      		stosw
   304                                  ; Data selector (FLAT16_SEL)
   305 00000244 31C0                    		xor		ax,ax
   306 00000246 48                      		dec		ax			; 0xFFFF
   307 00000247 AB                      		stosw					; LIMIT
   308 00000248 31C0                    		xor		ax,ax
   309 0000024A AB                      		stosw					; BASE[15:0]
   310 0000024B B492                    		mov		ah,0x92
   311 0000024D AB                      		stosw					; BASE[23:16] access byte=data writeable
   312 0000024E B08F                    		mov		al,0x8F
   313 00000250 30E4                    		xor		ah,ah
   314 00000252 AB                      		stosw
   315                                  ; Data selector (FLAT32_SEL)
   316 00000253 31C0                    		xor		ax,ax
   317 00000255 48                      		dec		ax			; 0xFFFF
   318 00000256 AB                      		stosw					; LIMIT
   319 00000257 31C0                    		xor		ax,ax
   320 00000259 AB                      		stosw					; BASE[15:0]
   321 0000025A B492                    		mov		ah,0x92
   322 0000025C AB                      		stosw					; BASE[23:16] access byte=data writeable
   323 0000025D B0CF                    		mov		al,0xCF
   324 0000025F 30E4                    		xor		ah,ah
   325 00000261 AB                      		stosw
   326                                  ; LDT selector (LDT_SEL)
   327 00000262 B80700                  		mov		ax,7			; I have no use for the LDT
   328 00000265 AB                      		stosw					; LIMIT
   329 00000266 A1[5820]                		mov		ax,[my_phys_base]
   330 00000269 AB                      		stosw					; BASE[15:0]
   331 0000026A A0[5A20]                		mov		al,[my_phys_base+2]
   332 0000026D B482                    		mov		ah,0x82
   333 0000026F AB                      		stosw					; BASE[23:16] access byte=data writeable LDT type 2
   334 00000270 B00F                    		mov		al,0x0F
   335 00000272 8A26[5B20]              		mov		ah,[my_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   336 00000276 AB                      		stosw
   337                                  ; TSS selector (TSS_SEL)
   338 00000277 B86700                  		mov		ax,104-1
   339 0000027A AB                      		stosw					; LIMIT
   340 0000027B A1[5C20]                		mov		ax,[tss_phys_base]
   341 0000027E AB                      		stosw					; BASE[15:0]
   342 0000027F A0[5E20]                		mov		al,[tss_phys_base+2]
   343 00000282 B489                    		mov		ah,0x89
   344 00000284 AB                      		stosw					; BASE[23:16] access byte=data writeable non-busy TSS type 9
   345 00000285 B00F                    		mov		al,0x0F
   346 00000287 8A26[5F20]              		mov		ah,[tss_phys_base+3]	; LIMIT[19:16] flags=0 BASE[31:24]
   347 0000028B AB                      		stosw
   348                                  ; TSS selector (TSS_VM86_SEL)
   349 0000028C B86720                  		mov		ax,104+8192-1
   350 0000028F AB                      		stosw					; LIMIT
   351 00000290 A1[6020]                		mov		ax,[tss_vm86_phys_base]
   352 00000293 AB                      		stosw					; BASE[15:0]
   353 00000294 A0[6220]                		mov		al,[tss_vm86_phys_base+2]
   354 00000297 B489                    		mov		ah,0x89
   355 00000299 AB                      		stosw					; BASE[23:16] access byte=data writeable non-busy TSS type 9
   356 0000029A B00F                    		mov		al,0x0F
   357 0000029C 8A26[6320]              		mov		ah,[tss_vm86_phys_base+3] ; LIMIT[19:16] flags=0 BASE[31:24]
   358 000002A0 AB                      		stosw
   359                                  
   360                                  ; prepare the CPU registers
   361 000002A1 0F011E[8820]            		lidt		[idtr_pmode]
   362 000002A6 0F0116[7820]            		lgdt		[gdtr_pmode]
   363                                  
   364                                  ; enter protected mode
   365 000002AB 66B801000000            		mov		eax,1
   366 000002B1 0F22C0                  		mov		cr0,eax
   367 000002B4 EA[B902]0800            		jmp		CODE16_SEL:pmode16_entry
   368 000002B9 B81000                  pmode16_entry:	mov		ax,DATA16_SEL
   369 000002BC 8ED8                    		mov		ds,ax
   370 000002BE 8EC0                    		mov		es,ax
   371 000002C0 8EE0                    		mov		fs,ax
   372 000002C2 8EE8                    		mov		gs,ax
   373 000002C4 8ED0                    		mov		ss,ax
   374 000002C6 BC[0010]                		mov		sp,stack_init
   375                                  
   376                                  ; load task register
   377 000002C9 B84000                  		mov		ax,TSS_SEL
   378 000002CC 0F00D8                  		ltr		ax
   379                                  
   380                                  ; load LDT
   381 000002CF B83800                  		mov		ax,LDT_SEL
   382 000002D2 0F00D0                  		lldt		ax
   383                                  
   384                                  ; now enter 32-bit protected mode
   385 000002D5 EA[DA02]1800            		jmp		CODE32_SEL:pmode32_entry
   386                                  		bits		32
   387 000002DA 66B82000                pmode32_entry:	mov		ax,DATA32_SEL
   388 000002DE 8ED8                    		mov		ds,ax
   389 000002E0 8EC0                    		mov		es,ax
   390 000002E2 8ED0                    		mov		ss,ax
   391 000002E4 66B83000                		mov		ax,FLAT32_SEL
   392 000002E8 8EE0                    		mov		fs,ax
   393 000002EA 8EE8                    		mov		gs,ax
   394 000002EC BC[00100000]            		mov		esp,stack_init
   395                                  ; at this point: we are in 32-bit protected mode!
   396                                  
   397                                  ; ============= setup the TSS representing our task (for when we return)
   398 000002F1 FC                      		cld
   399 000002F2 8B3D[5C200000]          		mov		edi,[tss_phys_base]
   400 000002F8 2B3D[58200000]          		sub		edi,[my_phys_base]
   401                                  
   402 000002FE 31C0                    		xor		eax,eax					; TSS+0x00 = no backlink
   403 00000300 AB                      		stosd
   404 00000301 A1[6C200000]            		mov		eax,[kern32_stack_top]			; TSS+0x04 = ESP for CPL0
   405 00000306 2B05[58200000]          		sub		eax,[my_phys_base]
   406 0000030C AB                      		stosd
   407 0000030D B820000000              		mov		eax,DATA32_SEL				; TSS+0x08 = SS for CPL0
   408 00000312 AB                      		stosd
   409 00000313 A1[6C200000]            		mov		eax,[kern32_stack_top]			; TSS+0x0C = ESP for CPL1
   410 00000318 2B05[58200000]          		sub		eax,[my_phys_base]
   411 0000031E AB                      		stosd
   412 0000031F B820000000              		mov		eax,DATA32_SEL				; TSS+0x10 = SS for CPL1
   413 00000324 AB                      		stosd
   414 00000325 A1[6C200000]            		mov		eax,[kern32_stack_top]			; TSS+0x14 = ESP for CPL2
   415 0000032A 2B05[58200000]          		sub		eax,[my_phys_base]
   416 00000330 AB                      		stosd
   417 00000331 B820000000              		mov		eax,DATA32_SEL				; TSS+0x18 = SS for CPL2
   418 00000336 AB                      		stosd
   419 00000337 31C0                    		xor		eax,eax					; TSS+0x1C = CR3
   420 00000339 AB                      		stosd
   421 0000033A B8[B20F0000]            		mov		eax,vm86_entry				; TSS+0x20 = EIP
   422 0000033F AB                      		stosd
   423 00000340 B802000000              		mov		eax,0x00000002				; TSS+0x24 = EFLAGS VM=0
   424 00000345 AB                      		stosd
   425 00000346 31C0                    		xor		eax,eax					; TSS+0x28 = EAX
   426 00000348 AB                      		stosd
   427 00000349 31C0                    		xor		eax,eax					; TSS+0x2C = ECX
   428 0000034B AB                      		stosd
   429 0000034C 31C0                    		xor		eax,eax					; TSS+0x30 = EDX
   430 0000034E AB                      		stosd
   431 0000034F 31C0                    		xor		eax,eax					; TSS+0x34 = EBX
   432 00000351 AB                      		stosd
   433 00000352 B8[44200000]            		mov		eax,stack_init_vm86			; TSS+0x38 = ESP
   434 00000357 AB                      		stosd
   435 00000358 31C0                    		xor		eax,eax					; TSS+0x3C = EBP
   436 0000035A AB                      		stosd
   437 0000035B 31C0                    		xor		eax,eax					; TSS+0x40 = ESI
   438 0000035D AB                      		stosd
   439 0000035E 31C0                    		xor		eax,eax					; TSS+0x44 = EDI
   440 00000360 AB                      		stosd
   441 00000361 66B82000                		mov		ax,DATA32_SEL				; TSS+0x48 = ES
   442 00000365 AB                      		stosd
   443 00000366 66B81800                		mov		ax,CODE32_SEL				; TSS+0x4C = CS
   444 0000036A AB                      		stosd
   445 0000036B 66B82000                		mov		ax,DATA32_SEL				; TSS+0x50 = SS
   446 0000036F AB                      		stosd
   447 00000370 66B82000                		mov		ax,DATA32_SEL				; TSS+0x54 = DS
   448 00000374 AB                      		stosd
   449 00000375 66B82000                		mov		ax,DATA32_SEL				; TSS+0x58 = FS
   450 00000379 AB                      		stosd
   451 0000037A 66B82000                		mov		ax,DATA32_SEL				; TSS+0x5C = GS
   452 0000037E AB                      		stosd
   453 0000037F 31C0                    		xor		eax,eax					; TSS+0x60 = LDTR
   454 00000381 AB                      		stosd
   455 00000382 B800006800              		mov		eax,(104 << 16)				; TSS+0x64 = I/O map base
   456 00000387 AB                      		stosd
   457                                  
   458                                  ; ============= setup the TSS representing the virtual 8086 mode task
   459 00000388 FC                      		cld
   460 00000389 8B3D[60200000]          		mov		edi,[tss_vm86_phys_base]
   461 0000038F 2B3D[58200000]          		sub		edi,[my_phys_base]
   462                                  
   463 00000395 31C0                    		xor		eax,eax					; TSS+0x00 = no backlink
   464 00000397 AB                      		stosd
   465 00000398 A1[6C200000]            		mov		eax,[kern32_stack_top]			; TSS+0x04 = ESP for CPL0
   466 0000039D 2B05[58200000]          		sub		eax,[my_phys_base]
   467 000003A3 AB                      		stosd
   468 000003A4 B820000000              		mov		eax,DATA32_SEL				; TSS+0x08 = SS for CPL0
   469 000003A9 AB                      		stosd
   470 000003AA A1[6C200000]            		mov		eax,[kern32_stack_top]			; TSS+0x0C = ESP for CPL1
   471 000003AF 2B05[58200000]          		sub		eax,[my_phys_base]
   472 000003B5 AB                      		stosd
   473 000003B6 B820000000              		mov		eax,DATA32_SEL				; TSS+0x10 = SS for CPL1
   474 000003BB AB                      		stosd
   475 000003BC A1[6C200000]            		mov		eax,[kern32_stack_top]			; TSS+0x14 = ESP for CPL2
   476 000003C1 2B05[58200000]          		sub		eax,[my_phys_base]
   477 000003C7 AB                      		stosd
   478 000003C8 B820000000              		mov		eax,DATA32_SEL				; TSS+0x18 = SS for CPL2
   479 000003CD AB                      		stosd
   480 000003CE 31C0                    		xor		eax,eax					; TSS+0x1C = CR3
   481 000003D0 AB                      		stosd
   482 000003D1 B8[B20F0000]            		mov		eax,vm86_entry				; TSS+0x20 = EIP
   483 000003D6 AB                      		stosd
   484 000003D7 B802020200              		mov		eax,0x00020202				; TSS+0x24 = EFLAGS VM=1 IOPL=N IF=1
   485 000003DC 0FB61D[EC280000]        		movzx		ebx,byte [user_req_iopl]
   486 000003E3 80E303                  		and		bl,3
   487 000003E6 C1E30C                  		shl		ebx,12
   488 000003E9 09D8                    		or		eax,ebx					; EFLAGS |= user_req_iopl << 12
   489 000003EB AB                      		stosd
   490 000003EC 31C0                    		xor		eax,eax					; TSS+0x28 = EAX
   491 000003EE AB                      		stosd
   492 000003EF 31C0                    		xor		eax,eax					; TSS+0x2C = ECX
   493 000003F1 AB                      		stosd
   494 000003F2 31C0                    		xor		eax,eax					; TSS+0x30 = EDX
   495 000003F4 AB                      		stosd
   496 000003F5 31C0                    		xor		eax,eax					; TSS+0x34 = EBX
   497 000003F7 AB                      		stosd
   498 000003F8 B8[00100000]            		mov		eax,stack_init				; TSS+0x38 = ESP
   499 000003FD AB                      		stosd
   500 000003FE 31C0                    		xor		eax,eax					; TSS+0x3C = EBP
   501 00000400 AB                      		stosd
   502 00000401 31C0                    		xor		eax,eax					; TSS+0x40 = ESI
   503 00000403 AB                      		stosd
   504 00000404 31C0                    		xor		eax,eax					; TSS+0x44 = EDI
   505 00000406 AB                      		stosd
   506 00000407 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x48 = ES
   507 0000040D AB                      		stosd
   508 0000040E 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x4C = CS
   509 00000414 AB                      		stosd
   510 00000415 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x50 = SS
   511 0000041B AB                      		stosd
   512 0000041C 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x54 = DS
   513 00000422 AB                      		stosd
   514 00000423 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x58 = FS
   515 00000429 AB                      		stosd
   516 0000042A 66A1[56200000]          		mov		ax,[my_realmode_seg]			; TSS+0x5C = GS
   517 00000430 AB                      		stosd
   518 00000431 31C0                    		xor		eax,eax					; TSS+0x60 = LDTR
   519 00000433 AB                      		stosd
   520 00000434 B800006800              		mov		eax,(104 << 16)				; TSS+0x64 = I/O map base
   521 00000439 AB                      		stosd
   522 0000043A 31C0                    		xor		eax,eax
   523 0000043C B900080000              		mov		ecx,8192 >> 2				; TSS+0x68 = I/O permission map (pre-set to all open)
   524 00000441 F3AB                    		rep		stosd
   525                                  
   526                                  ; set up the IDT
   527 00000443 FC                      		cld
   528                                  
   529 00000444 B900010000              		mov		ecx,0x100
   530 00000449 BF[E8200000]            		mov		edi,idt
   531 0000044E 66B8[3F06]              .idtdef:	mov		ax,fault_no_int		; no interrupt assigned procedure
   532 00000452 66AB                    		stosw					; base[15:0]
   533 00000454 66B81800                		mov		ax,CODE32_SEL
   534 00000458 66AB                    		stosw
   535 0000045A 66B8008E                		mov		ax,0x8E00		; DPL=3
   536 0000045E 66AB                    		stosw
   537 00000460 6631C0                  		xor		ax,ax
   538 00000463 66AB                    		stosw
   539 00000465 E2E7                    		loop		.idtdef
   540                                  
   541 00000467 BE[85110000]            		mov		esi,fault_routines
   542 0000046C B920000000              		mov		ecx,0x20
   543 00000471 BF[E8200000]            		mov		edi,idt
   544 00000476 66AD                    .idtsetup:	lodsw
   545 00000478 66AB                    		stosw					; base[15:0]
   546 0000047A 66B81800                		mov		ax,CODE32_SEL
   547 0000047E 66AB                    		stosw
   548 00000480 66B8008E                		mov		ax,0x8E00		; DPL=3
   549 00000484 66AB                    		stosw
   550 00000486 6631C0                  		xor		ax,ax
   551 00000489 66AB                    		stosw
   552 0000048B E2E9                    		loop		.idtsetup
   553                                  
   554 0000048D FC                      		cld
   555 0000048E BE[65110000]            		mov		esi,irq_routines
   556 00000493 B910000000              		mov		ecx,0x10
   557 00000498 BF[28240000]            		mov		edi,idt + (IRQ_BASE_INT*8)
   558 0000049D 66AD                    .idtsetup2:	lodsw
   559 0000049F 66AB                    		stosw					; base[15:0]
   560 000004A1 66B81800                		mov		ax,CODE32_SEL
   561 000004A5 66AB                    		stosw
   562 000004A7 66B8008E                		mov		ax,0x8E00		; you must set DPL=3
   563 000004AB 66AB                    		stosw
   564 000004AD 6631C0                  		xor		ax,ax
   565 000004B0 66AB                    		stosw
   566 000004B2 E2E9                    		loop		.idtsetup2
   567                                  
   568                                  ; next we need to reprogram the PIC so that IRQ 0-7 do not conflict with the CPU exceptions.
   569                                  ; note for stability we only reprogram first PIC, since we do not relocate the 2nd PIC.
   570 000004B4 B010                    		mov		al,0x10			; ICW1 A0=0
   571 000004B6 E620                    		out		20h,al
   572 000004B8 B068                    		mov		al,IRQ_BASE_INT		; ICW2 A0=1
   573 000004BA E621                    		out		21h,al
   574 000004BC B004                    		mov		al,0x04			; ICW3 A0=1 slave on IRQ 2
   575 000004BE E621                    		out		21h,al
   576                                  
   577                                  ; jump into virtual 8086 mode
   578 000004C0 EA000000004800          		jmp		TSS_VM86_SEL:0
   579                                  
   580                                  ; =============== IRQ handler code
   581                                  
   582 000004C7 08090A0B0C0D0E0F        int_rm_map:	db		0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F
   583 000004CF 7071727374757677        		db		0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77
   584                                  
   585 000004D7 000108090A0B0C0D0E-     irq_priority:	db		0,1,8,9,10,11,12,13,14,15,2,3,4,5,6,7
   586 000004E0 0F020304050607     
   587                                  	; ^ 16 entries, reflecting IRQ 8-15 -> IRQ 2 (slave PIC) and IRQ 0-7 (master PIC) cascade
   588                                  
   589                                  ; EAX = IRQ that fired
   590                                  ;  [ESP+0] = old EAX
   591                                  ;  [ESP+4] = EIP
   592                                  ;  [ESP+8] = CS
   593                                  ;  [ESP+12] = EFLAGS
   594                                  ;  [ESP+16] = ESP
   595                                  ;  [ESP+20] = SS
   596                                  ;  [ESP+24] = ES
   597                                  ;  [ESP+28] = DS
   598                                  ;  [ESP+32] = FS
   599                                  ;  [ESP+36] = GS
   600 000004E7 F744240C00000200        irq_general:	test		dword [esp+12],0x20000	; did the interrupt happen while in v86 mode?
   601 000004EF 7514                    		jnz		.reflect_v86
   602                                  ; this happened while NOT in v86 mode. We should still reflect it back to v86 mode.
   603                                  ;   ----------------------TODO--------------------
   604 000004F1 E8BD070000              		call		fault_collect_regs
   605 000004F6 BA00000000              		mov		edx,0x00
   606 000004FB BE[F5040000]            		mov		esi,str_irq_1
   607 00000500 E97F080000              		jmp		fault_jmp_unhandled
   608                                  ;   ----------------------------------------------
   609                                  ; CPU was in v86 mode. Modify stack pointer to reflect the interrupt.
   610 00000505 F744240C00020000        .reflect_v86:	test		dword [esp+12],0x200	; are interrupts enabled in the vm?
   611 0000050D 7464                    		jz		.reflect_v86_pending	; if not, then we need to note it and reflect later
   612 0000050F 53                      		push		ebx
   613 00000510 51                      		push		ecx
   614 00000511 66BB3000                		mov		bx,FLAT32_SEL		; NTS: Don't worry about saving ES. The CPU saved
   615 00000515 8EDB                    		mov		ds,bx			; it as part of the v86 -> interrupt transition.
   616 00000517 31DB                    		xor		ebx,ebx
   617 00000519 89D9                    		mov		ecx,ebx
   618 0000051B 2E8A98[C7040000]        		mov		bl,[cs:int_rm_map+eax]	; IRQ -> interrupt
   619 00000522 8B1C9D00000000          		mov		ebx,[ebx*4]		; interrupt -> realmode vector
   620 00000529 668B44241C              		mov		ax,[esp+20+8]		; fetch SS
   621 0000052E C1E004                  		shl		eax,4			; EAX = SS*16
   622 00000531 668B4C2418              		mov		cx,[esp+16+8]		; fetch SP
   623 00000536 6683E906                		sub		cx,6			; SP -= 6
   624 0000053A 01C8                    		add		eax,ecx			; EAX = SS*16 + SP
   625 0000053C 66894C2418              		mov		[esp+16+8],cx		; store modified SP back
   626                                  ; EBX = realmode interrupt vector
   627                                  ; EAX = stack pointer (physical mem addr)
   628 00000541 668B4C240C              		mov		cx,[esp+4+8]		; fetch EIP
   629 00000546 668908                  		mov		word [eax+0],cx		; SS:SP = offset
   630 00000549 668B4C2410              		mov		cx,[esp+8+8]		; fetch CS
   631 0000054E 66894802                		mov		word [eax+2],cx		; SS:SP+2 = segment
   632 00000552 668B4C2414              		mov		cx,[esp+12+8]		; fetch FLAGS
   633 00000557 66894804                		mov		word [eax+4],cx		; SS:SP+4 = flags
   634 0000055B 66895C240C              		mov		[esp+4+8],bx		; overwrite IP = offset of vector
   635 00000560 C1EB10                  		shr		ebx,16
   636 00000563 66895C2410              		mov		[esp+8+8],bx		; overwrite CS = segment of vector
   637                                  
   638                                  ; *DEBUG*
   639 00000568 66FF0500800B00          		inc		word [0xB8000]
   640                                  
   641 0000056F 59                      		pop		ecx
   642 00000570 5B                      		pop		ebx
   643 00000571 58                      		pop		eax
   644 00000572 CF                      		iret
   645                                  ; v86 mode, but interrupts are disabled
   646                                  .reflect_v86_pending:
   647 00000573 53                      		push		ebx
   648 00000574 51                      		push		ecx
   649 00000575 66BB2000                		mov		bx,DATA32_SEL
   650 00000579 8EDB                    		mov		ds,bx
   651 0000057B 88C1                    		mov		cl,al			; CL = IRQ
   652 0000057D B801000000              		mov		eax,1
   653 00000582 D3E0                    		shl		eax,cl			; EAX = 1 << IRQ
   654 00000584 660905[E8280000]        		or		word [irq_pending],ax	; irq_pending |= 1 << IRQ
   655 0000058B 59                      		pop		ecx
   656 0000058C 5B                      		pop		ebx
   657 0000058D 58                      		pop		eax
   658 0000058E CF                      		iret
   659                                  
   660 0000058F 50                      irq_0:		push		eax
   661 00000590 B800000000              		mov		eax,0
   662 00000595 E94DFFFFFF              		jmp		irq_general
   663                                  
   664 0000059A 50                      irq_1:		push		eax
   665 0000059B B801000000              		mov		eax,1
   666 000005A0 E942FFFFFF              		jmp		irq_general
   667                                  
   668 000005A5 50                      irq_2:		push		eax
   669 000005A6 B802000000              		mov		eax,2
   670 000005AB E937FFFFFF              		jmp		irq_general
   671                                  
   672 000005B0 50                      irq_3:		push		eax
   673 000005B1 B803000000              		mov		eax,3
   674 000005B6 E92CFFFFFF              		jmp		irq_general
   675                                  
   676 000005BB 50                      irq_4:		push		eax
   677 000005BC B804000000              		mov		eax,4
   678 000005C1 E921FFFFFF              		jmp		irq_general
   679                                  
   680 000005C6 50                      irq_5:		push		eax
   681 000005C7 B805000000              		mov		eax,5
   682 000005CC E916FFFFFF              		jmp		irq_general
   683                                  
   684 000005D1 50                      irq_6:		push		eax
   685 000005D2 B806000000              		mov		eax,6
   686 000005D7 E90BFFFFFF              		jmp		irq_general
   687                                  
   688 000005DC 50                      irq_7:		push		eax
   689 000005DD B807000000              		mov		eax,7
   690 000005E2 E900FFFFFF              		jmp		irq_general
   691                                  
   692 000005E7 50                      irq_8:		push		eax
   693 000005E8 B808000000              		mov		eax,8
   694 000005ED E9F5FEFFFF              		jmp		irq_general
   695                                  
   696 000005F2 50                      irq_9:		push		eax
   697 000005F3 B809000000              		mov		eax,9
   698 000005F8 E9EAFEFFFF              		jmp		irq_general
   699                                  
   700 000005FD 50                      irq_10:		push		eax
   701 000005FE B80A000000              		mov		eax,10
   702 00000603 E9DFFEFFFF              		jmp		irq_general
   703                                  
   704 00000608 50                      irq_11:		push		eax
   705 00000609 B80B000000              		mov		eax,11
   706 0000060E E9D4FEFFFF              		jmp		irq_general
   707                                  
   708 00000613 50                      irq_12:		push		eax
   709 00000614 B80C000000              		mov		eax,12
   710 00000619 E9C9FEFFFF              		jmp		irq_general
   711                                  
   712 0000061E 50                      irq_13:		push		eax
   713 0000061F B80D000000              		mov		eax,13
   714 00000624 E9BEFEFFFF              		jmp		irq_general
   715                                  
   716 00000629 50                      irq_14:		push		eax
   717 0000062A B80E000000              		mov		eax,14
   718 0000062F E9B3FEFFFF              		jmp		irq_general
   719                                  
   720 00000634 50                      irq_15:		push		eax
   721 00000635 B80F000000              		mov		eax,15
   722 0000063A E9A8FEFFFF              		jmp		irq_general
   723                                  
   724                                  ; =============== GENERAL PURPOSE "NO INTERRUPT ASSIGNED" HANDLER
   725 0000063F CF                      fault_no_int:	iret
   726                                  
   727 00000640 00                      fault_x86_vector:db		0
   728                                  ; =============== REFLECT EXCEPTION TO REAL MODE
   729                                  fault_v86_reflect:
   730 00000641 50                      		push		eax
   731 00000642 53                      		push		ebx
   732 00000643 51                      		push		ecx
   733 00000644 66BB3000                		mov		bx,FLAT32_SEL		; NTS: Don't worry about saving ES. The CPU saved
   734 00000648 8EDB                    		mov		ds,bx			; it as part of the v86 -> interrupt transition.
   735 0000064A 31DB                    		xor		ebx,ebx
   736 0000064C 89D9                    		mov		ecx,ebx
   737 0000064E 2E8A1D[40060000]        		mov		bl,[cs:fault_x86_vector]; what interrupt is involved?
   738 00000655 8B1C9D00000000          		mov		ebx,[ebx*4]		; interrupt -> realmode vector
   739 0000065C 668B44241C              		mov		ax,[esp+20+8]		; fetch SS
   740 00000661 C1E004                  		shl		eax,4			; EAX = SS*16
   741 00000664 668B4C2418              		mov		cx,[esp+16+8]		; fetch SP
   742 00000669 6683E906                		sub		cx,6			; SP -= 6
   743 0000066D 01C8                    		add		eax,ecx			; EAX = SS*16 + SP
   744 0000066F 66894C2418              		mov		[esp+16+8],cx		; store modified SP back
   745                                  ; EBX = realmode interrupt vector
   746                                  ; EAX = stack pointer (physical mem addr)
   747 00000674 668B4C240C              		mov		cx,[esp+4+8]		; fetch EIP
   748 00000679 668908                  		mov		word [eax+0],cx		; SS:SP = offset
   749 0000067C 668B4C2410              		mov		cx,[esp+8+8]		; fetch CS
   750 00000681 66894802                		mov		word [eax+2],cx		; SS:SP+2 = segment
   751 00000685 668B4C2414              		mov		cx,[esp+12+8]		; fetch FLAGS
   752 0000068A 66894804                		mov		word [eax+4],cx		; SS:SP+4 = flags
   753 0000068E 66895C240C              		mov		[esp+4+8],bx		; overwrite IP = offset of vector
   754 00000693 C1EB10                  		shr		ebx,16
   755 00000696 66895C2410              		mov		[esp+8+8],bx		; overwrite CS = segment of vector
   756                                  ; if this is INT 0x01 we also need to clear the TF bit
   757 0000069B 2E803D[40060000]01      		cmp		byte [cs:fault_x86_vector],1
   758 000006A3 7507                    		jnz		.not_int1
   759 000006A5 6681642414FFFE          		and		word [esp+12+8],~0x100	; clear TF
   760                                  .not_int1:
   761                                  
   762                                  ; *DEBUG*
   763 000006AC 66FF0502800B00          		inc		word [0xB8002]
   764                                  
   765 000006B3 59                      		pop		ecx
   766 000006B4 5B                      		pop		ebx
   767 000006B5 58                      		pop		eax
   768 000006B6 CF                      		iret
   769                                  
   770                                  ; =============== FAULT HANDLER CODE
   771 000006B7 6A00                    fault_0x00:	push		dword 0 ; ERROR CODE
   772 000006B9 E8F5050000              		call		fault_collect_regs
   773 000006BE BA00000000              		mov		edx,0x00
   774 000006C3 BE[2B030000]            		mov		esi,str_fault_0x00
   775 000006C8 E9B7060000              		jmp		fault_jmp_unhandled
   776                                  
   777 000006CD F744240800000200        fault_0x01:	test		dword [esp+8],0x20000	; did it happen from within v86 mode?
   778 000006D5 7516                    		jnz		.reflect_v86
   779 000006D7 6A00                    		push		dword 0 ; ERROR CODE
   780 000006D9 E8D5050000              		call		fault_collect_regs
   781 000006DE BA01000000              		mov		edx,0x01
   782 000006E3 BE[3A030000]            		mov		esi,str_fault_0x01
   783 000006E8 E997060000              		jmp		fault_jmp_unhandled
   784 000006ED 36C605[40060000]01      .reflect_v86:	mov		byte [ss:fault_x86_vector],0x01 ; reflect to INT 0x01
   785 000006F5 E947FFFFFF              		jmp		fault_v86_reflect
   786                                  
   787 000006FA 6A00                    fault_0x02:	push		dword 0 ; ERROR CODE
   788 000006FC E8B2050000              		call		fault_collect_regs
   789 00000701 BA02000000              		mov		edx,0x02
   790 00000706 BE[40030000]            		mov		esi,str_fault_0x02
   791 0000070B E974060000              		jmp		fault_jmp_unhandled
   792                                  
   793 00000710 F744240800000200        fault_0x03:	test		dword [esp+8],0x20000	; did it happen from within v86 mode?
   794 00000718 7516                    		jnz		.reflect_v86
   795 0000071A 6A00                    		push		dword 0 ; ERROR CODE
   796 0000071C E892050000              		call		fault_collect_regs
   797 00000721 BA03000000              		mov		edx,0x03
   798 00000726 BE[44030000]            		mov		esi,str_fault_0x03
   799 0000072B E954060000              		jmp		fault_jmp_unhandled
   800 00000730 36C605[40060000]03      .reflect_v86:	mov		byte [ss:fault_x86_vector],0x03 ; reflect to INT 0x03
   801 00000738 E904FFFFFF              		jmp		fault_v86_reflect
   802                                  
   803 0000073D 6A00                    fault_0x04:	push		dword 0 ; ERROR CODE
   804 0000073F E86F050000              		call		fault_collect_regs
   805 00000744 BA04000000              		mov		edx,0x04
   806 00000749 BE[4F030000]            		mov		esi,str_fault_0x04
   807 0000074E E931060000              		jmp		fault_jmp_unhandled
   808                                  
   809 00000753 6A00                    fault_0x05:	push		dword 0 ; ERROR CODE
   810 00000755 E859050000              		call		fault_collect_regs
   811 0000075A BA05000000              		mov		edx,0x05
   812 0000075F BE[58030000]            		mov		esi,str_fault_0x05
   813 00000764 E91B060000              		jmp		fault_jmp_unhandled
   814                                  
   815 00000769 6A00                    fault_0x06:	push		dword 0 ; ERROR CODE
   816 0000076B E843050000              		call		fault_collect_regs
   817 00000770 BA06000000              		mov		edx,0x06
   818 00000775 BE[67030000]            		mov		esi,str_fault_0x06
   819 0000077A E905060000              		jmp		fault_jmp_unhandled
   820                                  
   821 0000077F 50                      fault_0x07:	push		eax
   822 00000780 0F20C0                  		mov		eax,cr0
   823 00000783 A908000000              		test		eax,0x08		; is this a result of CR0.TS being set?
   824 00000788 58                      		pop		eax
   825 00000789 7403                    		jz		.not_cr0_ts
   826                                  ; very likely a real-mode DOS application executed floating point instructions, and
   827                                  ; the task switch into vm86 mode left bit 3 (CR0.TS) set. Clear it and return. This
   828                                  ; is necessary to allow the DOS system to use floating point, even on 486/Pentium and
   829                                  ; higher systems where the FPU is integral to the CPU. Even for simple instructions
   830                                  ; like FSTSW/FNSTSW.
   831 0000078B 0F06                    		clts
   832 0000078D CF                      		iret
   833                                  ; if the exception did NOT involve that bit, then yes, it's something to halt on
   834 0000078E 6A00                    .not_cr0_ts:	push		dword 0 ; ERROR CODE
   835 00000790 E81E050000              		call		fault_collect_regs
   836 00000795 BA07000000              		mov		edx,0x07
   837 0000079A BE[76030000]            		mov		esi,str_fault_0x07
   838 0000079F E9E0050000              		jmp		fault_jmp_unhandled
   839                                  
   840 000007A4 E80A050000              fault_0x08:	call		fault_collect_regs
   841 000007A9 BA08000000              		mov		edx,0x08
   842 000007AE BE[86030000]            		mov		esi,str_fault_0x08
   843 000007B3 E9CC050000              		jmp		fault_jmp_unhandled
   844                                  
   845 000007B8 6A00                    fault_0x09:	push		dword 0 ; ERROR CODE
   846 000007BA E8F4040000              		call		fault_collect_regs
   847 000007BF BA09000000              		mov		edx,0x09
   848 000007C4 BE[93030000]            		mov		esi,str_fault_0x09
   849 000007C9 E9B6050000              		jmp		fault_jmp_unhandled
   850                                  
   851 000007CE E8E0040000              fault_0x0A:	call		fault_collect_regs
   852 000007D3 BA0A000000              		mov		edx,0x0A
   853 000007D8 BE[AF030000]            		mov		esi,str_fault_0x0A
   854 000007DD E9A2050000              		jmp		fault_jmp_unhandled
   855                                  
   856 000007E2 E8CC040000              fault_0x0B:	call		fault_collect_regs
   857 000007E7 BA0B000000              		mov		edx,0x0B
   858 000007EC BE[BB030000]            		mov		esi,str_fault_0x0B
   859 000007F1 E98E050000              		jmp		fault_jmp_unhandled
   860                                  
   861 000007F6 E8B8040000              fault_0x0C:	call		fault_collect_regs
   862 000007FB BA0C000000              		mov		edx,0x0C
   863 00000800 BE[CF030000]            		mov		esi,str_fault_0x0C
   864 00000805 E97A050000              		jmp		fault_jmp_unhandled
   865                                  
   866 0000080A E8A4040000              fault_0x0E:	call		fault_collect_regs
   867 0000080F BA0E000000              		mov		edx,0x0E
   868 00000814 BE[F4030000]            		mov		esi,str_fault_0x0E
   869 00000819 E966050000              		jmp		fault_jmp_unhandled
   870                                  
   871 0000081E 6A00                    fault_0x0F:	push		dword 0 ; ERROR CODE
   872 00000820 E88E040000              		call		fault_collect_regs
   873 00000825 BA0F000000              		mov		edx,0x0F
   874 0000082A BE[FF030000]            		mov		esi,str_fault_0x0F
   875 0000082F E950050000              		jmp		fault_jmp_unhandled
   876                                  
   877 00000834 6A00                    fault_0x10:	push		dword 0 ; ERROR CODE
   878 00000836 E878040000              		call		fault_collect_regs
   879 0000083B BA10000000              		mov		edx,0x10
   880 00000840 BE[0B040000]            		mov		esi,str_fault_0x10
   881 00000845 E93A050000              		jmp		fault_jmp_unhandled
   882                                  
   883 0000084A 6A00                    fault_0x11:	push		dword 0 ; ERROR CODE
   884 0000084C E862040000              		call		fault_collect_regs
   885 00000851 BA11000000              		mov		edx,0x11
   886 00000856 BE[15040000]            		mov		esi,str_fault_0x11
   887 0000085B E924050000              		jmp		fault_jmp_unhandled
   888                                  
   889 00000860 6A00                    fault_0x12:	push		dword 0 ; ERROR CODE
   890 00000862 E84C040000              		call		fault_collect_regs
   891 00000867 BA12000000              		mov		edx,0x12
   892 0000086C BE[25040000]            		mov		esi,str_fault_0x12
   893 00000871 E90E050000              		jmp		fault_jmp_unhandled
   894                                  
   895 00000876 6A00                    fault_0x13:	push		dword 0 ; ERROR CODE
   896 00000878 E836040000              		call		fault_collect_regs
   897 0000087D BA13000000              		mov		edx,0x13
   898 00000882 BE[33040000]            		mov		esi,str_fault_0x13
   899 00000887 E9F8040000              		jmp		fault_jmp_unhandled
   900                                  
   901 0000088C E822040000              fault_0x14:	call		fault_collect_regs
   902 00000891 BA14000000              		mov		edx,0x14
   903 00000896 E984000000              		jmp		fault_jmp_unhandled_unknown
   904                                  
   905 0000089B E813040000              fault_0x15:	call		fault_collect_regs
   906 000008A0 BA15000000              		mov		edx,0x15
   907 000008A5 EB78                    		jmp		fault_jmp_unhandled_unknown
   908                                  
   909 000008A7 E807040000              fault_0x16:	call		fault_collect_regs
   910 000008AC BA16000000              		mov		edx,0x16
   911 000008B1 EB6C                    		jmp		fault_jmp_unhandled_unknown
   912                                  
   913 000008B3 E8FB030000              fault_0x17:	call		fault_collect_regs
   914 000008B8 BA17000000              		mov		edx,0x17
   915 000008BD EB60                    		jmp		fault_jmp_unhandled_unknown
   916                                  
   917 000008BF E8EF030000              fault_0x18:	call		fault_collect_regs
   918 000008C4 BA18000000              		mov		edx,0x18
   919 000008C9 EB54                    		jmp		fault_jmp_unhandled_unknown
   920                                  
   921 000008CB E8E3030000              fault_0x19:	call		fault_collect_regs
   922 000008D0 BA19000000              		mov		edx,0x19
   923 000008D5 EB48                    		jmp		fault_jmp_unhandled_unknown
   924                                  
   925 000008D7 E8D7030000              fault_0x1A:	call		fault_collect_regs
   926 000008DC BA1A000000              		mov		edx,0x1A
   927 000008E1 EB3C                    		jmp		fault_jmp_unhandled_unknown
   928                                  
   929 000008E3 E8CB030000              fault_0x1B:	call		fault_collect_regs
   930 000008E8 BA1B000000              		mov		edx,0x1B
   931 000008ED EB30                    		jmp		fault_jmp_unhandled_unknown
   932                                  
   933 000008EF E8BF030000              fault_0x1C:	call		fault_collect_regs
   934 000008F4 BA1C000000              		mov		edx,0x1C
   935 000008F9 EB24                    		jmp		fault_jmp_unhandled_unknown
   936                                  
   937 000008FB E8B3030000              fault_0x1D:	call		fault_collect_regs
   938 00000900 BA1D000000              		mov		edx,0x1D
   939 00000905 EB18                    		jmp		fault_jmp_unhandled_unknown
   940                                  
   941 00000907 E8A7030000              fault_0x1E:	call		fault_collect_regs
   942 0000090C BA1E000000              		mov		edx,0x1E
   943 00000911 EB0C                    		jmp		fault_jmp_unhandled_unknown
   944                                  
   945 00000913 E89B030000              fault_0x1F:	call		fault_collect_regs
   946 00000918 BA1F000000              		mov		edx,0x1F
   947 0000091D EB00                    		jmp		fault_jmp_unhandled_unknown
   948                                  
   949                                  fault_jmp_unhandled_unknown:
   950 0000091F BE[46040000]            		mov		esi,str_fault_unknown
   951 00000924 E95B040000              		jmp		fault_jmp_unhandled
   952                                  
   953                                  ; ============= EXCEPTION HANDLER: INT 0x0D GENERAL PROTECTION FAULT
   954                                  ; If caused by v8086 mode:
   955                                  ;  [ESP+0] = error code
   956                                  ;  [ESP+4] = EIP
   957                                  ;  [ESP+8] = CS
   958                                  ;  [ESP+12] = EFLAGS
   959                                  ;  [ESP+16] = ESP
   960                                  ;  [ESP+20] = SS
   961                                  ;  [ESP+24] = ES
   962                                  ;  [ESP+28] = DS
   963                                  ;  [ESP+32] = FS
   964                                  ;  [ESP+36] = GS
   965                                  ; Else, only the error code, EIP, CS, EFLAGS fields are present.
   966                                  ; If not from ring 0, then ESP, SS are as well.
   967 00000929 F744240C00000200        fault_0x0D:	test		dword [esp+12],0x20000			; [ESP+12] = EFLAGS. Is bit 17 (VM) set?
   968 00000931 0F842F010000            		jz		.not_vm86_related
   969                                  
   970                                  ; at this point, we know this is the processor trapping CLI/STI or anything that a v86 monitor needs to know.
   971                                  ; so the next thing we do is examine the opcode at CS:IP to determine what the code is trying to do, and how
   972                                  ; to emulate it. Note the CS:IP off stack are REAL MODE addresses.
   973 00000937 60                      		pushad
   974 00000938 66B82000                		mov		ax,DATA32_SEL
   975 0000093C 8ED8                    		mov		ds,ax
   976 0000093E 8EC0                    		mov		es,ax
   977                                  
   978 00000940 31C0                    		xor		eax,eax
   979 00000942 89C3                    		mov		ebx,eax
   980 00000944 668B442428              		mov		ax,[esp+0x20+8]				; CS ON STACK
   981 00000949 C1E004                  		shl		eax,4
   982 0000094C 66035C2424              		add		bx,[esp+0x20+4]				; EIP ON STACK
   983 00000951 01D8                    		add		eax,ebx
   984 00000953 2B05[58200000]          		sub		eax,[my_phys_base]			; REMEMBER our data segment is relative to the COM.
   985                                  									; ALSO KNOW most x86 processors will wrap addresses like
   986                                  									; 0xFFFFF000 back around to 0 (32-bit overflow) with nonzero
   987                                  									; segment bases.
   988                                  
   989 00000959 8B00                    		mov		eax,[eax]				; fetch 4 bytes at CS:IP
   990 0000095B A3[70200000]            		mov		[v86_raw_opcode],eax			; store for reference
   991                                  
   992 00000960 3CFA                    		cmp		al,0xFA					; CLI?
   993 00000962 0F8411020000            		jz		.v86_cli
   994 00000968 3CFB                    		cmp		al,0xFB					; STI?
   995 0000096A 0F8419020000            		jz		.v86_sti
   996 00000970 3CF4                    		cmp		al,0xF4					; HLT? (apparently, yes, that causes a GPF from v86 mode)
   997 00000972 0F8421020000            		jz		.v86_hlt
   998 00000978 3CCD                    		cmp		al,0xCD					; INT X (AH=interrupt)
   999 0000097A 0F8490010000            		jz		.v86_int
  1000 00000980 3CCC                    		cmp		al,0xCC					; INT 3
  1001 00000982 0F8480010000            		jz		.v86_int3
  1002 00000988 3CCF                    		cmp		al,0xCF					; IRET
  1003 0000098A 0F84EA000000            		jz		.v86_iret
  1004 00000990 3C9C                    		cmp		al,0x9C					; PUSHF 16-bit
  1005 00000992 0F8428020000            		jz		.v86_pushf
  1006 00000998 3C9D                    		cmp		al,0x9D					; POPF 16-bit
  1007 0000099A 0F847F020000            		jz		.v86_popf
  1008 000009A0 663D669C                		cmp		ax,0x9C66				; PUSHFD 32-bit
  1009 000009A4 0F8446020000            		jz		.v86_pushfd
  1010 000009AA 663D669D                		cmp		ax,0x9D66				; POPFD 32-bit
  1011 000009AE 0F849B020000            		jz		.v86_popfd
  1012 000009B4 E9CB020000              		jmp		.v86_unknown
  1013                                  
  1014                                  .v86_complete_and_check_pending_irq: ; <----------- COMPLETION, PLUS CHECK IF INTERRUPTS ENABLED, PENDING IRQs
  1015 000009B9 66F744242C0002          		test		word [esp+0x20+12],0x200		; are interrupts enabled (IF=1)
  1016 000009C0 742E                    		jz		.v86_complete
  1017                                  ; interrupts enabled, are there pending IRQs?
  1018 000009C2 66833D[E8280000]00      		cmp		word [irq_pending],0
  1019 000009CA 7424                    		jz		.v86_complete
  1020                                  ; for each pending IRQ, stuff the stack with an interrupt frame.
  1021                                  ; this must be done in the order the PIC would do based on IRQ priority.
  1022 000009CC FC                      		cld
  1023 000009CD B910000000              		mov		ecx,16
  1024 000009D2 BE[D7040000]            		mov		esi,irq_priority
  1025                                  .v86_complete_and_check_pending_irq_scan:
  1026 000009D7 31C0                    		xor		eax,eax
  1027 000009D9 AC                      		lodsb
  1028 000009DA BB01000000              		mov		ebx,1
  1029 000009DF 51                      		push		ecx
  1030 000009E0 88C1                    		mov		cl,al	; <- NTS: bits 8-31 should be zero because we inited ECX == 16
  1031 000009E2 D3E3                    		shl		ebx,cl
  1032 000009E4 59                      		pop		ecx
  1033 000009E5 66851D[E8280000]        		test		word [irq_pending],bx			; if (irq_pending & (1 << AL)) ...
  1034 000009EC 7507                    		jnz		.v86_complete_and_check_pending_irq_found
  1035 000009EE E2E7                    		loop		.v86_complete_and_check_pending_irq_scan
  1036                                  ; FALL THROUGH TO COMPLETION
  1037 000009F0 61                      .v86_complete:	popad
  1038                                  .v86_complete_no_popad:
  1039 000009F1 83C404                  		add		esp,4					; dump error code (usually zero)
  1040 000009F4 CF                      		iret
  1041                                  
  1042                                  ; we found a pending IRQ. EBX = 1 << IRQ, EAX = IRQ
  1043                                  .v86_complete_and_check_pending_irq_found:
  1044 000009F5 51                      		push		ecx
  1045 000009F6 66311D[E8280000]        		xor		word [irq_pending],bx			; clear the bit
  1046                                  
  1047 000009FD 0FB6D8                  		movzx		ebx,al					; EBX = interrupt number
  1048 00000A00 B830000000              		mov		eax,FLAT32_SEL
  1049 00000A05 8EC0                    		mov		es,ax					; we'll need flat mode for this
  1050 00000A07 8A9B[C7040000]          		mov		bl,[int_rm_map+ebx]			; IRQ -> interrupt
  1051                                  		; store CS:IP and FLAGS on 16-bit stack, decrement stack pointer. DO NOT MODIFY EBX
  1052 00000A0D 66836C243406            		sub		word [esp+0x20+4+16],6			; (E)SP -= 6
  1053 00000A13 668B442438              		mov		ax,word [esp+0x20+4+20]			; AX = SS (upper bits should be zero)
  1054 00000A18 C1E004                  		shl		eax,4					; AX *= 16
  1055 00000A1B 31C9                    		xor		ecx,ecx
  1056 00000A1D 668B4C2434              		mov		cx,word [esp+0x20+4+16]			; CX = SP
  1057 00000A22 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1058 00000A24 668B4C2428              		mov		cx,word [esp+0x20+4+4]			; IP
  1059 00000A29 26668908                		mov		word [es:eax],cx			; SS:SP+0 = IP
  1060 00000A2D 668B4C242C              		mov		cx,word [esp+0x20+4+8]			; CS
  1061 00000A32 2666894802              		mov		word [es:eax+2],cx			; SS:SP+2 = CS
  1062 00000A37 668B4C2430              		mov		cx,word [esp+0x20+4+12]			; FLAGS
  1063 00000A3C 2666894804              		mov		word [es:eax+4],cx			; SS:SP+4 = FLAGS
  1064                                  		; replace CS:IP with values from real-mode interrupt table (EBX = interrupt vector)
  1065 00000A41 26668B049D00000000      		mov		ax,[es:(ebx*4)]				; read from real-mode interrupt table (offset)
  1066 00000A4A 6689442428              		mov		word [esp+0x20+4+4],ax			; replace EIP
  1067 00000A4F 26668B049D02000000      		mov		ax,[es:(ebx*4)+2]			;  .... (segment)
  1068 00000A58 668944242C              		mov		word [esp+0x20+4+8],ax			; replace CS
  1069                                  
  1070 00000A5D 59                      		pop		ecx
  1071 00000A5E 49                      		dec		ecx
  1072 00000A5F 748F                    		jz		.v86_complete
  1073 00000A61 E971FFFFFF              		jmp		.v86_complete_and_check_pending_irq_scan
  1074                                  
  1075                                  ;   EXCEPTION HANDLING REACHES HERE IF IT TURNS OUT VM86 MODE WAS NOT INVOLVED
  1076                                  .not_vm86_related:
  1077 00000A66 E848020000              		call		fault_collect_regs
  1078 00000A6B BA0D000000              		mov		edx,0x0D				; INT 0x0D General Protection Fault
  1079 00000A70 BE[DB030000]            		mov		esi,str_fault_0x0D
  1080 00000A75 E90A030000              		jmp		fault_jmp_unhandled
  1081                                  ;   V86 IRET
  1082 00000A7A B830000000              .v86_iret:	mov		eax,FLAT32_SEL
  1083 00000A7F 8EC0                    		mov		es,ax					; we'll need flat mode for this
  1084                                  		; retrieve CS:IP and FLAGS from 16-bit stack, increment stack pointer
  1085 00000A81 668B442434              		mov		ax,word [esp+0x20+20]			; AX = SS (upper bits should be zero)
  1086 00000A86 C1E004                  		shl		eax,4					; AX *= 16
  1087 00000A89 31C9                    		xor		ecx,ecx
  1088 00000A8B 668B4C2430              		mov		cx,word [esp+0x20+16]			; CX = SP
  1089 00000A90 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1090                                  
  1091 00000A92 26668B08                		mov		cx,word [es:eax]			; IP = SS:SP+0
  1092 00000A96 66894C2424              		mov		word [esp+0x20+4],cx			; IP
  1093                                  
  1094 00000A9B 26668B4802              		mov		cx,word [es:eax+2]			; CS = SS:SP+2
  1095 00000AA0 66894C2428              		mov		word [esp+0x20+8],cx			; CS
  1096                                  
  1097 00000AA5 26668B4804              		mov		cx,word [es:eax+4]			; FLAGS = SS:SP+4
  1098 00000AAA 66894C242C              		mov		word [esp+0x20+12],cx			; FLAGS
  1099                                  
  1100 00000AAF 668344243006            		add		word [esp+0x20+16],6			; (E)SP += 6
  1101 00000AB5 E936FFFFFF              		jmp		.v86_complete
  1102                                  ;   V86 INT 66h
  1103 00000ABA 61                      .v86_int_api:	popad
  1104 00000ABB 3D55AABBAA              		cmp		eax,0xAABBAA55
  1105 00000AC0 7409                    		jz		.v86_int_api_detect
  1106 00000AC2 3DBBAABBAA              		cmp		eax,0xAABBAABB
  1107 00000AC7 740C                    		jz		.v86_int_api_unload
  1108 00000AC9 CD03                    		int		3
  1109                                  .v86_int_api_detect:
  1110 00000ACB B833BBAABB              		mov		eax,0xBBAABB33
  1111 00000AD0 E91CFFFFFF              		jmp		.v86_complete_no_popad
  1112                                  .v86_int_api_unload:
  1113 00000AD5 668B442404              		mov		ax,word [esp+4]				; save IP
  1114 00000ADA 668B5C2408              		mov		bx,word [esp+8]				; save CS
  1115 00000ADF 66A3[EE280000]          		mov		[unload_int_ret+0],ax
  1116 00000AE5 66891D[F0280000]        		mov		[unload_int_ret+2],bx
  1117                                  
  1118 00000AEC 668B442410              		mov		ax,word [esp+16]			; save SP
  1119 00000AF1 668B5C2414              		mov		bx,word [esp+20]			; save SS
  1120 00000AF6 66A3[F2280000]          		mov		[unload_int_stk+0],ax
  1121 00000AFC 66891D[F4280000]        		mov		[unload_int_stk+2],bx
  1122                                  
  1123 00000B03 E99A010000              		jmp		v86_api_exit
  1124                                  ;   V86 INT 3 (AL = 0xCC)
  1125 00000B08 B403                    .v86_int3:	mov		ah,0x03					; convert to INT 3 (CD 03)
  1126 00000B0A FF442424                		inc		dword [esp+0x20+4]			; step past (EIP++)
  1127 00000B0E EB05                    		jmp		short .v86_int_n
  1128                                  ;   V86 INT x (AL = 0xCD   AH = N)
  1129 00000B10 8344242402              .v86_int:	add		dword [esp+0x20+4],2			; EIP += 2
  1130                                  ;   V86 INT REFLECTION TO REAL MODE
  1131 00000B15 0FB6DC                  .v86_int_n:	movzx		ebx,ah					; EBX = interrupt number
  1132                                  		; *DEBUG*
  1133 00000B18 80FB66                  		cmp		bl,RM_INT_API
  1134 00000B1B 749D                    		jz		.v86_int_api
  1135                                  		; *END DEBUG*
  1136 00000B1D B830000000              		mov		eax,FLAT32_SEL
  1137 00000B22 8EC0                    		mov		es,ax					; we'll need flat mode for this
  1138                                  		; store CS:IP and FLAGS on 16-bit stack, decrement stack pointer. DO NOT MODIFY EBX
  1139 00000B24 66836C243006            		sub		word [esp+0x20+16],6			; (E)SP -= 6
  1140 00000B2A 668B442434              		mov		ax,word [esp+0x20+20]			; AX = SS (upper bits should be zero)
  1141 00000B2F C1E004                  		shl		eax,4					; AX *= 16
  1142 00000B32 31C9                    		xor		ecx,ecx
  1143 00000B34 668B4C2430              		mov		cx,word [esp+0x20+16]			; CX = SP
  1144 00000B39 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1145 00000B3B 668B4C2424              		mov		cx,word [esp+0x20+4]			; IP
  1146 00000B40 26668908                		mov		word [es:eax],cx			; SS:SP+0 = IP
  1147 00000B44 668B4C2428              		mov		cx,word [esp+0x20+8]			; CS
  1148 00000B49 2666894802              		mov		word [es:eax+2],cx			; SS:SP+2 = CS
  1149 00000B4E 668B4C242C              		mov		cx,word [esp+0x20+12]			; FLAGS
  1150 00000B53 2666894804              		mov		word [es:eax+4],cx			; SS:SP+4 = FLAGS
  1151                                  		; replace CS:IP with values from real-mode interrupt table (EBX = interrupt vector)
  1152 00000B58 26668B049D00000000      		mov		ax,[es:(ebx*4)]				; read from real-mode interrupt table (offset)
  1153 00000B61 6689442424              		mov		word [esp+0x20+4],ax			; replace EIP
  1154 00000B66 26668B049D02000000      		mov		ax,[es:(ebx*4)+2]			;  .... (segment)
  1155 00000B6F 6689442428              		mov		word [esp+0x20+8],ax			; replace CS
  1156 00000B74 E977FEFFFF              		jmp		.v86_complete
  1157                                  ;   V86 CLI
  1158 00000B79 FF442424                .v86_cli:	inc		dword [esp+0x20+4]			; step past (EIP++)
  1159 00000B7D 668164242CFFFD          		and		word [esp+0x20+12],~0x200
  1160 00000B84 E930FEFFFF              		jmp		.v86_complete_and_check_pending_irq
  1161                                  ;   V86 STI
  1162 00000B89 FF442424                .v86_sti:	inc		dword [esp+0x20+4]			; step past (EIP++)
  1163 00000B8D 66814C242C0002          		or		word [esp+0x20+12],0x200
  1164 00000B94 E920FEFFFF              		jmp		.v86_complete_and_check_pending_irq
  1165                                  ;   V86 HLT
  1166 00000B99 FF442424                .v86_hlt:	inc		dword [esp+0x20+4]			; step past (EIP++)
  1167 00000B9D 66F744242C0002          		test		word [esp+0x20+12],0x200
  1168 00000BA4 7405                    		jz		.v86_hlt_with_cli
  1169 00000BA6 E90EFEFFFF              		jmp		.v86_complete_and_check_pending_irq
  1170                                  ;   V86 HLT with interrupts disabled
  1171                                  .v86_hlt_with_cli:
  1172 00000BAB 61                      		popad							; undo v86 check stack
  1173 00000BAC E802010000              		call		fault_collect_regs
  1174 00000BB1 BA0D000000              		mov		edx,0x0D
  1175 00000BB6 BE[78040000]            		mov		esi,str_v86_hlt_cli
  1176 00000BBB E9C4010000              		jmp		fault_jmp_unhandled
  1177                                  ;   V86 PUSHF
  1178 00000BC0 B830000000              .v86_pushf:	mov		eax,FLAT32_SEL
  1179 00000BC5 8EC0                    		mov		es,ax
  1180 00000BC7 FF442424                		inc		dword [esp+0x20+4]			; step past (EIP++)
  1181 00000BCB 66836C243002            		sub		word [esp+0x20+16],2			; (E)SP -= 2
  1182 00000BD1 668B442434              		mov		ax,word [esp+0x20+20]			; AX = SS (upper bits should be zero)
  1183 00000BD6 C1E004                  		shl		eax,4					; AX *= 16
  1184 00000BD9 31C9                    		xor		ecx,ecx
  1185 00000BDB 668B4C2430              		mov		cx,word [esp+0x20+16]			; CX = SP
  1186 00000BE0 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1187 00000BE2 668B4C242C              		mov		cx,word [esp+0x20+12]			; FLAGS
  1188 00000BE7 26668908                		mov		word [es:eax],cx			; SS:SP+0 = FLAGS
  1189 00000BEB E900FEFFFF              		jmp		.v86_complete
  1190                                  ;   V86 PUSHFD
  1191 00000BF0 B830000000              .v86_pushfd:	mov		eax,FLAT32_SEL
  1192 00000BF5 8EC0                    		mov		es,ax
  1193 00000BF7 8344242402              		add		dword [esp+0x20+4],2			; step past (EIP += 2)
  1194 00000BFC 66836C243004            		sub		word [esp+0x20+16],4			; (E)SP -= 4
  1195 00000C02 668B442434              		mov		ax,word [esp+0x20+20]			; AX = SS (upper bits should be zero)
  1196 00000C07 C1E004                  		shl		eax,4					; AX *= 16
  1197 00000C0A 31C9                    		xor		ecx,ecx
  1198 00000C0C 668B4C2430              		mov		cx,word [esp+0x20+16]			; CX = SP
  1199 00000C11 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1200 00000C13 8B4C242C                		mov		ecx,dword [esp+0x20+12]			; EFLAGS
  1201 00000C17 268908                  		mov		dword [es:eax],ecx			; SS:SP+0 = FLAGS
  1202 00000C1A E9D1FDFFFF              		jmp		.v86_complete
  1203                                  ;   V86 POPF
  1204 00000C1F B830000000              .v86_popf:	mov		eax,FLAT32_SEL
  1205 00000C24 8EC0                    		mov		es,ax
  1206 00000C26 FF442424                		inc		dword [esp+0x20+4]			; step past (EIP++)
  1207 00000C2A 668B442434              		mov		ax,word [esp+0x20+20]			; AX = SS (upper bits should be zero)
  1208 00000C2F C1E004                  		shl		eax,4					; AX *= 16
  1209 00000C32 31C9                    		xor		ecx,ecx
  1210 00000C34 668B4C2430              		mov		cx,word [esp+0x20+16]			; CX = SP
  1211 00000C39 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1212 00000C3B 26668B08                		mov		cx,word [es:eax]			; FLAGS = SS:SP+0
  1213 00000C3F 66894C242C              		mov		word [esp+0x20+12],cx			; FLAGS
  1214 00000C44 668344243002            		add		word [esp+0x20+16],2			; (E)SP += 2
  1215 00000C4A E96AFDFFFF              		jmp		.v86_complete_and_check_pending_irq
  1216                                  ;   V86 POPFD
  1217 00000C4F B830000000              .v86_popfd:	mov		eax,FLAT32_SEL
  1218 00000C54 8EC0                    		mov		es,ax
  1219 00000C56 8344242402              		add		dword [esp+0x20+4],2			; step past (EIP += 2)
  1220 00000C5B 668B442434              		mov		ax,word [esp+0x20+20]			; AX = SS (upper bits should be zero)
  1221 00000C60 C1E004                  		shl		eax,4					; AX *= 16
  1222 00000C63 31C9                    		xor		ecx,ecx
  1223 00000C65 668B4C2430              		mov		cx,word [esp+0x20+16]			; CX = SP
  1224 00000C6A 01C8                    		add		eax,ecx					; AX += SP  AX = (SS*16)+SP
  1225 00000C6C 268B08                  		mov		ecx,dword [es:eax]			; EFLAGS = SS:SP+0
  1226 00000C6F 81C900000200            		or		ecx,0x20000				; make sure the VM bit is set
  1227 00000C75 894C242C                		mov		dword [esp+0x20+12],ecx			; EFLAGS
  1228 00000C79 668344243004            		add		word [esp+0x20+16],4			; (E)SP += 4
  1229 00000C7F E935FDFFFF              		jmp		.v86_complete_and_check_pending_irq
  1230                                  ;   UNKNOWN OPCODE AT CS:IP in V8086 MODE
  1231 00000C84 61                      .v86_unknown:	popad							; undo v86 check stack
  1232 00000C85 83C404                  		add		esp,4					; toss real error code
  1233 00000C88 FF35[70200000]          		push		dword [v86_raw_opcode]			; the "ERROR CODE" are the 4 bytes at CS:IP
  1234 00000C8E E820000000              		call		fault_collect_regs
  1235 00000C93 BA0D000000              		mov		edx,0x0D
  1236 00000C98 BE[58040000]            		mov		esi,str_v86_unknown
  1237 00000C9D E9E2000000              		jmp		fault_jmp_unhandled
  1238                                  ;   API CALL TO SHUTDOWN VM86 MONITOR
  1239 00000CA2 66B83000                v86_api_exit:	mov		ax,FLAT32_SEL
  1240 00000CA6 8EC0                    		mov		es,ax
  1241 00000CA8 66B82000                		mov		ax,DATA32_SEL
  1242 00000CAC 8ED8                    		mov		ds,ax
  1243                                  ; FIXME: I give up... why does JMPing to TSS_SEL:0 cause random crashes in VirtualBox?
  1244 00000CAE E9E7000000              		jmp		_exit_from_prot32			; and then begin shutdown of this program
  1245                                  
  1246                                  ; ========== FAULT COLLECTION ROUTINE. SS:ESP should point to fault. If the exception does not push an error code,
  1247                                  ;    then the caller must push a dummy error code
  1248                                  fault_collect_regs:
  1249 00000CB3 1E                      		push		ds
  1250 00000CB4 50                      		push		eax
  1251 00000CB5 53                      		push		ebx
  1252 00000CB6 668CD8                  		mov		ax,ds
  1253 00000CB9 6689C3                  		mov		bx,ax
  1254 00000CBC 66B82000                		mov		ax,DATA32_SEL
  1255 00000CC0 8ED8                    		mov		ds,ax
  1256 00000CC2 66891D[30290000]        		mov		word [unhandled_fault_var_ds],bx
  1257 00000CC9 5B                      		pop		ebx
  1258                                  
  1259 00000CCA 8B44240C                		mov		eax,[esp+4+8+0]				; ERROR CODE ON STACK +2 DWORDs PUSHED
  1260 00000CCE A3[F6280000]            		mov		dword [unhandled_fault_var_errcode],eax
  1261                                  
  1262 00000CD3 8B442410                		mov		eax,[esp+4+8+4]				; EIP ON STACK
  1263 00000CD7 A3[1A290000]            		mov		dword [unhandled_fault_var_eip],eax
  1264                                  
  1265 00000CDC 8B442414                		mov		eax,[esp+4+8+8]				; CS ON STACK
  1266 00000CE0 66A3[2E290000]          		mov		word [unhandled_fault_var_cs],ax
  1267                                  
  1268 00000CE6 8B442418                		mov		eax,[esp+4+8+12]			; EFLAGS ON STACK
  1269 00000CEA A3[1E290000]            		mov		dword [unhandled_fault_var_eflags],eax
  1270                                  
  1271 00000CEF E85F000000              		call		.retr_stack_ptr
  1272                                  
  1273 00000CF4 58                      		pop		eax
  1274                                  
  1275 00000CF5 A3[FA280000]            		mov		dword [unhandled_fault_var_eax],eax
  1276 00000CFA 891D[FE280000]          		mov		dword [unhandled_fault_var_ebx],ebx
  1277 00000D00 890D[02290000]          		mov		dword [unhandled_fault_var_ecx],ecx
  1278 00000D06 8915[06290000]          		mov		dword [unhandled_fault_var_edx],edx
  1279 00000D0C 8935[0A290000]          		mov		dword [unhandled_fault_var_esi],esi
  1280 00000D12 893D[0E290000]          		mov		dword [unhandled_fault_var_edi],edi
  1281 00000D18 892D[12290000]          		mov		dword [unhandled_fault_var_ebp],ebp
  1282                                  
  1283 00000D1E 0F20C0                  		mov		eax,cr0
  1284 00000D21 A3[22290000]            		mov		dword [unhandled_fault_var_cr0],eax
  1285 00000D26 0F20D8                  		mov		eax,cr3
  1286 00000D29 A3[26290000]            		mov		dword [unhandled_fault_var_cr3],eax
  1287 00000D2E 0F20E0                  		mov		eax,cr4
  1288 00000D31 A3[2A290000]            		mov		dword [unhandled_fault_var_cr4],eax
  1289 00000D36 668CC0                  		mov		ax,es
  1290 00000D39 66A3[32290000]          		mov		word [unhandled_fault_var_es],ax
  1291 00000D3F 668CE0                  		mov		ax,fs
  1292 00000D42 66A3[34290000]          		mov		word [unhandled_fault_var_fs],ax
  1293 00000D48 668CE8                  		mov		ax,gs
  1294 00000D4B 66A3[36290000]          		mov		word [unhandled_fault_var_gs],ax
  1295 00000D51 1F                      		pop		ds
  1296 00000D52 C3                      		ret
  1297                                  ; if privilege escalation was involved (stack switching) then retrieve SS:ESP at fault from the stack frame.
  1298                                  ; else retrieve from actual SS:ESP registers
  1299                                  .retr_stack_ptr:
  1300 00000D53 66F705[2E290000]03-     		test		word [unhandled_fault_var_cs],3		; if code segment is nonzero
  1301 00000D5B 00                 
  1302 00000D5C 7414                    		jz		.retr_stack_ptr_ring_0
  1303                                  
  1304 00000D5E 8B442420                		mov		eax,[esp+4+4+8+16]			; ESP ON STACK
  1305 00000D62 A3[16290000]            		mov		dword [unhandled_fault_var_esp],eax
  1306                                  
  1307 00000D67 8B442424                		mov		eax,[esp+4+4+8+20]			; SS ON STACK
  1308 00000D6B 66A3[38290000]          		mov		word [unhandled_fault_var_ss],ax
  1309                                  
  1310 00000D71 C3                      		ret
  1311                                  .retr_stack_ptr_ring_0:
  1312 00000D72 8D442420                		lea		eax,[esp+4+4+8+16]			; +4 our call frame, +8 PUSH DS,EAX +16 GPF stack frame
  1313 00000D76 A3[16290000]            		mov		dword [unhandled_fault_var_esp],eax
  1314                                  
  1315 00000D7B 8CD0                    		mov		eax,ss					; SS ON STACK
  1316 00000D7D 66A3[38290000]          		mov		word [unhandled_fault_var_ss],ax
  1317                                  
  1318 00000D83 C3                      		ret
  1319                                  
  1320                                  fault_jmp_unhandled:
  1321 00000D84 EA[8B0D0000]0800        		jmp		CODE16_SEL:.thunk16
  1322                                  		bits		16
  1323 00000D8B B81000                  .thunk16:	mov		ax,DATA16_SEL
  1324 00000D8E 8ED8                    		mov		ds,ax
  1325 00000D90 8EC0                    		mov		es,ax
  1326 00000D92 8ED0                    		mov		ss,ax
  1327 00000D94 BC[0010]                		mov		sp,stack_init
  1328 00000D97 E9BA00                  		jmp		unhandled_fault_errcode
  1329                                  		bits		32
  1330                                  
  1331                                  ; ============= cleanup, exit to DOS (from 32-bit protected mode)
  1332                                  _exit_from_prot32:
  1333 00000D9A EA[A10D0000]0800        		jmp		CODE16_SEL:.entry16
  1334                                  		bits		16
  1335 00000DA1 B81000                  .entry16:	mov		ax,DATA16_SEL
  1336 00000DA4 8ED8                    		mov		ds,ax
  1337 00000DA6 8EC0                    		mov		es,ax
  1338 00000DA8 8EE0                    		mov		fs,ax
  1339 00000DAA 8EE8                    		mov		gs,ax
  1340 00000DAC 8ED0                    		mov		ss,ax
  1341 00000DAE 66BC[00100000]          		mov		esp,stack_init
  1342                                  
  1343                                  ; ============= cleanup, exit to DOS (from 16-bit protected mode)
  1344                                  _exit_from_prot16:
  1345 00000DB4 B81000                  		mov		ax,DATA16_SEL
  1346 00000DB7 8ED8                    		mov		ds,ax
  1347 00000DB9 8EC0                    		mov		es,ax
  1348 00000DBB 8EE0                    		mov		fs,ax
  1349 00000DBD 8EE8                    		mov		gs,ax
  1350 00000DBF 8ED0                    		mov		ss,ax
  1351 00000DC1 BC[0010]                		mov		sp,stack_init
  1352                                  		; overwrite the far jmp's segment value
  1353 00000DC4 A1[5620]                		mov		ax,[my_realmode_seg]
  1354 00000DC7 A3[DD0D]                		mov		word [.real_hackme+3],ax
  1355 00000DCA 0F011E[9020]            		lidt		[idtr_real]
  1356 00000DCF 0F0116[8020]            		lgdt		[gdtr_real]
  1357 00000DD4 6631C0                  		xor		eax,eax
  1358 00000DD7 0F22C0                  		mov		cr0,eax
  1359 00000DDA EA[DF0D]0000            .real_hackme:	jmp		0:.real_entry
  1360 00000DDF A1[5620]                .real_entry:	mov		ax,[my_realmode_seg]
  1361 00000DE2 8ED8                    		mov		ds,ax
  1362 00000DE4 8EC0                    		mov		es,ax
  1363 00000DE6 8EE0                    		mov		fs,ax
  1364 00000DE8 8EE8                    		mov		gs,ax
  1365 00000DEA 8ED0                    		mov		ss,ax
  1366 00000DEC BC[0010]                		mov		sp,stack_init
  1367                                  
  1368                                  ; reprogram the PIC back to what normal DOS expects: IRQ 0-7 => INT 8-15
  1369 00000DEF B010                    		mov		al,0x10			; ICW1 A0=0
  1370 00000DF1 E620                    		out		20h,al
  1371 00000DF3 B008                    		mov		al,0x08			; ICW2 A0=1
  1372 00000DF5 E621                    		out		21h,al
  1373 00000DF7 B004                    		mov		al,0x04			; ICW3 A0=1 slave on IRQ 2
  1374 00000DF9 E621                    		out		21h,al
  1375                                  
  1376                                  ; remove our INT 66h API
  1377 00000DFB 31C0                    		xor		ax,ax
  1378 00000DFD 8EC0                    		mov		es,ax
  1379 00000DFF 26A39801                		mov		word [es:(RM_INT_API*4)],ax
  1380 00000E03 26A39A01                		mov		word [es:(RM_INT_API*4)+2],ax
  1381                                  
  1382                                  ; free HIMEM.SYS blocks
  1383 00000E07 B40D                    		mov		ah,0Dh			; HIMEM.SYS function 0Dh unlock memory block
  1384 00000E09 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
  1385 00000E0D FF1E[4C20]              		call far	word [himem_sys_entry]
  1386 00000E11 B40A                    		mov		ah,0Ah			; HIMEM.SYS function 0Ah free memory block
  1387 00000E13 8B16[5420]              		mov		dx,word [himem_sys_buffer_handle]
  1388 00000E17 FF1E[4C20]              		call far	word [himem_sys_entry]
  1389                                  
  1390                                  ; if we already exited as a TSR...
  1391 00000E1B F606[ED28]01            		test		byte [i_am_tsr],1
  1392 00000E20 7506                    		jnz		.tsr_exit
  1393                                  
  1394                                  ; time to exit to DOS
  1395 00000E22 BA[C404]                		mov		dx,str_exit_to_dos
  1396 00000E25 E92AF2                  		jmp		_exit_with_msg
  1397                                  
  1398                                  ; ============= ALTERNATE EXIT IF WE ALREADY EXITED AS TSR
  1399                                  .tsr_exit:	
  1400 00000E28 8CC8                    		mov		ax,cs
  1401 00000E2A 8EC0                    		mov		es,ax			; ES = our code segment which is also our PSP segment
  1402 00000E2C B449                    		mov		ah,0x49			; function 49h free memory block
  1403 00000E2E F8                      		clc
  1404 00000E2F CD21                    		int		21h
  1405 00000E31 7306                    		jnc		.tsr_exit_free_ok
  1406 00000E33 BA[8E00]                		mov		dx,str_cannot_free_self
  1407 00000E36 E8F803                  		call		dos_puts
  1408                                  .tsr_exit_free_ok:
  1409 00000E39 FA                      		cli
  1410 00000E3A 2EA1[F228]              		mov		ax,[cs:unload_int_stk+0]	; offset
  1411 00000E3E 83C006                  		add		ax,6				; discard prior frame
  1412 00000E41 89C4                    		mov		sp,ax
  1413 00000E43 2EA1[F428]              		mov		ax,[cs:unload_int_stk+2]	; segment
  1414 00000E47 8ED0                    		mov		ss,ax
  1415                                  
  1416 00000E49 BA[C404]                		mov		dx,str_exit_to_dos
  1417 00000E4C E8E203                  		call		dos_puts
  1418                                  
  1419 00000E4F 2EFF2E[EE28]            		jmp far		word [cs:unload_int_ret]
  1420                                  
  1421                                  ; ============= UNHANDLED FAULT HANDLER (16-bit code)
  1422                                  ;   input: EDX = Number of interrupt
  1423                                  ;          DS:SI = Textual string of fault
  1424                                  ;          ESP = Stack containing:
  1425                                  ;                  
  1426                                  unhandled_fault_errcode:
  1427 00000E54 FA                      		cli
  1428 00000E55 B81000                  		mov		ax,DATA16_SEL
  1429 00000E58 8ED8                    		mov		ds,ax
  1430                                  
  1431 00000E5A 2EA1[5620]              		mov		ax,[cs:my_realmode_seg]
  1432 00000E5E A3[7F0E]                		mov		word [.real16jmp+3],ax
  1433                                  
  1434 00000E61 B82800                  		mov		ax,FLAT16_SEL
  1435 00000E64 8ED8                    		mov		ds,ax
  1436 00000E66 8EC0                    		mov		es,ax
  1437 00000E68 8ED0                    		mov		ss,ax
  1438                                  
  1439 00000E6A 2E0F0116[8020]          		lgdt		[cs:gdtr_real]
  1440 00000E70 2E0F011E[9020]          		lidt		[cs:idtr_real]
  1441                                  
  1442                                  		; crash-thunk to real mode
  1443 00000E76 6631C0                  		xor		eax,eax
  1444 00000E79 0F22C0                  		mov		cr0,eax
  1445 00000E7C EA[810E]0000            .real16jmp:	jmp		0:.real16
  1446 00000E81 2EA1[5620]              .real16:	mov		ax,[cs:my_realmode_seg]
  1447 00000E85 8ED8                    		mov		ds,ax
  1448 00000E87 8ED0                    		mov		ss,ax
  1449 00000E89 31C0                    		xor		ax,ax
  1450 00000E8B 8EC0                    		mov		es,ax
  1451                                  
  1452 00000E8D B80300                  		mov		ax,3
  1453 00000E90 CD10                    		int		10h
  1454                                  
  1455 00000E92 FC                      		cld
  1456 00000E93 B8204E                  		mov		ax,0x4E20
  1457 00000E96 66B9D0070000            		mov		ecx,80*25
  1458 00000E9C 66BF00800B00            		mov		edi,0xB8000
  1459 00000EA2 F367AB                  		a32 rep		stosw
  1460                                  
  1461                                  		; print exception name on screen
  1462 00000EA5 66BF00800B00            		mov		edi,0xB8000
  1463 00000EAB E8F800                  		call		.unhandled_print
  1464 00000EAE B020                    		mov		al,' '		; +space plus AH still contains upper byte from .unhandled_print
  1465 00000EB0 67AB                    		a32 stosw
  1466                                  
  1467                                  		; then the number (in EDX) write to DS:DI
  1468 00000EB2 6689D0                  		mov		eax,edx
  1469 00000EB5 6657                    		push		edi
  1470 00000EB7 66BF[04100000]          		mov		edi,scratch_str
  1471 00000EBD E8E703                  		call		eax_to_hex_16_dos
  1472 00000EC0 8D7506                  		lea		si,[di+6]	; only the last two hex digits
  1473 00000EC3 665F                    		pop		edi
  1474 00000EC5 E8DE00                  		call		.unhandled_print
  1475                                  
  1476                                  		; print the registers.
  1477                                  		; during this loop: SI = print list  EDI = location on screen to draw   [ESP] = location on screen of row start
  1478 00000EC8 66BF40810B00            		mov		edi,0xB8000+(160*2)	; two lines down
  1479 00000ECE 6657                    		push		edi
  1480 00000ED0 BE[C511]                		mov		si,printlist_32
  1481 00000ED3 AD                      .regprint32:	lodsw
  1482 00000ED4 09C0                    		or		ax,ax
  1483 00000ED6 743F                    		jz		.regprint32e		; AX=0 STOP
  1484 00000ED8 48                      		dec		ax
  1485 00000ED9 742F                    		jz		.regprint32nl		; AX=1 GO TO NEW LINE
  1486 00000EDB 56                      		push		si
  1487 00000EDC 89C6                    		mov		si,ax			; SI=AX=address of variable name
  1488 00000EDE 46                      		inc		si
  1489 00000EDF E8C400                  		call		.unhandled_print
  1490 00000EE2 5E                      		pop		si
  1491 00000EE3 B83A4E                  		mov		ax,0x4E00 | (':')
  1492 00000EE6 67AB                    		a32 stosw
  1493 00000EE8 AD                      		lodsw					; SI=address of variable
  1494 00000EE9 56                      		push		si
  1495 00000EEA 89C6                    		mov		si,ax
  1496 00000EEC 668B04                  		mov		eax,[si]
  1497 00000EEF 6657                    		push		edi
  1498 00000EF1 66BF[04100000]          		mov		edi,scratch_str
  1499 00000EF7 E8AD03                  		call		eax_to_hex_16_dos
  1500 00000EFA 6689FE                  		mov		esi,edi
  1501 00000EFD 665F                    		pop		edi
  1502 00000EFF E8A400                  		call		.unhandled_print
  1503 00000F02 5E                      		pop		si
  1504 00000F03 B8204E                  		mov		ax,0x4E00 | (' ')
  1505 00000F06 67AB                    		a32 stosw
  1506 00000F08 EBC9                    		jmp		.regprint32
  1507 00000F0A 665F                    .regprint32nl:	pop		edi
  1508 00000F0C 6681C7A0000000          		add		edi,160			; move to next line, save back to [ESP]
  1509 00000F13 6657                    		push		edi
  1510 00000F15 EBBC                    		jmp		.regprint32
  1511 00000F17 665F                    .regprint32e:	pop		edi
  1512                                  
  1513 00000F19 6681C7A0000000          		add		edi,160			; next line...
  1514                                  
  1515 00000F20 BE[0312]                		mov		si,printlist_16
  1516 00000F23 AD                      .regprint16:	lodsw
  1517 00000F24 09C0                    		or		ax,ax
  1518 00000F26 7443                    		jz		.regprint16e		; AX=0 STOP
  1519 00000F28 48                      		dec		ax
  1520 00000F29 7433                    		jz		.regprint16nl		; AX=1 GO TO NEW LINE
  1521 00000F2B 56                      		push		si
  1522 00000F2C 89C6                    		mov		si,ax			; SI=AX=address of variable name
  1523 00000F2E 46                      		inc		si
  1524 00000F2F E87400                  		call		.unhandled_print
  1525 00000F32 5E                      		pop		si
  1526 00000F33 B83A4E                  		mov		ax,0x4E00 | (':')
  1527 00000F36 67AB                    		a32 stosw
  1528 00000F38 AD                      		lodsw					; SI=address of variable
  1529 00000F39 56                      		push		si
  1530 00000F3A 89C6                    		mov		si,ax
  1531 00000F3C 6631C0                  		xor		eax,eax
  1532 00000F3F 8B04                    		mov		ax,[si]
  1533 00000F41 6657                    		push		edi
  1534 00000F43 66BF[04100000]          		mov		edi,scratch_str
  1535 00000F49 E85B03                  		call		eax_to_hex_16_dos
  1536 00000F4C 66678D7704              		lea		esi,[edi+4]
  1537 00000F51 665F                    		pop		edi
  1538 00000F53 E85000                  		call		.unhandled_print
  1539 00000F56 5E                      		pop		si
  1540 00000F57 B8204E                  		mov		ax,0x4E00 | (' ')
  1541 00000F5A 67AB                    		a32 stosw
  1542 00000F5C EBC5                    		jmp		.regprint16
  1543 00000F5E 665F                    .regprint16nl:	pop		edi
  1544 00000F60 6681C7A0000000          		add		edi,160			; move to next line, save back to [ESP]
  1545 00000F67 6657                    		push		edi
  1546 00000F69 EBB8                    		jmp		.regprint16
  1547 00000F6B BE[BF02]                .regprint16e:	mov		si,str_mode_prot	; CPU mode
  1548 00000F6E 66F706[1E29]000002-     		test		dword [unhandled_fault_var_eflags],0x20000
  1549 00000F76 00                 
  1550 00000F77 7403                    		jz		.regprint_cpu_mode_not_v86
  1551 00000F79 BE[CE02]                		mov		si,str_mode_v86
  1552                                  .regprint_cpu_mode_not_v86:
  1553 00000F7C E82700                  		call		.unhandled_print
  1554 00000F7F 665F                    		pop		edi
  1555                                  
  1556 00000F81 B020                    		mov		al,020h
  1557                                  
  1558 00000F83 E620                    		out		20h,al
  1559 00000F85 E620                    		out		20h,al
  1560 00000F87 E620                    		out		20h,al
  1561 00000F89 E620                    		out		20h,al
  1562 00000F8B E620                    		out		20h,al
  1563 00000F8D E620                    		out		20h,al
  1564 00000F8F E620                    		out		20h,al
  1565 00000F91 E620                    		out		20h,al
  1566                                  
  1567 00000F93 E6A0                    		out		0A0h,al
  1568 00000F95 E6A0                    		out		0A0h,al
  1569 00000F97 E6A0                    		out		0A0h,al
  1570 00000F99 E6A0                    		out		0A0h,al
  1571 00000F9B E6A0                    		out		0A0h,al
  1572 00000F9D E6A0                    		out		0A0h,al
  1573 00000F9F E6A0                    		out		0A0h,al
  1574 00000FA1 E6A0                    		out		0A0h,al
  1575                                  
  1576 00000FA3 FB                      		sti
  1577 00000FA4 EBFE                    		jmp		short $
  1578                                  ; ===== print on screen from DS:SI to ES:EDI
  1579                                  .unhandled_print:
  1580 00000FA6 AC                      		lodsb
  1581 00000FA7 3C24                    		cmp		al,'$'
  1582 00000FA9 7406                    		jz		.unhandled_printe
  1583 00000FAB B44E                    		mov		ah,0x4E
  1584 00000FAD 67AB                    		a32 stosw
  1585 00000FAF EBF5                    		jmp		.unhandled_print
  1586                                  .unhandled_printe:
  1587 00000FB1 C3                      		ret
  1588                                  
  1589                                  ; ============= Entry point (virtual 8086 mode)
  1590 00000FB2 FA                      vm86_entry:	cli				; make sure the v86 monitor handles CLI
  1591 00000FB3 FB                      		sti				; ...and STI
  1592 00000FB4 9C                      		pushf				; ...and PUSHF
  1593 00000FB5 9D                      		popf				; ...and POPF
  1594 00000FB6 669C                    		pushfd				; ...32-bit PUSHF
  1595 00000FB8 669D                    		popfd				; ...32-bit POPF
  1596 00000FBA E421                    		in		al,21h		; ...IN?
  1597 00000FBC E621                    		out		21h,al		; ...OUT?
  1598                                  
  1599                                  		; NOW MAKE SURE PUSHF/POPF STORE THE VALUE ON-STACK LIKE THEY'RE SUPPOSED TO
  1600 00000FBE 89E3                    		mov		bx,sp
  1601 00000FC0 36C747FE5A5A            		mov		word [ss:bx-2],0x5A5A
  1602 00000FC6 9C                      		pushf
  1603 00000FC7 89E3                    		mov		bx,sp
  1604 00000FC9 36813F5A5A              		cmp		word [ss:bx],0x5A5A
  1605 00000FCE 7506                    		jnz		.pushf_ok	; if the value DIDN'T CHANGE then the monitor failed to write FLAGS to stack
  1606 00000FD0 B80000                  		mov		ax,0
  1607 00000FD3 E9C400                  		jmp		vm86_errcode
  1608                                  .pushf_ok:
  1609                                  
  1610                                  		; DOES POPF WORK?
  1611 00000FD6 B89204                  		mov		ax,0x492
  1612 00000FD9 50                      		push		ax
  1613 00000FDA 9D                      		popf
  1614 00000FDB 9C                      		pushf
  1615 00000FDC 58                      		pop		ax
  1616 00000FDD 25D60F                  		and		ax,0xFD6
  1617 00000FE0 3D9204                  		cmp		ax,0x492
  1618 00000FE3 7406                    		jz		.popf_ok
  1619 00000FE5 B80100                  		mov		ax,1
  1620 00000FE8 E9AF00                  		jmp		vm86_errcode
  1621                                  .popf_ok:
  1622                                  
  1623                                  		; TEST 32-bit PUSHF
  1624 00000FEB 89E3                    		mov		bx,sp
  1625 00000FED 3666C747FC5A5A5A5A      		mov		dword [ss:bx-4],0x5A5A5A5A
  1626 00000FF6 669C                    		pushfd
  1627 00000FF8 89E3                    		mov		bx,sp
  1628 00000FFA 3666813F5A5A5A5A        		cmp		dword [ss:bx],0x5A5A5A5A
  1629 00001002 7506                    		jnz		.pushfd_ok	; if the value DIDN'T CHANGE then the monitor failed to write FLAGS to stack
  1630 00001004 B80200                  		mov		ax,2
  1631 00001007 E99000                  		jmp		vm86_errcode
  1632                                  .pushfd_ok:
  1633                                  
  1634                                  		; DOES POPFD WORK?
  1635 0000100A 66B892040000            		mov		eax,0x492
  1636 00001010 6650                    		push		eax
  1637 00001012 669D                    		popfd
  1638 00001014 669C                    		pushfd
  1639 00001016 6658                    		pop		eax
  1640 00001018 6625D60F0000            		and		eax,0xFD6
  1641 0000101E 663D92040000            		cmp		eax,0x492
  1642 00001024 7405                    		jz		.popfd_ok
  1643 00001026 B80300                  		mov		ax,3
  1644 00001029 EB6F                    		jmp		vm86_errcode
  1645                                  .popfd_ok:
  1646                                  
  1647                                  		; IF I CLEAR INTERRUPT (CLI) AND THEN EXECUTE AN INTERRUPT, DOES IT COME BACK ENABLED?
  1648 0000102B FA                      		cli
  1649 0000102C B40F                    		mov		ah,0x0F			; INT 10 AH=0x0F which has no visisible effect
  1650 0000102E CD10                    		int		10h
  1651 00001030 9C                      		pushf
  1652 00001031 58                      		pop		ax
  1653 00001032 A90002                  		test		ax,0x200
  1654 00001035 7405                    		jz		.int_doesnt_enable
  1655 00001037 B80400                  		mov		ax,4
  1656 0000103A EB5E                    		jmp		vm86_errcode
  1657                                  .int_doesnt_enable:
  1658                                  
  1659                                  		; HELLO WORLD!
  1660 0000103C BE[E002]                		mov		si,str_vm86_hello
  1661 0000103F E8DB01                  		call		bios_puts
  1662                                  
  1663                                  		; TEST DEFERRED IRQ MECHANISM BY DELIBERATLEY HALTING FOR AWHILE
  1664 00001042 FA                      		cli
  1665 00001043 66B900000001            		mov		ecx,0x1000000		; delibrate slow countdown loop
  1666 00001049 6649                    .l1:		dec		ecx
  1667 0000104B 75FC                    		jnz		.l1
  1668 0000104D FB                      		sti
  1669                                  
  1670                                  		; for my next trick, I will exit to DOS as a TSR
  1671                                  		; and allow the user to run the whole DOS kernel this way :)
  1672 0000104E 2E8E062C00              		mov		es,[cs:0x2C]		; locate our environment block and free it
  1673 00001053 B449                    		mov		ah,0x49			; function 49h free memory block
  1674 00001055 CD21                    		int		21h
  1675 00001057 7305                    		jnc		.env_free_ok
  1676 00001059 B80400                  		mov		ax,4
  1677 0000105C EB3C                    		jmp		vm86_errcode
  1678 0000105E 2EC7062C000000          .env_free_ok:	mov		word [cs:0x2C],0	; rub out the ENV block
  1679                                  
  1680                                  		; setup our INT 66h API
  1681 00001065 31C0                    		xor		ax,ax
  1682 00001067 8EC0                    		mov		es,ax
  1683 00001069 26C7069801[AB10]        		mov		word [es:(RM_INT_API*4)],realmode_api_entry
  1684 00001070 8CC8                    		mov		ax,cs
  1685 00001072 26A39A01                		mov		word [es:(RM_INT_API*4)+2],ax
  1686                                  
  1687                                  		; finally, terminate and stay resident
  1688 00001076 C606[ED28]01            		mov		byte [i_am_tsr],1
  1689 0000107B 66BA[4A290000]          		mov		edx,the_end		; DX = memory in paragraphs to save
  1690 00001081 6683C20F                		add		edx,15
  1691 00001085 66C1EA04                		shr		edx,4
  1692 00001089 6683C210                		add		edx,16			; <-- FIXME: IS THIS NECESSARY
  1693 0000108D B431                    		mov		ah,0x31			; function 31h terminate and stay resident
  1694 0000108F CD21                    		int		21h
  1695                                  
  1696                                  ; ============= "Secret Handshake" to exit back into the v86 monitor and shutdown the program (virtual 8086 mode)
  1697                                  ; TODO: Remove this, call into RM_INT_API instead
  1698 00001091 66B8BBAABBAA            vm86_exit:	mov		eax,0xAABBAABB
  1699 00001097 CD66                    		int		RM_INT_API
  1700 00001099 F4                      		hlt
  1701                                  
  1702                                  ; ============= If any of our self-test fails, we draw DIRECTLY ON VGA RAM and hike back into the vm86 monitor ASAP.
  1703                                  ;   if self-tests fail chances are calling the BIOS/DOS will cause major problems. AX=CODE
  1704 0000109A BB00B8                  vm86_errcode:	mov		bx,0xB800
  1705 0000109D 8EC3                    		mov		es,bx
  1706 0000109F 83E00F                  		and		ax,0xF
  1707 000010A2 0D304E                  		or		ax,0x4E30	; AX = VGA alphanumeric code for that number
  1708 000010A5 26A3A000                		mov		[es:160],ax
  1709 000010A9 EBE6                    		jmp		vm86_exit
  1710                                  
  1711                                  ; ============= Real-mode API entry (reflect to v86 monitor by executing an INT)
  1712                                  ;    this would allow the trick to work even for programs that direct-call instead
  1713                                  realmode_api_entry:
  1714 000010AB CD66                    		int		RM_INT_API
  1715 000010AD CF                      		iret
  1716                                  
  1717                                  ; ============= Parse command line (from PSP segment)
  1718 000010AE FC                      parse_argv:	cld
  1719 000010AF BE8100                  		mov		si,81h
  1720 000010B2 AC                      .scan:		lodsb
  1721 000010B3 08C0                    		or		al,al
  1722 000010B5 7410                    		jz		.done
  1723 000010B7 3C0D                    		cmp		al,0Dh
  1724 000010B9 740C                    		jz		.done
  1725 000010BB 3C20                    		cmp		al,20h
  1726 000010BD 74F3                    		jz		.scan
  1727 000010BF 3C2D                    		cmp		al,'-'
  1728 000010C1 7405                    		jz		.switch
  1729 000010C3 3C2F                    		cmp		al,'/'
  1730 000010C5 7401                    		jz		.switch
  1731                                  		; FALL THROUGH WITH ZF=0 to return
  1732 000010C7 C3                      .done:		ret
  1733                                  		; AT THIS POINT: SI = just after the / or - in the switch
  1734 000010C8 AC                      .switch:	lodsb
  1735 000010C9 3C3F                    		cmp		al,'?'
  1736 000010CB 7416                    		jz		.help
  1737 000010CD 3C41                    		cmp		al,'A'
  1738 000010CF 7215                    		jb		.unknown_switch
  1739 000010D1 3C5A                    		cmp		al,'Z'
  1740 000010D3 7711                    		ja		.unknown_switch
  1741                                  		; the A-Z switches are allowed to have "=NNNN" after them where N is some integer in hex or decimal
  1742 000010D5 2C41                    		sub		al,'A'
  1743 000010D7 88C3                    		mov		bl,al
  1744 000010D9 30FF                    		xor		bh,bh		; BX = index into lookup table
  1745 000010DB 01DB                    		add		bx,bx
  1746 000010DD FFA7[3111]              		jmp		word [bx+.switch_az]
  1747 000010E1 B001                    .fail:		mov		al,1
  1748 000010E3 08C0                    .help:		or		al,al		; AL != 0 => ZF=0
  1749 000010E5 C3                      		ret
  1750 000010E6 BA[5102]                .unknown_switch:mov		dx,str_unknown_switch
  1751 000010E9 E84501                  		call		dos_puts
  1752 000010EC 8D54FE                  		lea		dx,[si-2]	; step back two chars
  1753 000010EF C60424                  		mov		byte [si],'$'
  1754 000010F2 E83C01                  		call		dos_puts
  1755 000010F5 BA[5A01]                		mov		dx,str_crlf
  1756 000010F8 E83601                  		call		dos_puts
  1757 000010FB EBE4                    		jmp		.fail
  1758                                  ; ========== Switches CALL here if they need a numeric value to follow.
  1759                                  ; returns to caller if so, parsing as 16-bit integer returned in EAX. Else,
  1760                                  ; it discards the return address and jumps to the 'needs param' error message.
  1761                                  .switch_needs_equ_check:
  1762 000010FD 803C3D                  		cmp		byte [si],'='
  1763 00001100 7509                    		jnz		.switch_needs_equ_check_fail
  1764 00001102 46                      		inc		si
  1765 00001103 FA                      		cli
  1766 00001104 6631C0                  		xor		eax,eax
  1767 00001107 E83F01                  		call		ax_strtol_16
  1768 0000110A C3                      		ret
  1769                                  .switch_needs_equ_check_fail:
  1770 0000110B 83C402                  		add		sp,2		; fall through
  1771                                  .switch_needs_equ:
  1772 0000110E BA[6102]                		mov		dx,str_needs_equals
  1773 00001111 E81D01                  		call		dos_puts
  1774 00001114 EBCB                    		jmp		.fail
  1775                                  ; ========== /B=<number>
  1776                                  .switch_buffer_size:
  1777 00001116 E8E4FF                  		call		.switch_needs_equ_check
  1778 00001119 66C1E00A                		shl		eax,10
  1779 0000111D 66A3[0000]              		mov		[himem_sys_buffer_size],eax
  1780 00001121 EB8F                    		jmp		.scan
  1781                                  ; ========== /U
  1782 00001123 C606[EB28]01            .switch_unload:	mov		byte [user_req_unload],1
  1783 00001128 EB88                    		jmp		.scan
  1784                                  ; ========== /I
  1785 0000112A C606[EC28]00            .switch_iopl:	mov		byte [user_req_iopl],0
  1786 0000112F EB81                    		jmp		.scan
  1787                                  ; switch A-Z jump table
  1788 00001131 [E610]                  .switch_az:	dw		.unknown_switch			; /A
  1789 00001133 [1611]                  		dw		.switch_buffer_size		; /B=<number>
  1790 00001135 [E610]                  		dw		.unknown_switch			; /C
  1791 00001137 [E610]                  		dw		.unknown_switch			; /D
  1792 00001139 [E610]                  		dw		.unknown_switch			; /E
  1793 0000113B [E610]                  		dw		.unknown_switch			; /F
  1794 0000113D [E610]                  		dw		.unknown_switch			; /G
  1795 0000113F [E610]                  		dw		.unknown_switch			; /H
  1796 00001141 [2A11]                  		dw		.switch_iopl			; /I
  1797 00001143 [E610]                  		dw		.unknown_switch			; /J
  1798 00001145 [E610]                  		dw		.unknown_switch			; /K
  1799 00001147 [E610]                  		dw		.unknown_switch			; /L
  1800 00001149 [E610]                  		dw		.unknown_switch			; /M
  1801 0000114B [E610]                  		dw		.unknown_switch			; /N
  1802 0000114D [E610]                  		dw		.unknown_switch			; /O
  1803 0000114F [E610]                  		dw		.unknown_switch			; /P
  1804 00001151 [E610]                  		dw		.unknown_switch			; /Q
  1805 00001153 [E610]                  		dw		.unknown_switch			; /R
  1806 00001155 [E610]                  		dw		.unknown_switch			; /S
  1807 00001157 [E610]                  		dw		.unknown_switch			; /T
  1808 00001159 [2311]                  		dw		.switch_unload			; /U
  1809 0000115B [E610]                  		dw		.unknown_switch			; /V
  1810 0000115D [E610]                  		dw		.unknown_switch			; /W
  1811 0000115F [E610]                  		dw		.unknown_switch			; /X
  1812 00001161 [E610]                  		dw		.unknown_switch			; /Y
  1813 00001163 [E610]                  		dw		.unknown_switch			; /Z
  1814                                  
  1815 00001165 [8F05]                  irq_routines:	dw		irq_0
  1816 00001167 [9A05]                  		dw		irq_1
  1817 00001169 [A505]                  		dw		irq_2
  1818 0000116B [B005]                  		dw		irq_3
  1819 0000116D [BB05]                  		dw		irq_4
  1820 0000116F [C605]                  		dw		irq_5
  1821 00001171 [D105]                  		dw		irq_6
  1822 00001173 [DC05]                  		dw		irq_7
  1823 00001175 [E705]                  		dw		irq_8
  1824 00001177 [F205]                  		dw		irq_9
  1825 00001179 [FD05]                  		dw		irq_10
  1826 0000117B [0806]                  		dw		irq_11
  1827 0000117D [1306]                  		dw		irq_12
  1828 0000117F [1E06]                  		dw		irq_13
  1829 00001181 [2906]                  		dw		irq_14
  1830 00001183 [3406]                  		dw		irq_15
  1831                                  
  1832 00001185 [B706]                  fault_routines:	dw		fault_0x00
  1833 00001187 [CD06]                  		dw		fault_0x01
  1834 00001189 [FA06]                  		dw		fault_0x02
  1835 0000118B [1007]                  		dw		fault_0x03
  1836 0000118D [3D07]                  		dw		fault_0x04
  1837 0000118F [5307]                  		dw		fault_0x05
  1838 00001191 [6907]                  		dw		fault_0x06
  1839 00001193 [7F07]                  		dw		fault_0x07
  1840 00001195 [A407]                  		dw		fault_0x08
  1841 00001197 [B807]                  		dw		fault_0x09
  1842 00001199 [CE07]                  		dw		fault_0x0A
  1843 0000119B [E207]                  		dw		fault_0x0B
  1844 0000119D [F607]                  		dw		fault_0x0C
  1845 0000119F [2909]                  		dw		fault_0x0D
  1846 000011A1 [0A08]                  		dw		fault_0x0E
  1847 000011A3 [1E08]                  		dw		fault_0x0F
  1848 000011A5 [3408]                  		dw		fault_0x10
  1849 000011A7 [4A08]                  		dw		fault_0x11
  1850 000011A9 [6008]                  		dw		fault_0x12
  1851 000011AB [7608]                  		dw		fault_0x13
  1852 000011AD [8C08]                  		dw		fault_0x14
  1853 000011AF [9B08]                  		dw		fault_0x15
  1854 000011B1 [A708]                  		dw		fault_0x16
  1855 000011B3 [B308]                  		dw		fault_0x17
  1856 000011B5 [BF08]                  		dw		fault_0x18
  1857 000011B7 [CB08]                  		dw		fault_0x19
  1858 000011B9 [D708]                  		dw		fault_0x1A
  1859 000011BB [E308]                  		dw		fault_0x1B
  1860 000011BD [EF08]                  		dw		fault_0x1C
  1861 000011BF [FB08]                  		dw		fault_0x1D
  1862 000011C1 [0709]                  		dw		fault_0x1E
  1863 000011C3 [1309]                  		dw		fault_0x1F
  1864                                  
  1865                                  
  1866                                  ; register print list
  1867 000011C5 [7502][FA28]            printlist_32:	dw		str_eax,	unhandled_fault_var_eax
  1868 000011C9 [7902][FE28]            		dw		str_ebx,	unhandled_fault_var_ebx
  1869 000011CD [7D02][0229]            		dw		str_ecx,	unhandled_fault_var_ecx
  1870 000011D1 [8102][0629]            		dw		str_edx,	unhandled_fault_var_edx
  1871 000011D5 [8502][0A29]            		dw		str_esi,	unhandled_fault_var_esi
  1872 000011D9 [8902][0E29]            		dw		str_edi,	unhandled_fault_var_edi
  1873 000011DD 0100                    		dw		1
  1874 000011DF [8D02][1229]            		dw		str_ebp,	unhandled_fault_var_ebp
  1875 000011E3 [9102][1629]            		dw		str_esp,	unhandled_fault_var_esp
  1876 000011E7 [9502][1A29]            		dw		str_eip,	unhandled_fault_var_eip
  1877 000011EB [9D02][1E29]            		dw		str_eflags,	unhandled_fault_var_eflags
  1878 000011EF [9902][F628]            		dw		str_errcode,	unhandled_fault_var_errcode
  1879 000011F3 [A102][2229]            		dw		str_cr0,	unhandled_fault_var_cr0
  1880 000011F7 0100                    		dw		1
  1881 000011F9 [A502][2629]            		dw		str_cr3,	unhandled_fault_var_cr3
  1882 000011FD [A902][2A29]            		dw		str_cr4,	unhandled_fault_var_cr4
  1883 00001201 0000                    		dw		0
  1884 00001203 [AD02][2E29]            printlist_16:	dw		str_cs,		unhandled_fault_var_cs
  1885 00001207 [B002][3029]            		dw		str_ds,		unhandled_fault_var_ds
  1886 0000120B [B302][3229]            		dw		str_es,		unhandled_fault_var_es
  1887 0000120F [B602][3429]            		dw		str_fs,		unhandled_fault_var_fs
  1888 00001213 [B902][3629]            		dw		str_gs,		unhandled_fault_var_gs
  1889 00001217 [BC02][3829]            		dw		str_ss,		unhandled_fault_var_ss
  1890 0000121B 0000                    		dw		0
  1891                                  
  1892                                  ; ============= bios_puts (print $-terminated string at DS:SI)
  1893 0000121D FA                      bios_puts:	cli
  1894 0000121E FC                      		cld
  1895 0000121F 50                      		push		ax
  1896 00001220 53                      		push		bx
  1897 00001221 AC                      .putsloop:	lodsb
  1898 00001222 3C24                    		cmp		al,'$'
  1899 00001224 7408                    		jz		.putsend
  1900 00001226 B40E                    		mov		ah,0x0E
  1901 00001228 31DB                    		xor		bx,bx
  1902 0000122A CD10                    		int		10h
  1903 0000122C EBF3                    		jmp		.putsloop
  1904 0000122E 5B                      .putsend:	pop		bx
  1905 0000122F 58                      		pop		ax
  1906 00001230 C3                      		ret
  1907                                  
  1908                                  ; ============= dos_puts (print $-terminated string at DS:DX)
  1909 00001231 B409                    dos_puts:	mov		ah,09h
  1910 00001233 CD21                    		int		21h
  1911 00001235 C3                      		ret
  1912                                  
  1913                                  ; ============= read one digit from DS:SI return in AX (16-bit code)
  1914 00001236 8A04                    ax_strtol_16_single:mov		al,[si]
  1915 00001238 3C30                    		cmp		al,'0'
  1916 0000123A 720B                    		jb		.no
  1917 0000123C 3C39                    		cmp		al,'9'
  1918 0000123E 7707                    		ja		.no
  1919 00001240 2C30                    		sub		al,'0'
  1920 00001242 30E4                    		xor		ah,ah
  1921 00001244 46                      		inc		si
  1922 00001245 F8                      		clc
  1923 00001246 C3                      		ret
  1924 00001247 F9                      .no:		stc
  1925 00001248 C3                      		ret
  1926                                  
  1927                                  ; ============= read from DS:SI and convert numerical string to integer value return in AX (16-bit code)
  1928 00001249 31C9                    ax_strtol_16:	xor		cx,cx
  1929 0000124B 51                      .loop:		push		cx
  1930 0000124C E8E7FF                  		call		ax_strtol_16_single
  1931 0000124F 59                      		pop		cx
  1932 00001250 720D                    		jc		.done
  1933 00001252 89CB                    		mov		bx,cx
  1934 00001254 01DB                    		add		bx,bx
  1935 00001256 C1E103                  		shl		cx,3		; BX = CX * 2,  CX *= 8
  1936 00001259 01D9                    		add		cx,bx		; CX = (CX * 8) + (CX * 2) = CX * 10
  1937 0000125B 01C1                    		add		cx,ax		; CX += new digit
  1938 0000125D EBEC                    		jmp		.loop
  1939 0000125F 89C8                    .done:		mov		ax,cx
  1940 00001261 C3                      		ret
  1941                                  
  1942                                  ; ============= take AX and write to buffer (DS:SI) as hexadecimal string (16-bit code)
  1943 00001262 C6450224                al_to_hex_16_dos:mov		byte [di+2],'$'
  1944 00001266 EB04                    		jmp		al_to_hex_16
  1945 00001268 C6450200                al_to_hex_16_nul:mov		byte [di+2],0
  1946 0000126C 57                      al_to_hex_16:	push		di
  1947 0000126D 53                      		push		bx
  1948 0000126E 50                      		push		ax
  1949 0000126F 30FF                    		xor		bh,bh
  1950 00001271 88C4                    		mov		ah,al
  1951 00001273 240F                    		and		al,0xF
  1952 00001275 88C3                    		mov		bl,al
  1953 00001277 8A87[5D01]              		mov		al,[bx+str_hex]		; AL' = str_hex[al]
  1954 0000127B C0EC04                  		shr		ah,4
  1955 0000127E 88E3                    		mov		bl,ah
  1956 00001280 8AA7[5D01]              		mov		ah,[bx+str_hex]		; AH' = str_hex[ah]
  1957 00001284 8825                    		mov		[di+0],ah
  1958 00001286 884501                  		mov		[di+1],al
  1959 00001289 58                      		pop		ax
  1960 0000128A 5B                      		pop		bx
  1961 0000128B 5F                      		pop		di
  1962 0000128C C3                      		ret
  1963                                  
  1964                                  ; ============= take AX and write to buffer (DS:SI) as hexadecimal string (16-bit code)
  1965 0000128D C6450424                ax_to_hex_16_dos:mov		byte [di+4],'$'
  1966 00001291 EB04                    		jmp		ax_to_hex_16
  1967 00001293 C6450400                ax_to_hex_16_nul:mov		byte [di+4],0
  1968 00001297 57                      ax_to_hex_16:	push		di
  1969 00001298 50                      		push		ax
  1970 00001299 88E0                    		mov		al,ah
  1971 0000129B E8CEFF                  		call		al_to_hex_16
  1972 0000129E 58                      		pop		ax
  1973 0000129F 83C702                  		add		di,2
  1974 000012A2 E8C7FF                  		call		al_to_hex_16
  1975 000012A5 5F                      		pop		di
  1976 000012A6 C3                      		ret
  1977                                  
  1978                                  ; ============= take EAX and write to buffer (DS:DI) as hexadecimal string (16-bit code)
  1979 000012A7 C6450824                eax_to_hex_16_dos:mov		byte [di+8],'$'
  1980 000012AB EB04                    		jmp		eax_to_hex_16
  1981 000012AD C6450800                eax_to_hex_16_nul:mov		byte [di+8],0
  1982 000012B1 57                      eax_to_hex_16:	push		di
  1983 000012B2 6650                    		push		eax
  1984 000012B4 66C1E810                		shr		eax,16
  1985 000012B8 E8DCFF                  		call		ax_to_hex_16
  1986 000012BB 6658                    		pop		eax
  1987 000012BD 83C704                  		add		di,4
  1988 000012C0 E8D4FF                  		call		ax_to_hex_16
  1989 000012C3 5F                      		pop		di
  1990 000012C4 C3                      		ret
  1991                                  
  1992                                  ; ============= /U Unloading the resident copy of this program
  1993                                  unload_this_program:
  1994 000012C5 0F01E0                  		smsw		ax
  1995 000012C8 A801                    		test		al,1
  1996 000012CA 7506                    		jnz		.v86_active
  1997 000012CC BA[7700]                		mov		dx,str_not_loaded
  1998 000012CF E980ED                  		jmp		_exit_with_msg
  1999                                  .v86_active:
  2000 000012D2 31C0                    		xor		ax,ax
  2001 000012D4 8EC0                    		mov		es,ax
  2002 000012D6 268B1E9801              		mov		bx,[es:(RM_INT_API*4)]
  2003 000012DB 260B0E9A01              		or		cx,[es:(RM_INT_API*4)+2]
  2004 000012E0 83F900                  		cmp		cx,0		; if pointer is 0000:0000
  2005 000012E3 7434                    		jz		.v86_not_me
  2006 000012E5 66B855AABBAA            		mov		eax,0xAABBAA55
  2007 000012EB CD66                    		int		RM_INT_API
  2008 000012ED 663D33BBAABB            		cmp		eax,0xBBAABB33
  2009 000012F3 7524                    		jnz		.v86_not_me
  2010 000012F5 8CC8                    .v86_is_me:	mov		ax,cs
  2011 000012F7 8ED8                    		mov		ds,ax
  2012 000012F9 8EC0                    		mov		es,ax
  2013 000012FB 8EE0                    		mov		fs,ax
  2014 000012FD 8EE8                    		mov		gs,ax
  2015 000012FF BA[1B00]                		mov		dx,str_removing_self
  2016 00001302 E82CFF                  		call		dos_puts
  2017                                  ; instruct it to remove itself
  2018 00001305 66B8BBAABBAA            		mov		eax,0xAABBAABB
  2019 0000130B CD66                    		int		RM_INT_API
  2020                                  ; exit, having done our job
  2021 0000130D BA[5A01]                		mov		dx,str_crlf
  2022 00001310 E81EFF                  		call		dos_puts
  2023 00001313 BA[4301]                		mov		dx,str_unloaded
  2024 00001316 E939ED                  		jmp		_exit_with_msg
  2025 00001319 BA[5300]                .v86_not_me:	mov		dx,str_v86_but_not_me
  2026 0000131C E933ED                  		jmp		_exit_with_msg
  2027                                  
  2028                                  ; ============= DATA: THESE EXIST IN THE .COM BINARY IMAGE
  2029                                  		section		.data align=2
  2030 00000000 00000400                himem_sys_buffer_size:dd	(256*1024)	; DWORD [amount of extended memory to allocate]
  2031 00000004 333836206F72206869-     str_require_386:db		'386 or higher required$'
  2032 0000000D 676865722072657175-
  2033 00000016 6972656424         
  2034 0000001B 52656D6F76696E6720-     str_removing_self:db		'Removing from memory',13,10,'$'
  2035 00000024 66726F6D206D656D6F-
  2036 0000002D 72790D0A24         
  2037 00000032 5669727475616C2038-     str_v86_detected:db		'Virtual 8086 mode already active$'
  2038 0000003B 303836206D6F646520-
  2039 00000044 616C72656164792061-
  2040 0000004D 637469766524       
  2041 00000053 5669727475616C2038-     str_v86_but_not_me:db		'Virtual 8086 active, and its not me$'
  2042 0000005C 303836206163746976-
  2043 00000065 652C20616E64206974-
  2044 0000006E 73206E6F74206D6524 
  2045 00000077 4E6F74207265736964-     str_not_loaded:	db		'Not resident in memory$'
  2046 00000080 656E7420696E206D65-
  2047 00000089 6D6F727924         
  2048 0000008E 43616E6E6F74206672-     str_cannot_free_self:db		'Cannot free self from memory$'
  2049 00000097 65652073656C662066-
  2050 000000A0 726F6D206D656D6F72-
  2051 000000A9 7924               
  2052 000000AB 48494D454D2E535953-     str_need_himem_sys:db		'HIMEM.SYS not installed$'
  2053 000000B4 206E6F7420696E7374-
  2054 000000BD 616C6C656424       
  2055 000000C3 48494D454D2E535953-     str_himem_a20_error:db		'HIMEM.SYS failed to enable A20$'
  2056 000000CC 206661696C65642074-
  2057 000000D5 6F20656E61626C6520-
  2058 000000DE 41323024           
  2059 000000E2 556E61626C6520746F-     str_himem_alloc_err:db		'Unable to alloc extended memory$'
  2060 000000EB 20616C6C6F63206578-
  2061 000000F4 74656E646564206D65-
  2062 000000FD 6D6F727924         
  2063 00000102 556E61626C6520746F-     str_himem_lock_err:db		'Unable to lock extended memory$'
  2064 0000010B 206C6F636B20657874-
  2065 00000114 656E646564206D656D-
  2066 0000011D 6F727924           
  2067 00000121 42756666657220746F-     str_buffer_too_small:db		'Buffer too small$'
  2068 0000012A 6F20736D616C6C24   
  2069 00000132 42756666657220746F-     str_buffer_too_large:db		'Buffer too large$'
  2070 0000013B 6F206C6172676524   
  2071 00000143 556E6C6F616465640D-     str_unloaded:	db		'Unloaded',13,10,'$'
  2072 0000014C 0A24               
  2073 0000014E 427566666572206174-     str_buffer_at:	db		'Buffer at: $'
  2074 00000157 3A2024             
  2075 0000015A 0D0A24                  str_crlf:	db		13,10,'$'
  2076 0000015D 303132333435363738-     str_hex:	db		'0123456789ABCDEF'
  2077 00000166 39414243444546     
  2078 0000016D 5638364B45524E205B-     str_help:	db		'V86KERN [options]',13,10
  2079 00000176 6F7074696F6E735D0D-
  2080 0000017F 0A                 
  2081 00000180 44656D6F6E73747261-     		db		'Demonstration Virtual 8086 kernel/monitor',13,10
  2082 00000189 74696F6E2056697274-
  2083 00000192 75616C203830383620-
  2084 0000019B 6B65726E656C2F6D6F-
  2085 000001A4 6E69746F720D0A     
  2086 000001AB 0D0A                    		db		13,10
  2087 000001AD 4F7074696F6E732073-     		db		'Options start with - or /',13,10
  2088 000001B6 746172742077697468-
  2089 000001BF 202D206F72202F0D0A 
  2090 000001C8 20202F3F2020202020-     		db		'  /?      Show this help',13,10
  2091 000001D1 2053686F7720746869-
  2092 000001DA 732068656C700D0A   
  2093 000001E2 20202F423D2E2E2E20-     		db		'  /B=...  Set buffer size (in KB)',13,10
  2094 000001EB 205365742062756666-
  2095 000001F4 65722073697A652028-
  2096 000001FD 696E204B42290D0A   
  2097 00000205 20202F552020202020-     		db		'  /U      Unload the kernel',13,10
  2098 0000020E 20556E6C6F61642074-
  2099 00000217 6865206B65726E656C-
  2100 00000220 0D0A               
  2101 00000222 20202F492020202020-     		db		'  /I      Run with IOPL=3 (trap CLI/STI/etc)',13,10
  2102 0000022B 2052756E2077697468-
  2103 00000234 20494F504C3D332028-
  2104 0000023D 7472617020434C492F-
  2105 00000246 5354492F657463290D-
  2106 0000024F 0A                 
  2107 00000250 24                      		db		'$'
  2108 00000251 556E6B6E6F776E2073-     str_unknown_switch:db		'Unknown switch $'
  2109 0000025A 77697463682024     
  2110 00000261 537769746368206D69-     str_needs_equals:db		'Switch missing =...$'
  2111 0000026A 7373696E67203D2E2E-
  2112 00000273 2E24               
  2113 00000275 45415824                str_eax:	db		'EAX$'
  2114 00000279 45425824                str_ebx:	db		'EBX$'
  2115 0000027D 45435824                str_ecx:	db		'ECX$'
  2116 00000281 45445824                str_edx:	db		'EDX$'
  2117 00000285 45534924                str_esi:	db		'ESI$'
  2118 00000289 45444924                str_edi:	db		'EDI$'
  2119 0000028D 45425024                str_ebp:	db		'EBP$'
  2120 00000291 45535024                str_esp:	db		'ESP$'
  2121 00000295 45495024                str_eip:	db		'EIP$'
  2122 00000299 45525224                str_errcode:	db		'ERR$'
  2123 0000029D 464C4724                str_eflags:	db		'FLG$'
  2124 000002A1 43523024                str_cr0:	db		'CR0$'
  2125 000002A5 43523324                str_cr3:	db		'CR3$'
  2126 000002A9 43523424                str_cr4:	db		'CR4$'
  2127 000002AD 435324                  str_cs:		db		'CS$'
  2128 000002B0 445324                  str_ds:		db		'DS$'
  2129 000002B3 455324                  str_es:		db		'ES$'
  2130 000002B6 465324                  str_fs:		db		'FS$'
  2131 000002B9 475324                  str_gs:		db		'GS$'
  2132 000002BC 535324                  str_ss:		db		'SS$'
  2133 000002BF 50726F746563746564-     str_mode_prot:	db		'Protected mode$'
  2134 000002C8 206D6F646524       
  2135 000002CE 5669727475616C2038-     str_mode_v86:	db		'Virtual 8086 mode$'
  2136 000002D7 303836206D6F646524 
  2137 000002E0 546869732074657874-     str_vm86_hello:	db		'This text was printed by the Virtual 8086 mode component of this program',13,10,'$'
  2138 000002E9 20776173207072696E-
  2139 000002F2 746564206279207468-
  2140 000002FB 65205669727475616C-
  2141 00000304 2038303836206D6F64-
  2142 0000030D 6520636F6D706F6E65-
  2143 00000316 6E74206F6620746869-
  2144 0000031F 732070726F6772616D-
  2145 00000328 0D0A24             
  2146 0000032B 446976696465206279-     str_fault_0x00:	db		'Divide by Zero$'
  2147 00000334 205A65726F24       
  2148 0000033A 446562756724            str_fault_0x01:	db		'Debug$'
  2149 00000340 4E4D4924                str_fault_0x02:	db		'NMI$'
  2150 00000344 427265616B706F696E-     str_fault_0x03:	db		'Breakpoint$'
  2151 0000034D 7424               
  2152 0000034F 4F766572666C6F7724      str_fault_0x04:	db		'Overflow$'
  2153 00000358 426F756E6461727920-     str_fault_0x05:	db		'Boundary Check$'
  2154 00000361 436865636B24       
  2155 00000367 496E76616C6964204F-     str_fault_0x06:	db		'Invalid Opcode$'
  2156 00000370 70636F646524       
  2157 00000376 436F70726F63657373-     str_fault_0x07:	db		'Coprocessor N/A$'
  2158 0000037F 6F72204E2F4124     
  2159 00000386 446F75626C65204661-     str_fault_0x08:	db		'Double Fault$'
  2160 0000038F 756C7424           
  2161 00000393 436F70726F63657373-     str_fault_0x09:	db		'Coprocessor Segment Overrun$'
  2162 0000039C 6F72205365676D656E-
  2163 000003A5 74204F76657272756E-
  2164 000003AE 24                 
  2165 000003AF 496E76616C69642054-     str_fault_0x0A:	db		'Invalid TSS$'
  2166 000003B8 535324             
  2167 000003BB 5365676D656E74204E-     str_fault_0x0B:	db		'Segment Not Present$'
  2168 000003C4 6F742050726573656E-
  2169 000003CD 7424               
  2170 000003CF 537461636B20466175-     str_fault_0x0C:	db		'Stack Fault$'
  2171 000003D8 6C7424             
  2172 000003DB 47656E6572616C2050-     str_fault_0x0D:	db		'General Protection Fault$'
  2173 000003E4 726F74656374696F6E-
  2174 000003ED 204661756C7424     
  2175 000003F4 50616765204661756C-     str_fault_0x0E:	db		'Page Fault$'
  2176 000003FD 7424               
  2177 000003FF 457863657074696F6E-     str_fault_0x0F:	db		'Exception F$'
  2178 00000408 204624             
  2179 0000040B 465055204572726F72-     str_fault_0x10:	db		'FPU Error$'
  2180 00000414 24                 
  2181 00000415 416C69676E6D656E74-     str_fault_0x11:	db		'Alignment Check$'
  2182 0000041E 20436865636B24     
  2183 00000425 4D616368696E652043-     str_fault_0x12:	db		'Machine Check$'
  2184 0000042E 6865636B24         
  2185 00000433 53494D442F53534520-     str_fault_0x13:	db		'SIMD/SSE Exception$'
  2186 0000043C 457863657074696F6E-
  2187 00000445 24                 
  2188 00000446 556E6B6E6F776E2065-     str_fault_unknown:db		'Unknown exception$'
  2189 0000044F 7863657074696F6E24 
  2190 00000458 556E6B6E6F776E2069-     str_v86_unknown:db		'Unknown instruction in v86 mode$'
  2191 00000461 6E737472756374696F-
  2192 0000046A 6E20696E2076383620-
  2193 00000473 6D6F646524         
  2194 00000478 7638362068616C7420-     str_v86_hlt_cli:db		'v86 halt with interrupts disabled$'
  2195 00000481 7769746820696E7465-
  2196 0000048A 727275707473206469-
  2197 00000493 7361626C656424     
  2198 0000049A 496E617070726F7072-     str_v86_secret:	db		'Inappropriate use of v86 secret handshake$'
  2199 000004A3 696174652075736520-
  2200 000004AC 6F6620763836207365-
  2201 000004B5 637265742068616E64-
  2202 000004BE 7368616B6524       
  2203 000004C4 53687574646F776E20-     str_exit_to_dos:db		'Shutdown successful, exiting to DOS$'
  2204 000004CD 737563636573736675-
  2205 000004D6 6C2C2065786974696E-
  2206 000004DF 6720746F20444F5324 
  2207 000004E8 446566657272656420-     str_irq_deferred:db		'Deferred IRQ$'
  2208 000004F1 49525124           
  2209 000004F5 49525120233124          str_irq_1:	db		'IRQ #1$'
  2210                                  
  2211                                  ; ============= VARIABLES: THESE DO NOT EXIST IN THE .COM FILE THEY EXIST IN MEMORY FOLLOWING THE BINARY IMAGE
  2212                                  		section		.bss align=2
  2213                                  ; ---------------------- STACK
  2214 00000000 <res 00001000>          stack_base:	resb		4096		; char[4096+4]
  2215 00001000 <res 00000004>          stack_init:	resd		1		; DWORD
  2216                                  stack_top:
  2217 00001004 <res 00000040>          scratch_str:	resb		64		; char[64]
  2218                                  ; ---------------------- STACK
  2219 00001044 <res 00001000>          stack_base_vm86:resb		4096		; char[4096+4]
  2220 00002044 <res 00000008>          stack_init_vm86:resd		2		; DWORD
  2221                                  stack_top_vm86:
  2222                                  ; ---------------------- HIMEM.SYS state
  2223 0000204C <res 00000004>          himem_sys_entry:resd		1		; FAR POINTER
  2224 00002050 <res 00000004>          himem_sys_buffer_phys:resd	1		; DWORD [physical memory address]
  2225 00002054 <res 00000002>          himem_sys_buffer_handle:resw	1		; WORD [HIMEM.SYS handle]
  2226                                  ; ---------------------- my real mode segment
  2227 00002056 <res 00000002>          my_realmode_seg:resw		1		; WORD
  2228 00002058 <res 00000004>          my_phys_base:	resd		1		; DWORD
  2229 0000205C <res 00000004>          tss_phys_base:	resd		1		; DWORD base logical address of TSS
  2230 00002060 <res 00000004>          tss_vm86_phys_base:resd		1		; DWORD base logical address of TSS
  2231 00002064 <res 00000004>          buffer_alloc:	resd		1		; DWORD
  2232 00002068 <res 00000004>          kern32_stack_base:resd		1		; DWORD
  2233 0000206C <res 00000004>          kern32_stack_top:resd		1		; DWORD
  2234 00002070 <res 00000004>          v86_raw_opcode:	resd		1		; DWORD
  2235 00002074 <res 00000004>          		resd		1		; *PADDING*
  2236                                  ; ---------------------- GDTR/IDTR
  2237 00002078 <res 00000008>          gdtr_pmode:	resq		1		; LIMIT. BASE
  2238 00002080 <res 00000008>          gdtr_real:	resq		1		; LIMIT, BASE
  2239 00002088 <res 00000008>          idtr_pmode:	resq		1		; LIMIT, BASE
  2240 00002090 <res 00000008>          idtr_real:	resq		1		; LIMIT, BASE
  2241                                  ; ---------------------- GLOBAL DESCRIPTOR TABLE
  2242                                  		align		8
  2243 00002098 <res 00000050>          gdt:		resq		(MAX_SEL/8)	; 16 GDT entries
  2244                                  ; ---------------------- INTERRUPT DESCRIPTOR TABLE
  2245                                  		align		8
  2246 000020E8 <res 00000800>          idt:		resq		256		; all 256
  2247                                  ; ---------------------- STATE
  2248 000028E8 <res 00000002>          irq_pending:	resw		1
  2249 000028EA <res 00000001>          v86_if:		resb		1
  2250 000028EB <res 00000001>          user_req_unload:resb		1
  2251 000028EC <res 00000001>          user_req_iopl:	resb		1
  2252 000028ED <res 00000001>          i_am_tsr:	resb		1
  2253 000028EE <res 00000004>          unload_int_ret:	resd		1
  2254 000028F2 <res 00000004>          unload_int_stk:	resd		1
  2255                                  ; ---------------------- WHEN DISPLAYING THE UNHANDLED FAULT DIALOG
  2256 000028F6 <res 00000004>          unhandled_fault_var_errcode:resd	1
  2257 000028FA <res 00000004>          unhandled_fault_var_eax:resd		1
  2258 000028FE <res 00000004>          unhandled_fault_var_ebx:resd		1
  2259 00002902 <res 00000004>          unhandled_fault_var_ecx:resd		1
  2260 00002906 <res 00000004>          unhandled_fault_var_edx:resd		1
  2261 0000290A <res 00000004>          unhandled_fault_var_esi:resd		1
  2262 0000290E <res 00000004>          unhandled_fault_var_edi:resd		1
  2263 00002912 <res 00000004>          unhandled_fault_var_ebp:resd		1
  2264 00002916 <res 00000004>          unhandled_fault_var_esp:resd		1
  2265 0000291A <res 00000004>          unhandled_fault_var_eip:resd		1
  2266 0000291E <res 00000004>          unhandled_fault_var_eflags:resd		1
  2267 00002922 <res 00000004>          unhandled_fault_var_cr0:resd		1
  2268 00002926 <res 00000004>          unhandled_fault_var_cr3:resd		1
  2269 0000292A <res 00000004>          unhandled_fault_var_cr4:resd		1
  2270 0000292E <res 00000002>          unhandled_fault_var_cs:resw		1
  2271 00002930 <res 00000002>          unhandled_fault_var_ds:resw		1
  2272 00002932 <res 00000002>          unhandled_fault_var_es:resw		1
  2273 00002934 <res 00000002>          unhandled_fault_var_fs:resw		1
  2274 00002936 <res 00000002>          unhandled_fault_var_gs:resw		1
  2275 00002938 <res 00000002>          unhandled_fault_var_ss:resw		1
  2276                                  ; ---------------------------------------------------------------------
  2277                                  ;                       END POINTER
  2278                                  ; ---------------------------------------------------------------------
  2279 0000293A <res 00000010>          padding:	resq		2		; SAFETY PADDING
  2280                                  the_end:
